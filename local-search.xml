<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2025/03/%E7%AC%94%E8%AE%B0/Git/"/>
    <url>/2025/03/%E7%AC%94%E8%AE%B0/Git/</url>
    
    <content type="html"><![CDATA[<h3 id="git快速入门"><a href="#git快速入门" class="headerlink" title="git快速入门"></a>git快速入门</h3><p>Git 完整命令手册地址：<a href="http://git-scm.com/docs">Git 官方文档</a></p><p>PDF 版命令手册：<a href="https://www.runoob.com/manual/github-git-cheat-sheet.pdf">github-git-cheat-sheet.pdf</a></p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a><strong>基础操作</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化新仓库</td></tr><tr><td align="left"><code>git clone &lt;url&gt;</code></td><td align="left">克隆远程仓库</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看工作区状态</td></tr><tr><td align="left"><code>git add &lt;file&gt; </code></td><td align="left">添加文件到暂存区</td></tr><tr><td align="left"><code>git add .</code></td><td align="left">添加所有修改到暂存区</td></tr><tr><td align="left"><code>git commit -m &quot;message&quot;</code></td><td align="left">提交更改到本地仓库</td></tr><tr><td align="left"><code>git commit --amend</code></td><td align="left">修改最后一次提交</td></tr></tbody></table><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a><strong>分支管理</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git branch</code></td><td align="left">查看本地分支</td></tr><tr><td align="left"><code>git branch </code></td><td align="left">创建新分支</td></tr><tr><td align="left"><code>git checkout </code></td><td align="left">切换分支</td></tr><tr><td align="left"><code>git checkout -b </code></td><td align="left">创建并切换分支</td></tr><tr><td align="left"><code>git merge &lt;branch&gt; </code></td><td align="left">合并分支到当前分支</td></tr><tr><td align="left"><code>git branch -d </code></td><td align="left">删除本地分支</td></tr><tr><td align="left"><code>git push origin --delete &lt;branch&gt; </code></td><td align="left">删除远程分支</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a><strong>远程操作</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote -v</code></td><td align="left">查看远程仓库地址</td></tr><tr><td align="left"><code>git pull origin &lt;branch&gt; </code></td><td align="left">拉取远程分支并合并</td></tr><tr><td align="left"><code>git push origin &lt;branch&gt;</code></td><td align="left">推送本地分支到远程</td></tr><tr><td align="left"><code>git fetch --all</code></td><td align="left">获取所有远程更新（不自动合并）</td></tr></tbody></table><h3 id="撤销与回退"><a href="#撤销与回退" class="headerlink" title="撤销与回退"></a><strong>撤销与回退</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git restore &lt;file&gt;</code></td><td align="left">撤销工作区修改</td></tr><tr><td align="left"><code>git restore --staged &lt;file&gt; </code></td><td align="left">撤销暂存区修改</td></tr><tr><td align="left"><code>git reset --hard HEAD^</code></td><td align="left">回退到上一个提交（彻底删除更改）</td></tr><tr><td align="left"><code>git reset --soft HEAD^</code></td><td align="left">回退提交但保留更改到暂存区</td></tr><tr><td align="left"><code>git revert &lt;commit-id&gt; </code></td><td align="left">撤销指定提交（生成新提交）</td></tr></tbody></table><h3 id="日志与对比"><a href="#日志与对比" class="headerlink" title="日志与对比"></a><strong>日志与对比</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看提交历史</td></tr><tr><td align="left"><code>git log --oneline --graph</code></td><td align="left">简洁版提交历史（带分支图）</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">查看工作区与暂存区的差异</td></tr><tr><td align="left"><code>git diff --cached</code></td><td align="left">查看暂存区与仓库的差异</td></tr></tbody></table><h3 id="临时修改用户名和邮箱"><a href="#临时修改用户名和邮箱" class="headerlink" title="临时修改用户名和邮箱"></a><strong>临时修改用户名和邮箱</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git config user.name &quot;新用户名&quot;</code></td><td align="left">修改用户名</td></tr><tr><td align="left"><code>git config user.email &quot;新邮箱地址&quot;</code></td><td align="left">修改邮箱</td></tr><tr><td align="left"><code>git config user.name</code></td><td align="left">查看用户名</td></tr><tr><td align="left"><code>git config user.email</code></td><td align="left">查看邮箱</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++内存池</title>
    <link href="/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%86%85%E5%AD%98%E6%B1%A0%E9%A1%B9%E7%9B%AE/"/>
    <url>/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%86%85%E5%AD%98%E6%B1%A0%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="内存池介绍"><a href="#内存池介绍" class="headerlink" title="内存池介绍"></a>内存池介绍</h3><h4 id="什么是内存池"><a href="#什么是内存池" class="headerlink" title="什么是内存池"></a>什么是内存池</h4><p><strong>内存池是一种预分配内存并且进行重复利用的技术</strong>，通过减少频繁的动态内存分配与释放操作，从而提高程序的运行效率。内存池通常预先分配一块大的区域，将其划分为多个小块，每次需要分配内存时直接从这块区域分配，而不是调用系统的动态分配函数（如new或者malloc）。简单来说就是申请一块较大的内存块（不够就继续申请），之后将这块内存的管理放在应用层执行，减少系统调用带来的开销。</p><h4 id="为什么要做内存池"><a href="#为什么要做内存池" class="headerlink" title="为什么要做内存池"></a>为什么要做内存池</h4><h5 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h5><ul><li><p><strong>减少动态内存分配的开销</strong>：系统调用malloc&#x2F;new和free&#x2F;delete涉及复杂的内存管理操作（如内存查找、碎片整理），导致性能较低，而内存池通过预分配和简单的管理逻辑显著提高了分配和释放的效率。</p></li><li><p><strong>避免内存碎片</strong>：动态分配内存会产生内存碎片，尤其在大量小对象频繁分配和释放的场景中，导致的后果就是：当程序长时间运行时，由于所申请的内存块的大小不定，频繁使用时会造成大量的内存碎片从而降低程序和操作系统的性能。内存池通过管理固定大小的内存块，可以有效避免碎片化。</p></li><li><p><strong>降低系统调用频率</strong>：系统级内存分配（如malloc）需要进入内核态，频繁调用会有较高的性能开销。内存池通过减少系统调用频率提高程序效率。</p></li></ul><h5 id="确定性（实时性）："><a href="#确定性（实时性）：" class="headerlink" title="确定性（实时性）："></a>确定性（实时性）：</h5><ul><li><strong>稳定的分配时间</strong>：使用内存池可以使分配和释放操作的耗时更加可控和稳定，适合实时性有严格要求的系统。</li></ul><h4 id="内存池的应用场景："><a href="#内存池的应用场景：" class="headerlink" title="内存池的应用场景："></a>内存池的应用场景：</h4><h5 id="高频小对象分配："><a href="#高频小对象分配：" class="headerlink" title="高频小对象分配："></a>高频小对象分配：</h5><ul><li><p><strong>游戏开发</strong>：游戏中大量小对象（如粒子、子弹、NPC）的动态分配和释放非常频繁，使用内存池可以显著优化性能。</p></li><li><p><strong>网络编程</strong>：网络编程中，大量请求和响应对象（如消息报文）和频繁创建和销毁非常适合使用内存池。</p></li><li><p><strong>内存管理库</strong>：一些容器或数据结构（如std::vector或std::deque）在内部可能使用内存池来优化分配性能。</p></li></ul><h5 id="实时系统："><a href="#实时系统：" class="headerlink" title="实时系统："></a>实时系统：</h5><ul><li>嵌入式设备或实时控制系统中，动态内存分配的延迟可能影响实时性，内存池提供确定性的分配性能。</li></ul><h5 id="高性能计算："><a href="#高性能计算：" class="headerlink" title="高性能计算："></a>高性能计算：</h5><ul><li>在高性能计算程序中，频繁地内存分配和释放会拖累整个程序的性能，内存池可以优化内存管理</li></ul><h5 id="服务器开发："><a href="#服务器开发：" class="headerlink" title="服务器开发："></a>服务器开发：</h5><ul><li>数据库服务器、web服务器等需要管理大量连接和请求，这些连接涉及大量内存分配，内存池能有效提升服务器性能。</li></ul><h4 id="内存池在代码中的应用"><a href="#内存池在代码中的应用" class="headerlink" title="内存池在代码中的应用"></a>内存池在代码中的应用</h4><ul><li><p>对new&#x2F;malloc&#x2F;delete&#x2F;free等动态开辟内存的系统调用进行替换</p></li><li><p>对STL众多容器中的空间配置器std::allocator进行替换</p></li></ul><h4 id="内存池的缺点"><a href="#内存池的缺点" class="headerlink" title="内存池的缺点"></a>内存池的缺点</h4><ul><li><p><strong>初始内存占用</strong>：内存池需要预先分配较大的内存区域，可能浪费一些内存。</p></li><li><p><strong>复杂性</strong>：实现和调试内存池代码比直接使用 malloc &#x2F; new 更复杂。</p></li><li><p><strong>不适合大型对象</strong>：对于大对象的分配可能并不划算。</p></li></ul><h3 id="项目框架"><a href="#项目框架" class="headerlink" title="项目框架"></a>项目框架</h3><p>内存池本质：预先向系统申请一大片内存，并交由应用层管理，在程序运行时，内存的分配和回收都由应用层的内存池处理，从而减少系统调用。</p><p>该项目实现的是基于<strong>哈希映射的多种定长内存分配器（内存池中的一种）</strong>：</p><img src="../img/1.jpg" alt="内存池示意图" style="width: 50%;"><p>主要框架如上图所示，主要是维护一个哈希桶 MemoryPools，里面每项对应一个内存池 MemoryPool，哈希桶中每个内存池的块大小 BlockSize 是相同的（4096字节，可以设置为不同），但是每个内存池里每个块分割的大小（槽大小）SlotSize是不同的，依次为8,16,32,…,512字节（<strong>需要的内存超过512字节就用new&#x2F;malloc</strong>），用户申请不同大小的内存就通过哈希桶的映射找到相应（槽大小）  SlotSize 的内存池向其申请，比如用户分别申请8字节和12字节的内存，则经过哈希函数的计算找到槽大小为8字节的内存池和槽大小为16字节（哈希函数向上取整，因为分配给用户的内存块只能大不能小）的内存池分别分配内存给用户，这样设置的好处是<strong>可以保证内存碎片在可控范围内</strong>。</p><p><strong>为什么用户申请超过512字节的内存就直接调用 new&#x2F;malloc 等系统调用？</strong></p><p><strong>因为内存池主要解决的是 小内存带来的内存碎片问题 和 小内存频繁申请释放带来的性能问题。</strong>（频繁申请小内存带来的问题可参考：<a href="https://blog.csdn.net/LF_2016/article/details/53511648">https://blog.csdn.net/LF_2016/article/details/53511648</a>）</p><p>每个内存池的内部结构图：</p><img src="../img/2.jpg" alt="内存池示意图" style="width: 50%;"><ul><li><strong>Slot currentBlock</strong>：内存池实际上是一个一个的 Block 以链表的形式连接起来，每一个 Block 是一块大的内存，当内存池的内存不足的时候，就会向操作系统申请新的 block 加入链表。</li><li><strong>Slot freeSlot</strong>：链表里面的每一项都是对象被释放后归还给内存池的空间，内存池刚创建时 freeSlot 是空的。用户创建对象，将对象释放时，把内存归还给内存池，此时内存池不会将内存归还给系统（delete&#x2F;free），而是把指向这个对象的内存的指针加到 freeSlot 链表的前面（前插），之后用户每次申请内存时，memoryPool就先在这个 freeSlot 链表里面找。</li><li><strong>Slot curretSlot</strong>：用户在创建对象的时候，先检查 freeSlot 是否为空，不为空的时候直接取出一项作为分配出的空间。否则就在当前 Block 将 currentSlot 所指的内存分配出去，如果 Block 里面的内存已经使用完，就向操作系统申请一个新的 Block。</li></ul><p><strong>整体流程图</strong></p><img src="../img/3.jpg" alt="内存池示意图" style="width: 50%;"><p>该项目对外提供了两个重要的接口newElement和deleteElement，分别是向内存池申请内存和将申请的内存进行回收操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">T* <span class="hljs-title">newElement</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p>用户在构造对象T的时候通过调用newElement<T>()方法申请内存，newElement<T>()方法计算出元素T的大小后传入哈希桶中，哈希桶中根据哈希映射选择相应槽大小的内存池去分配内存返回（分配内存时优先使用FreeList_里的空闲内存槽，其次再找curSlot_，如果curSlot_大于等于lastSot_，则重新申请一块内存块来分配内存槽），newElement函数获得内存之后，在该内存上构造对象T后将地址返回给用户。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteElement</span><span class="hljs-params">(T* p)</span></span>;<br></code></pre></td></tr></table></figure><p>当用户想要释放对象时可调用deleteElement函数，该方法首先调用对象T的析构函数，其次同样经过哈希映射找到相应的内存池去把内存槽加入到FreeList_中。</p>]]></content>
    
    
    <categories>
      
      <category>个人项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>内存池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用C++实现终端版俄罗斯方块：从零开始的游戏开发指南</title>
    <link href="/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/"/>
    <url>/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h3 id="用C-实现终端版俄罗斯方块：从零开始的游戏开发指南"><a href="#用C-实现终端版俄罗斯方块：从零开始的游戏开发指南" class="headerlink" title="用C++实现终端版俄罗斯方块：从零开始的游戏开发指南"></a>用C++实现终端版俄罗斯方块：从零开始的游戏开发指南</h3><h4 id="引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C-控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。"><a href="#引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C-控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。" class="headerlink" title="引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C++控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。"></a>引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C++控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。</h4><p>观看视频讲解：<a href="https://www.bilibili.com/video/BV1a94y1Y7Jw">C++俄罗斯方块实现教程</a></p><h4 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h4><h5 id="1-方块表示与旋转"><a href="#1-方块表示与旋转" class="headerlink" title="1. 方块表示与旋转"></a>1. 方块表示与旋转</h5><ul><li>采用4x4字符矩阵表示方块，通过旋转算法实现多角度变换：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模拟俄罗斯方块的旋转</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> px, <span class="hljs-type">int</span> py, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">switch</span> (r % <span class="hljs-number">4</span>)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> py * <span class="hljs-number">4</span> + px;         <span class="hljs-comment">//0 degress</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">12</span> + py - (px * <span class="hljs-number">4</span>);<span class="hljs-comment">//90 degress</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">15</span> - (py * <span class="hljs-number">4</span>) - px;<span class="hljs-comment">//180 degress</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">3</span> - py + (px * <span class="hljs-number">4</span>);     <span class="hljs-comment">//270 degress</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-碰撞检测"><a href="#2-碰撞检测" class="headerlink" title="2. 碰撞检测"></a>2. 碰撞检测</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DoesPieceFit</span><span class="hljs-params">(<span class="hljs-type">int</span> nTetromino, <span class="hljs-type">int</span> nRotation, <span class="hljs-type">int</span> nPosX, <span class="hljs-type">int</span> nPosY)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// All Field cells &gt;0 are occupied</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">0</span>; px &lt; <span class="hljs-number">4</span>; px++)<span class="hljs-comment">// 循环遍历方块的水平位置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<span class="hljs-comment">// 循环遍历方块的垂直位置</span><br>&#123;<br><span class="hljs-comment">// Get index into piece</span><br><span class="hljs-comment">// 获取方块内部位置的索引</span><br><span class="hljs-type">int</span> pi = <span class="hljs-built_in">Rotate</span>(px, py, nRotation);<br><br><span class="hljs-comment">// Get index into field</span><br><span class="hljs-comment">// 获取方块在游戏区域中的索引</span><br><span class="hljs-type">int</span> fi = (nPosY + py) * nFieldWidth + (nPosX + px);<br><br><span class="hljs-comment">// Check that test is in bounds. Note out of bounds does</span><br><span class="hljs-comment">// not necessarily mean a fail, as the long vertical piece</span><br><span class="hljs-comment">// can have cells that lie outside the boundary, so we&#x27;ll</span><br><span class="hljs-comment">// just ignore them</span><br><span class="hljs-keyword">if</span> (nPosX + px &gt;= <span class="hljs-number">0</span> &amp;&amp; nPosX + px &lt; nFieldWidth)<span class="hljs-comment">// 检查方块是否在横向范围内</span><br>&#123;<br><span class="hljs-keyword">if</span> (nPosY + py &gt;= <span class="hljs-number">0</span> &amp;&amp; nPosY + py &lt; nFieldHeight)<span class="hljs-comment">// 检查方块是否在纵向范围内</span><br>&#123;<br><span class="hljs-comment">// In Bounds so do collision check</span><br><span class="hljs-keyword">if</span> (tetromino[nTetromino][pi] != <span class="hljs-string">L&#x27;.&#x27;</span> &amp;&amp; pField[fi] != <span class="hljs-number">0</span>)<span class="hljs-comment">// 检查方块和游戏区域是否有重叠</span><br><span class="hljs-comment">// 第一个碰撞就返回失败</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// fail on first hit</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 方块适合放置在指定位置</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-方块定义"><a href="#3-方块定义" class="headerlink" title="3. 方块定义"></a>3. 方块定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++">tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br><br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br><br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="4-游戏主循环"><a href="#4-游戏主循环" class="headerlink" title="4. 游戏主循环"></a>4. 游戏主循环</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (!bGameOver)<br>&#123;<br><span class="hljs-comment">//GAME TIMING =======================================</span><br>this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">50</span>ms);<br>nSpeedCounter++;<br>bForceDown = (nSpeedCounter == nSpeed);<br><br><span class="hljs-comment">//INPUT =============================================</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++)<span class="hljs-comment">// R   L   D Z</span><br><span class="hljs-comment">// 判断了指定键码对应的按键是否处于按下状态。如果按键被按下，则结果为真，否则为假。</span><br>bKey[k] = (<span class="hljs-number">0x8000</span> &amp; <span class="hljs-built_in">GetAsyncKeyState</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(<span class="hljs-string">&quot;\x27\x25\x28Z&quot;</span>[k]))) != <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//GAME LOGIC ========================================</span><br><span class="hljs-comment">// Handle player movement</span><br><span class="hljs-comment">// 处理玩家的移动</span><br><span class="hljs-comment">// 按下右键 right</span><br>nCurrentX += (bKey[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX + <span class="hljs-number">1</span>, nCurrentY)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 按下左键 left</span><br>nCurrentX -= (bKey[<span class="hljs-number">1</span>] &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX - <span class="hljs-number">1</span>, nCurrentY)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 按下下键 down</span><br>nCurrentY += (bKey[<span class="hljs-number">2</span>] &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX, nCurrentY + <span class="hljs-number">1</span>)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 按下Z键，旋转</span><br><span class="hljs-keyword">if</span> (bKey[<span class="hljs-number">3</span>])<span class="hljs-comment">// 按下Z键</span><br>&#123;<br>nCurrentRotation += (bRotateHold &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation + <span class="hljs-number">1</span>, nCurrentX, nCurrentY)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>bRotateHold = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>bRotateHold = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 无法连续旋转</span><br><br><span class="hljs-keyword">if</span> (bForceDown)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX, nCurrentY + <span class="hljs-number">1</span>))<br>nCurrentY++;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// Lock the current in the field</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">0</span>; px &lt; <span class="hljs-number">4</span>; px++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<br><span class="hljs-keyword">if</span> (tetromino[nCurrentPiece][<span class="hljs-built_in">Rotate</span>(px, py, nCurrentRotation)] == <span class="hljs-string">L&#x27;X&#x27;</span>)<br>pField[(nCurrentY + py) * nFieldWidth + (nCurrentX + px)] = nCurrentPiece + <span class="hljs-number">1</span>;<br><br>nPieceCount++;<br><span class="hljs-keyword">if</span> (nPieceCount % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> (nSpeed &gt;= <span class="hljs-number">10</span>) nSpeed--;<br><br><br><span class="hljs-comment">// Check have we got any lines</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<br><span class="hljs-keyword">if</span> (nCurrentY + py &lt; nFieldHeight - <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-type">bool</span> bLine = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">1</span>; px &lt; nFieldWidth - <span class="hljs-number">1</span>; px++)<br>bLine &amp;= (pField[(nCurrentY + py) * nFieldWidth + px]) != <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (bLine)<br>&#123;<br><span class="hljs-comment">// Remove Line, set to = </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">1</span>; px &lt; nFieldWidth - <span class="hljs-number">1</span>; px++)<br>pField[(nCurrentY + py) * nFieldWidth + px] = <span class="hljs-number">8</span>; <br><br>vLines.<span class="hljs-built_in">push_back</span>(nCurrentY + py);<br>&#125;<br>&#125;<br>nScore += <span class="hljs-number">50</span>;<br><span class="hljs-keyword">if</span> (!vLines.<span class="hljs-built_in">empty</span>()) nScore += (<span class="hljs-number">1</span> &lt;&lt; vLines.<span class="hljs-built_in">size</span>()) * <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// Choose next piece</span><br>nCurrentX = nFieldWidth / <span class="hljs-number">2</span>;<br>nCurrentY = <span class="hljs-number">0</span>;<br>nCurrentRotation = <span class="hljs-number">0</span>;<br>nCurrentPiece = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">7</span>;<br><br>bGameOver = !<span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX, nCurrentY);<br>&#125;<br>nSpeedCounter = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//RENDER OUTPUT =====================================</span><br><br><br><br><span class="hljs-comment">// Draw Field</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; nFieldWidth; x++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; nFieldHeight; y++)<br>screen[(y + <span class="hljs-number">2</span>) * nScreenWidth + (x + <span class="hljs-number">2</span>)] = <span class="hljs-string">L&quot; ABCDEFG=#&quot;</span>[pField[y * nFieldWidth + x]];<br><br><span class="hljs-comment">// Draw Current piece</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">0</span>; px &lt; <span class="hljs-number">4</span>; px++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<br><span class="hljs-keyword">if</span> (tetromino[nCurrentPiece][<span class="hljs-built_in">Rotate</span>(px, py, nCurrentRotation)] == <span class="hljs-string">L&#x27;X&#x27;</span>)<br>screen[(nCurrentY + py + <span class="hljs-number">2</span>) * nScreenWidth + (nCurrentX + px + <span class="hljs-number">2</span>)] = nCurrentPiece + <span class="hljs-number">65</span>;<br><br><span class="hljs-comment">// Draw Score</span><br><span class="hljs-built_in">swprintf_s</span>(&amp;screen[<span class="hljs-number">2</span> * nScreenWidth + nFieldWidth + <span class="hljs-number">6</span>], <span class="hljs-number">16</span>, <span class="hljs-string">L&quot;SCORE: %8d&quot;</span>, nScore);<br><br><span class="hljs-keyword">if</span> (!vLines.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// Display Frame (cheekily to dray lines</span><br><span class="hljs-built_in">WriteConsoleOutputCharacter</span>(hConsole, screen, nScreenWidth * nScreenHeight, &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;, &amp;dwBytesWritten);<br>this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">400</span>ms);  <span class="hljs-comment">//Delay a bit</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; v : vLines)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">1</span>; px &lt; nFieldWidth - <span class="hljs-number">1</span>; px++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = v; py &gt; <span class="hljs-number">0</span>; py--)<br>pField[py * nFieldWidth + px] = pField[(py - <span class="hljs-number">1</span>) * nFieldWidth + px];<br>pField[px] = <span class="hljs-number">0</span>;<br>&#125;<br>vLines.<span class="hljs-built_in">clear</span>();<br>&#125;<br><br><span class="hljs-comment">//Display Frame</span><br><span class="hljs-built_in">WriteConsoleOutputCharacter</span>(hConsole, screen, nScreenWidth * nScreenHeight, &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;, &amp;dwBytesWritten);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a href="https://github.com/hwl111/hwl111.github.io/blob/main/code/tetris.cpp">在线查看代码</a></li><li><a href="https://github.com/hwl111/hwl111.github.io/raw/main/code/tetris.cpp">直接下载代码</a></li></ul><p>通过这个项目，我们不仅实现了经典游戏，还掌握了：</p><ul><li>二维游戏逻辑开发</li><li>控制台图形渲染</li><li>实时输入处理</li><li>状态管理技巧</li></ul>]]></content>
    
    
    <categories>
      
      <category>个人项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>游戏开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法时间复杂度与空间复杂度详解</title>
    <link href="/2025/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2025/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="算法时间复杂度与空间复杂度"><a href="#算法时间复杂度与空间复杂度" class="headerlink" title="算法时间复杂度与空间复杂度"></a>算法时间复杂度与空间复杂度</h3><h4 id="什么是算法复杂度"><a href="#什么是算法复杂度" class="headerlink" title="什么是算法复杂度"></a>什么是算法复杂度</h4><p>算法复杂度是衡量算法效率的重要指标，主要包括：</p><ul><li><strong>时间复杂度</strong>：算法执行所需的时间量级</li><li><strong>空间复杂度</strong>：算法执行所需的内存空间量级</li></ul><p>复杂度作用：</p><ol><li>比较不同算法的效率</li><li>预测算法在不同规模数据下的表现</li><li>优化程序性能</li></ol><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><h5 id="1-大O表示法"><a href="#1-大O表示法" class="headerlink" title="1. 大O表示法"></a>1. 大O表示法</h5><p>大O表示法（Big-O Notation）描述了算法在最坏情况下的增长趋势：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        std::cout&lt;&lt;i;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子的时间复杂度就是O(n)</p><h5 id="2-常见时间复杂度对比"><a href="#2-常见时间复杂度对比" class="headerlink" title="2. 常见时间复杂度对比"></a>2. 常见时间复杂度对比</h5><table><thead><tr><th align="left">复杂度</th><th align="left">名称</th><th align="left">示例</th><th align="left">n&#x3D;100时的操作次数</th></tr></thead><tbody><tr><td align="left">O(1)</td><td align="left">常数时间</td><td align="left">哈希表查找</td><td align="left">1</td></tr><tr><td align="left">O(log n)</td><td align="left">对数时间</td><td align="left">二分查找</td><td align="left">~7</td></tr><tr><td align="left">O(n)</td><td align="left">线性时间</td><td align="left">遍历数组</td><td align="left">100</td></tr><tr><td align="left">O(n log n)</td><td align="left">线性对数时间</td><td align="left">快速排序</td><td align="left">~664</td></tr><tr><td align="left">O(n²)</td><td align="left">平方时间</td><td align="left">冒泡排序</td><td align="left">10,000</td></tr><tr><td align="left">O(2ⁿ)</td><td align="left">指数时间</td><td align="left">穷举算法</td><td align="left">1.26e+30</td></tr></tbody></table><h5 id="3-计算规则"><a href="#3-计算规则" class="headerlink" title="3. 计算规则"></a>3. 计算规则</h5><ul><li><strong>加法规则</strong>：T(n) &#x3D; T1(n) + T2(n) → O(max(f(n), g(n)))</li><li><strong>乘法规则</strong>：T(n) &#x3D; T1(n) * T2(n) → O(f(n) * g(n))</li></ul><h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><h5 id="1-计算方法"><a href="#1-计算方法" class="headerlink" title="1. 计算方法"></a>1. 计算方法</h5><p>计算算法运行过程中<strong>额外</strong>占用的存储空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># O(n)空间复杂度示例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_array</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>] * n  <span class="hljs-comment"># 需要分配n个元素的存储空间</span><br></code></pre></td></tr></table></figure><h5 id="2-常见空间复杂度"><a href="#2-常见空间复杂度" class="headerlink" title="2. 常见空间复杂度"></a>2. 常见空间复杂度</h5><table><thead><tr><th align="left">复杂度</th><th align="left">说明</th><th align="left">典型算法</th></tr></thead><tbody><tr><td align="left">O(1)</td><td align="left">固定大小的额外空间</td><td align="left">迭代算法</td></tr><tr><td align="left">O(n)</td><td align="left">与输入规模线性相关</td><td align="left">归并排序</td></tr><tr><td align="left">O(n²)</td><td align="left">二维数据结构</td><td align="left">邻接矩阵存储图</td></tr></tbody></table><h4 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 递归实现（时间复杂度O(2ⁿ)，空间复杂度O(n)）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_recursive</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">return</span> fib_recursive(n-<span class="hljs-number">1</span>) + fib_recursive(n-<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 迭代实现（时间复杂度O(n)，空间复杂度O(1)）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_iterative</span>(<span class="hljs-params">n</span>):<br>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        a, b = b, a + b<br>    <span class="hljs-keyword">return</span> a<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时间复杂度</tag>
      
      <tag>空间复杂度</tag>
      
      <tag>算法基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
