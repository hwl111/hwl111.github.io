<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>STL深度探索</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/STL%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/STL%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="STL-Standard-Template-Library-深度探索"><a href="#STL-Standard-Template-Library-深度探索" class="headerlink" title="STL (Standard Template Library) 深度探索"></a>STL (Standard Template Library) 深度探索</h1><hr><h2 id="一、容器内部实现、复杂度与性能对比"><a href="#一、容器内部实现、复杂度与性能对比" class="headerlink" title="一、容器内部实现、复杂度与性能对比"></a>一、容器内部实现、复杂度与性能对比</h2><h3 id="1-std-vector"><a href="#1-std-vector" class="headerlink" title="1. std::vector"></a>1. std::vector</h3><ul><li><strong>实现</strong>：动态数组，元素连续存储，支持随机访问。</li><li><strong>扩容</strong>：容量不足时按倍数增长，移动&#x2F;拷贝所有元素。</li><li><strong>复杂度</strong>：push_back O(1) 摊销，insert&#x2F;erase O(n)，随机访问 O(1)。</li><li><strong>源码结构</strong>（libstdc++）：_M_start, _M_finish, _M_end_of_storage 指针管理区间。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 预分配，减少扩容次数</span><br></code></pre></td></tr></table></figure><h3 id="2-std-list"><a href="#2-std-list" class="headerlink" title="2. std::list"></a>2. std::list</h3><ul><li><strong>实现</strong>：双向链表，节点分散存储，插入&#x2F;删除 O(1)。</li><li><strong>复杂度</strong>：push_back&#x2F;push_front&#x2F;insert&#x2F;erase O(1)，随机访问 O(n)。</li><li><strong>适用场景</strong>：频繁插入&#x2F;删除，元素位置不重要。</li></ul><h3 id="3-std-map"><a href="#3-std-map" class="headerlink" title="3. std::map"></a>3. std::map</h3><ul><li><strong>实现</strong>：红黑树（平衡二叉搜索树），有序键值对。</li><li><strong>复杂度</strong>：insert&#x2F;find&#x2F;erase O(log n)。</li><li><strong>源码结构</strong>：_Rb_tree_node, _M_left, _M_right, _M_parent。</li></ul><h3 id="4-std-unordered-map"><a href="#4-std-unordered-map" class="headerlink" title="4. std::unordered_map"></a>4. std::unordered_map</h3><ul><li><strong>实现</strong>：哈希表，元素无序，key-&gt;bucket-&gt;链表&#x2F;红黑树。</li><li><strong>复杂度</strong>：平均 O(1)，最坏 O(n)（哈希冲突）。</li><li><strong>源码结构</strong>：_Hashtable, _M_buckets, _M_element_count。</li></ul><h3 id="5-std-array-std-span"><a href="#5-std-array-std-span" class="headerlink" title="5. std::array, std::span"></a>5. std::array, std::span</h3><ul><li><strong>array</strong>：定长数组，栈上分配，零开销。</li><li>**span (C++20)**：轻量视图，不拥有数据，适合函数参数传递。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::array&lt;<span class="hljs-type">int</span>, 4&gt; arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-function">std::span&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(arr)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="性能对比表"><a href="#性能对比表" class="headerlink" title="性能对比表"></a>性能对比表</h4><table><thead><tr><th>容器</th><th>随机访问</th><th>插入&#x2F;删除</th><th>内存局部性</th><th>适用场景</th></tr></thead><tbody><tr><td>vector</td><td>O(1)</td><td>O(n)</td><td>优</td><td>动态数组</td></tr><tr><td>list</td><td>O(n)</td><td>O(1)</td><td>差</td><td>频繁插入&#x2F;删除</td></tr><tr><td>map</td><td>O(log n)</td><td>O(log n)</td><td>一般</td><td>有序键值对</td></tr><tr><td>unordered_map</td><td>O(1)*</td><td>O(1)*</td><td>一般</td><td>快速查找</td></tr><tr><td>array&#x2F;span</td><td>O(1)</td><td>不支持</td><td>优</td><td>固定大小&#x2F;视图</td></tr></tbody></table><hr><h2 id="二、-算法高效使用与并行"><a href="#二、-算法高效使用与并行" class="headerlink" title="二、 算法高效使用与并行"></a>二、<algorithm> 算法高效使用与并行</h2><h3 id="1-常用算法与自定义谓词"><a href="#1-常用算法与自定义谓词" class="headerlink" title="1. 常用算法与自定义谓词"></a>1. 常用算法与自定义谓词</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>std::<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123; <span class="hljs-keyword">return</span> a &gt; b; &#125;);<br>std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x)&#123; std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>; &#125;);<br></code></pre></td></tr></table></figure><ul><li><strong>自定义谓词</strong>：lambda、函数对象、函数指针均可。</li></ul><h3 id="2-并行算法（C-17）"><a href="#2-并行算法（C-17）" class="headerlink" title="2. 并行算法（C++17）"></a>2. 并行算法（C++17）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">1000000</span>)</span></span>;<br>std::<span class="hljs-built_in">iota</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>std::<span class="hljs-built_in">sort</span>(std::execution::par, v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><ul><li><strong>原理</strong>：std::execution::par 让算法多线程并行，底层用线程池&#x2F;分块。</li><li><strong>适用场景</strong>：大数据量、无数据依赖。</li></ul><hr><h2 id="三、迭代器类型、适配器与自定义迭代器"><a href="#三、迭代器类型、适配器与自定义迭代器" class="headerlink" title="三、迭代器类型、适配器与自定义迭代器"></a>三、迭代器类型、适配器与自定义迭代器</h2><h3 id="1-迭代器类型与概念"><a href="#1-迭代器类型与概念" class="headerlink" title="1. 迭代器类型与概念"></a>1. 迭代器类型与概念</h3><ul><li><strong>Input&#x2F;Output&#x2F;Forward&#x2F;Bidirectional&#x2F;RandomAccess</strong></li><li>vector&#x2F;array：RandomAccess，list：Bidirectional，map：Bidirectional</li></ul><h3 id="2-迭代器适配器"><a href="#2-迭代器适配器" class="headerlink" title="2. 迭代器适配器"></a>2. 迭代器适配器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>std::<span class="hljs-built_in">copy</span>(std::<span class="hljs-built_in">istream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;(std::cin), &#123;&#125;, std::<span class="hljs-built_in">back_inserter</span>(v));<br></code></pre></td></tr></table></figure><ul><li><strong>back_inserter</strong>：将输出插入到容器尾部。</li><li><strong>istream_iterator</strong>：从输入流读取。</li></ul><h3 id="3-自定义迭代器实现"><a href="#3-自定义迭代器实现" class="headerlink" title="3. 自定义迭代器实现"></a>3. 自定义迭代器实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIter</span> : <span class="hljs-keyword">public</span> std::iterator&lt;std::forward_iterator_tag, <span class="hljs-type">int</span>&gt; &#123;<br>    <span class="hljs-type">int</span>* p;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyIter</span>(<span class="hljs-type">int</span>* ptr) : <span class="hljs-built_in">p</span>(ptr) &#123;&#125;<br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> *p; &#125;<br>    MyIter&amp; <span class="hljs-keyword">operator</span>++() &#123; ++p; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> MyIter&amp; rhs) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> p != rhs.p; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="四、函数对象与-std-function-std-bind-lambda"><a href="#四、函数对象与-std-function-std-bind-lambda" class="headerlink" title="四、函数对象与 std::function, std::bind, lambda"></a>四、函数对象与 std::function, std::bind, lambda</h2><h3 id="1-函数对象（仿函数）"><a href="#1-函数对象（仿函数）" class="headerlink" title="1. 函数对象（仿函数）"></a>1. 函数对象（仿函数）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Add</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br>&#125;;<br>Add add;<br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="2-std-function"><a href="#2-std-function" class="headerlink" title="2. std::function"></a>2. std::function</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br>std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; f = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br></code></pre></td></tr></table></figure><h3 id="3-std-bind"><a href="#3-std-bind" class="headerlink" title="3. std::bind"></a>3. std::bind</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">auto</span> f = std::<span class="hljs-built_in">bind</span>(std::<span class="hljs-built_in">plus</span>&lt;<span class="hljs-type">int</span>&gt;(), <span class="hljs-number">1</span>, std::placeholders::_1);<br><span class="hljs-type">int</span> x = <span class="hljs-built_in">f</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 1+2</span><br></code></pre></td></tr></table></figure><h3 id="4-lambda-表达式"><a href="#4-lambda-表达式" class="headerlink" title="4. lambda 表达式"></a>4. lambda 表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * x; &#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="五、std-vector-扩容策略与-reserve-优化"><a href="#五、std-vector-扩容策略与-reserve-优化" class="headerlink" title="五、std::vector 扩容策略与 reserve 优化"></a>五、std::vector 扩容策略与 reserve 优化</h2><h3 id="1-扩容源码与策略"><a href="#1-扩容源码与策略" class="headerlink" title="1. 扩容源码与策略"></a>1. 扩容源码与策略</h3><ul><li>vector 扩容通常按 1.5~2 倍增长（libstdc++&#x2F;libc++源码 _M_realloc_insert&#x2F;_M_reserve）。</li><li>扩容时所有元素移动&#x2F;拷贝到新内存。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) v.<span class="hljs-built_in">push_back</span>(i);<br></code></pre></td></tr></table></figure><h3 id="2-reserve-优化与-benchmark"><a href="#2-reserve-优化与-benchmark" class="headerlink" title="2. reserve 优化与 benchmark"></a>2. reserve 优化与 benchmark</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) v.<span class="hljs-built_in">push_back</span>(i);<br></code></pre></td></tr></table></figure><ul><li><strong>性能对比</strong>：预分配可大幅减少扩容次数和拷贝。</li></ul><hr><h2 id="六、std-map-vs-std-unordered-map"><a href="#六、std-map-vs-std-unordered-map" class="headerlink" title="六、std::map vs std::unordered_map"></a>六、std::map vs std::unordered_map</h2><h3 id="1-底层实现与复杂度"><a href="#1-底层实现与复杂度" class="headerlink" title="1. 底层实现与复杂度"></a>1. 底层实现与复杂度</h3><ul><li>map：红黑树，O(log n)，有序。</li><li>unordered_map：哈希表，O(1)均摊，无序。</li></ul><h3 id="2-哈希冲突处理"><a href="#2-哈希冲突处理" class="headerlink" title="2. 哈希冲突处理"></a>2. 哈希冲突处理</h3><ul><li>链地址法（buckets+链表&#x2F;红黑树），C++17后高冲突桶用红黑树。</li><li>哈希函数可自定义。</li></ul><h3 id="3-性能对比与选择建议"><a href="#3-性能对比与选择建议" class="headerlink" title="3. 性能对比与选择建议"></a>3. 性能对比与选择建议</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br>std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; um;<br><span class="hljs-keyword">auto</span> t1 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) m[i] = i;<br><span class="hljs-keyword">auto</span> t2 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) um[i] = i;<br><span class="hljs-keyword">auto</span> t3 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;map: &quot;</span> &lt;&lt; (t2-t1).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;, unordered_map: &quot;</span> &lt;&lt; (t3-t2).<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><ul><li>map 适合有序遍历、区间查找，unordered_map 适合快速查找。</li><li>哈希冲突多时 unordered_map 性能下降。</li></ul><hr><h2 id="七、高效使用-替代手写循环"><a href="#七、高效使用-替代手写循环" class="headerlink" title="七、高效使用  替代手写循环"></a>七、高效使用 <algorithm> 替代手写循环</h2><h3 id="1-常见替代案例"><a href="#1-常见替代案例" class="headerlink" title="1. 常见替代案例"></a>1. 常见替代案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> sum = std::<span class="hljs-built_in">accumulate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>std::for_each(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span>&amp; x)&#123; x *= <span class="hljs-number">2</span>; &#125;);<br>std::<span class="hljs-built_in">replace_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x)&#123; <span class="hljs-keyword">return</span> x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>; &#125;, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li><algorithm> 提供高效、可读性强的 STL 算法，避免手写易错循环。</li><li>并行算法（C++17）可进一步提升性能。</li></ul><p>！ </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>性能</tag>
      
      <tag>STL</tag>
      
      <tag>容器</tag>
      
      <tag>迭代器</tag>
      
      <tag>函数对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux操作系统详解</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-操作系统详解"><a href="#Linux-操作系统详解" class="headerlink" title="Linux 操作系统详解"></a>Linux 操作系统详解</h1><hr><h2 id="一、Linux-简介"><a href="#一、Linux-简介" class="headerlink" title="一、Linux 简介"></a>一、Linux 简介</h2><p>Linux 是一种自由和开放源代码的类 Unix 操作系统。最初由 Linus Torvalds 于 1991 年开发，采用 GPL（GNU 通用公共许可证）协议。Linux 具有高度的可定制性、稳定性和安全性，广泛应用于服务器、桌面、嵌入式系统、移动设备等领域。</p><p><strong>主要特点：</strong></p><ul><li>开源免费，拥有庞大的社区支持</li><li>多用户、多任务、支持多种硬件平台</li><li>稳定性高，安全性强，适合服务器环境</li><li>丰富的开发工具和软件生态</li></ul><hr><h2 id="二、体系结构"><a href="#二、体系结构" class="headerlink" title="二、体系结构"></a>二、体系结构</h2><p>Linux 操作系统采用分层结构，主要分为内核空间和用户空间。</p><h3 id="1-内核空间（Kernel-Space）"><a href="#1-内核空间（Kernel-Space）" class="headerlink" title="1. 内核空间（Kernel Space）"></a>1. 内核空间（Kernel Space）</h3><ul><li>负责管理硬件资源、进程调度、内存分配、文件系统、网络通信等。</li><li>Linux 内核为单内核（Monolithic Kernel），所有核心功能都在内核空间实现。</li><li>支持可加载内核模块（LKM），可动态扩展内核功能。</li></ul><h3 id="2-用户空间（User-Space）"><a href="#2-用户空间（User-Space）" class="headerlink" title="2. 用户空间（User Space）"></a>2. 用户空间（User Space）</h3><ul><li>运行用户应用程序，通过系统调用与内核交互。</li><li>用户空间与内核空间隔离，保证系统安全和稳定。</li></ul><h3 id="3-系统调用接口（System-Call-Interface）"><a href="#3-系统调用接口（System-Call-Interface）" class="headerlink" title="3. 系统调用接口（System Call Interface）"></a>3. 系统调用接口（System Call Interface）</h3><ul><li>用户程序通过系统调用（如 open、read、write、fork 等）请求内核服务。</li><li>系统调用是用户空间与内核空间的桥梁。</li></ul><h4 id="原理结构图"><a href="#原理结构图" class="headerlink" title="原理结构图"></a>原理结构图</h4><pre><code class=" mermaid">graph TD  A[&quot;用户空间&quot;] -- 系统调用 --&gt; B[&quot;内核空间&quot;]  B -- 管理 --&gt; C[&quot;硬件&quot;]  B -- 提供接口 --&gt; D[&quot;设备驱动&quot;]  B -- 文件操作 --&gt; E[&quot;文件系统&quot;]  B -- 进程调度 --&gt; F[&quot;进程管理&quot;]  B -- 内存分配 --&gt; G[&quot;内存管理&quot;]  B -- 网络通信 --&gt; H[&quot;网络协议栈&quot;]</code></pre><hr><h2 id="三、内核（Kernel）与-C-并发原理对照"><a href="#三、内核（Kernel）与-C-并发原理对照" class="headerlink" title="三、内核（Kernel）与 C++ 并发原理对照"></a>三、内核（Kernel）与 C++ 并发原理对照</h2><h3 id="C-多线程与同步机制"><a href="#C-多线程与同步机制" class="headerlink" title="C++ 多线程与同步机制"></a>C++ 多线程与同步机制</h3><h4 id="1-线程创建与管理"><a href="#1-线程创建与管理" class="headerlink" title="1. 线程创建与管理"></a>1. 线程创建与管理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="hljs-string">&quot; running\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(worker, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(worker, <span class="hljs-number">2</span>)</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; C++ 用 std::thread 创建线程，类似内核的 task_struct 和调度。</p><h4 id="2-互斥锁与条件变量"><a href="#2-互斥锁与条件变量" class="headerlink" title="2. 互斥锁与条件变量"></a>2. 互斥锁与条件变量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>std::mutex mtx;<br>std::condition_variable cv;<br>std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        cv.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    done = <span class="hljs-literal">true</span>;<br>    cv.<span class="hljs-built_in">notify_all</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        cv.<span class="hljs-built_in">wait</span>(lock, []&#123; <span class="hljs-keyword">return</span> !q.<span class="hljs-built_in">empty</span>() || done; &#125;);<br>        <span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> val = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Consumed: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (done) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">p</span><span class="hljs-params">(producer)</span>, <span class="hljs-title">c</span><span class="hljs-params">(consumer)</span></span>;<br>    p.<span class="hljs-built_in">join</span>(); c.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; std::mutex 和 std::condition_variable 对应内核的 spinlock&#x2F;semaphore&#x2F;wait queue。</p><h4 id="3-原子操作"><a href="#3-原子操作" class="headerlink" title="3. 原子操作"></a>3. 原子操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counter</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) counter++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(add)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(add)</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>(); t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; counter &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; std::atomic 对应内核的 atomic_t，保证并发安全。</p><hr><h2 id="四、进程管理与-C-线程调度对照"><a href="#四、进程管理与-C-线程调度对照" class="headerlink" title="四、进程管理与 C++ 线程调度对照"></a>四、进程管理与 C++ 线程调度对照</h2><h3 id="C-线程优先级与调度"><a href="#C-线程优先级与调度" class="headerlink" title="C++ 线程优先级与调度"></a>C++ 线程优先级与调度</h3><h4 id="1-设置线程优先级（POSIX-接口）"><a href="#1-设置线程优先级（POSIX-接口）" class="headerlink" title="1. 设置线程优先级（POSIX 接口）"></a>1. 设置线程优先级（POSIX 接口）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123; <span class="hljs-comment">/* do work */</span> &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(task)</span></span>;<br>    sched_param sch_params;<br>    sch_params.sched_priority = <span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">pthread_setschedparam</span>(t.<span class="hljs-built_in">native_handle</span>(), SCHED_RR, &amp;sch_params);<br>    t.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; C++ 标准库不直接支持优先级，需用 pthread 接口，类似内核 SCHED_RR&#x2F;SCHED_FIFO。</p><h4 id="2-C-与内核调度对比"><a href="#2-C-与内核调度对比" class="headerlink" title="2. C++ 与内核调度对比"></a>2. C++ 与内核调度对比</h4><ul><li>C++ 线程调度依赖操作系统，不能像内核 CFS 那样精细控制。</li><li>但可通过 native_handle 与系统调度器交互。</li></ul><hr><h2 id="五、内存管理"><a href="#五、内存管理" class="headerlink" title="五、内存管理"></a>五、内存管理</h2><h3 id="1-虚拟内存"><a href="#1-虚拟内存" class="headerlink" title="1. 虚拟内存"></a>1. 虚拟内存</h3><ul><li>每个进程拥有独立的虚拟地址空间。</li><li>通过页表将虚拟地址映射到物理内存。</li></ul><h4 id="源码分析：Linux-内核内存分配（伙伴系统与-slab-分配器）"><a href="#源码分析：Linux-内核内存分配（伙伴系统与-slab-分配器）" class="headerlink" title="源码分析：Linux 内核内存分配（伙伴系统与 slab 分配器）"></a>源码分析：Linux 内核内存分配（伙伴系统与 slab 分配器）</h4><ul><li><strong>伙伴系统（Buddy System）</strong>：用于管理大块物理内存。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// mm/page_alloc.c</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">alloc_pages</span><span class="hljs-params">(<span class="hljs-type">gfp_t</span> gfp_mask, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> order)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    page = __alloc_pages(gfp_mask, order, ...);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> page_address(page);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>slab 分配器</strong>：用于高效分配小对象。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// mm/slab.c</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">kmem_cache_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *cachep, <span class="hljs-type">gfp_t</span> flags)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    objp = slab_alloc(cachep, flags, ...);<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> objp;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="命令实操与详细用法"><a href="#命令实操与详细用法" class="headerlink" title="命令实操与详细用法"></a>命令实操与详细用法</h4><ul><li><code>free</code>：显示内存和 swap 使用情况<ul><li><code>free -h</code>：以人类可读方式显示</li></ul></li><li><code>vmstat</code>：显示虚拟内存、进程、CPU 等统计信息<ul><li><code>vmstat 1</code>：每秒刷新一次</li></ul></li><li><code>top</code>&#x2F;<code>htop</code>：实时监控内存使用</li><li><code>cat /proc/meminfo</code>：查看详细内存信息</li></ul><p><strong>实操示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">free -h<br>vmstat 1<br><span class="hljs-built_in">cat</span> /proc/meminfo<br></code></pre></td></tr></table></figure><hr><h2 id="六、C-与内核内存管理对照"><a href="#六、C-与内核内存管理对照" class="headerlink" title="六、C++ 与内核内存管理对照"></a>六、C++ 与内核内存管理对照</h2><h3 id="1-C-内存分配与内核分配器对比"><a href="#1-C-内存分配与内核分配器对比" class="headerlink" title="1. C++ 内存分配与内核分配器对比"></a>1. C++ 内存分配与内核分配器对比</h3><ul><li><strong>C++ new&#x2F;delete 与内核 buddy&#x2F;slab 分配器</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 动态分配 100 个 int</span><br>    <span class="hljs-comment">// ... 使用 arr ...</span><br>    <span class="hljs-keyword">delete</span>[] arr; <span class="hljs-comment">// 释放内存</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; C++ new&#x2F;delete 由运行时库管理，内核则用 buddy&#x2F;slab 分配器管理物理内存和小对象。</p><ul><li><strong>std::allocator 与内核 slab 分配器</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br>std::vector&lt;<span class="hljs-type">int</span>, std::allocator&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">v</span>(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; std::allocator 为 STL 容器分配内存，类似内核 slab 分配器为小对象池化分配。</p><ul><li><strong>智能指针（RAII）与内核自动资源管理</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;<br>    <span class="hljs-comment">// 离开作用域自动释放</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; 智能指针自动释放资源，内核通过引用计数、slab 回收等机制管理生命周期。</p><hr><h2 id="七、文件系统实现与-C-资源管理对照"><a href="#七、文件系统实现与-C-资源管理对照" class="headerlink" title="七、文件系统实现与 C++ 资源管理对照"></a>七、文件系统实现与 C++ 资源管理对照</h2><h3 id="C-文件-IO-与-RAII"><a href="#C-文件-IO-与-RAII" class="headerlink" title="C++ 文件 IO 与 RAII"></a>C++ 文件 IO 与 RAII</h3><h4 id="1-文件读写与自动资源管理"><a href="#1-文件读写与自动资源管理" class="headerlink" title="1. 文件读写与自动资源管理"></a>1. 文件读写与自动资源管理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;std::fstream&gt; <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-keyword">new</span> std::fstream(<span class="hljs-string">&quot;test.txt&quot;</span>, std::ios::out))</span></span>;<br>    <span class="hljs-keyword">if</span> (file-&gt;<span class="hljs-built_in">is_open</span>()) &#123;<br>        *file &lt;&lt; <span class="hljs-string">&quot;Hello, Linux!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-comment">// unique_ptr 自动关闭文件，防止资源泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; std::fstream 和 unique_ptr 体现 RAII 思想，类似内核 VFS 自动管理 file&#x2F;inode 结构。</p><h4 id="2-文件锁"><a href="#2-文件锁" class="headerlink" title="2. 文件锁"></a>2. 文件锁</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br>std::mutex file_mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">safe_write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(file_mtx)</span></span>;<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;log.txt&quot;</span>, std::ios::app)</span></span>;<br>    ofs &lt;&lt; msg &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; C++ 用 mutex 保护文件写入，类似内核文件系统的 inode 锁。</p><hr><h2 id="八、C-与内核在网络编程、事件驱动等方面的对照"><a href="#八、C-与内核在网络编程、事件驱动等方面的对照" class="headerlink" title="八、C++ 与内核在网络编程、事件驱动等方面的对照"></a>八、C++ 与内核在网络编程、事件驱动等方面的对照</h2><h3 id="1-网络编程"><a href="#1-网络编程" class="headerlink" title="1. 网络编程"></a>1. 网络编程</h3><h4 id="C-socket-编程与内核协议栈对比"><a href="#C-socket-编程与内核协议栈对比" class="headerlink" title="C++ socket 编程与内核协议栈对比"></a>C++ socket 编程与内核协议栈对比</h4><ul><li><strong>C++ 原生 socket 编程</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    sockaddr_in addr&#123;&#125;;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8080</span>);<br>    addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    <span class="hljs-built_in">connect</span>(sock, (sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">send</span>(sock, msg, <span class="hljs-built_in">strlen</span>(msg), <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">close</span>(sock);<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; C++ socket API 直接调用内核 socket、connect、send、recv 等系统调用，底层由内核协议栈处理。</p><ul><li><strong>C++ 高性能异步网络库（asio）</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> asio::ip::tcp;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    asio::io_context io;<br>    <span class="hljs-function">tcp::socket <span class="hljs-title">socket</span><span class="hljs-params">(io)</span></span>;<br>    socket.<span class="hljs-built_in">connect</span>(tcp::<span class="hljs-built_in">endpoint</span>(asio::ip::<span class="hljs-built_in">make_address</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>), <span class="hljs-number">8080</span>));<br>    asio::<span class="hljs-built_in">write</span>(socket, asio::<span class="hljs-built_in">buffer</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; asio 库实现异步 IO，底层依赖内核 epoll&#x2F;kqueue 等事件通知。</p><hr><h3 id="2-事件驱动"><a href="#2-事件驱动" class="headerlink" title="2. 事件驱动"></a>2. 事件驱动</h3><h4 id="C-事件驱动模型与内核事件通知对比"><a href="#C-事件驱动模型与内核事件通知对比" class="headerlink" title="C++ 事件驱动模型与内核事件通知对比"></a>C++ 事件驱动模型与内核事件通知对比</h4><ul><li><strong>C++ select&#x2F;epoll 封装</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-type">int</span> epfd = <span class="hljs-built_in">epoll_create1</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 添加 fd 到 epoll</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> ev&#123;&#125;;<br>ev.events = EPOLLIN;<br>ev.data.fd = sockfd;<br><span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);<br><span class="hljs-comment">// 等待事件</span><br><span class="hljs-function">std::vector&lt;epoll_event&gt; <span class="hljs-title">events</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-type">int</span> n = <span class="hljs-built_in">epoll_wait</span>(epfd, events.<span class="hljs-built_in">data</span>(), <span class="hljs-number">10</span>, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; C++ 可直接使用内核 epoll 接口实现高效事件驱动，适合高并发服务器。</p><ul><li><strong>asio 异步事件驱动</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_read</span><span class="hljs-params">(<span class="hljs-type">const</span> asio::error_code&amp; ec, std::<span class="hljs-type">size_t</span> bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!ec) std::cout &lt;&lt; <span class="hljs-string">&quot;Read &quot;</span> &lt;&lt; bytes &lt;&lt; <span class="hljs-string">&quot; bytes\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    asio::io_context io;<br>    asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(io)</span></span>;<br>    <span class="hljs-comment">// ... 连接 ...</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    sock.<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(buf), on_read);<br>    io.<span class="hljs-built_in">run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; asio 通过回调实现事件驱动，底层依赖内核 epoll&#x2F;poll。</p><ul><li><strong>内核事件通知机制</strong><ul><li>内核通过 epoll、poll、select、信号等机制通知用户空间事件。</li><li>C++ 高性能网络库（如 asio、libevent）底层均依赖这些内核机制。</li></ul></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>性能</tag>
      
      <tag>Linux</tag>
      
      <tag>操作系统</tag>
      
      <tag>内核</tag>
      
      <tag>进程管理</tag>
      
      <tag>文件系统</tag>
      
      <tag>网络</tag>
      
      <tag>安全</tag>
      
      <tag>C++对照</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++实用工具库详解</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="C-实用工具库详解"><a href="#C-实用工具库详解" class="headerlink" title="C++ 实用工具库详解"></a>C++ 实用工具库详解</h1><hr><h2 id="一、std-filesystem-C-17-文件和目录操作"><a href="#一、std-filesystem-C-17-文件和目录操作" class="headerlink" title="一、std::filesystem (C++17) 文件和目录操作"></a>一、std::filesystem (C++17) 文件和目录操作</h2><h3 id="1-典型用法"><a href="#1-典型用法" class="headerlink" title="1. 典型用法"></a>1. 典型用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">namespace</span> fs = std::filesystem;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    fs::<span class="hljs-built_in">create_directory</span>(<span class="hljs-string">&quot;testdir&quot;</span>);<br>    fs::<span class="hljs-built_in">copy_file</span>(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-string">&quot;testdir/a.txt&quot;</span>, fs::copy_options::overwrite_existing);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : fs::<span class="hljs-built_in">directory_iterator</span>(<span class="hljs-string">&quot;testdir&quot;</span>)) &#123;<br>        std::cout &lt;&lt; entry.<span class="hljs-built_in">path</span>() &lt;&lt; std::endl;<br>    &#125;<br>    fs::<span class="hljs-built_in">remove_all</span>(<span class="hljs-string">&quot;testdir&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-源码结构与跨平台"><a href="#2-源码结构与跨平台" class="headerlink" title="2. 源码结构与跨平台"></a>2. 源码结构与跨平台</h3><ul><li>头文件 <code>&lt;filesystem&gt;</code>，实现依赖操作系统API（POSIX&#x2F;Win32）。</li><li>主要类：<code>std::filesystem::path</code>, <code>directory_iterator</code>, <code>file_status</code>。</li><li>跨平台注意路径分隔符、权限、符号链接等差异。</li></ul><hr><h2 id="二、std-chrono-时间与日期处理"><a href="#二、std-chrono-时间与日期处理" class="headerlink" title="二、std::chrono 时间与日期处理"></a>二、std::chrono 时间与日期处理</h2><h3 id="1-类型体系与源码结构"><a href="#1-类型体系与源码结构" class="headerlink" title="1. 类型体系与源码结构"></a>1. 类型体系与源码结构</h3><ul><li><code>std::chrono::duration</code>：时间段，模板参数为精度（如秒、毫秒）。</li><li><code>std::chrono::time_point</code>：时间点，基于clock。</li><li><code>std::chrono::system_clock</code>, <code>steady_clock</code>, <code>high_resolution_clock</code>。</li></ul><h3 id="2-常用场景与高精度计时"><a href="#2-常用场景与高精度计时" class="headerlink" title="2. 常用场景与高精度计时"></a>2. 常用场景与高精度计时</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> start = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>    <span class="hljs-keyword">auto</span> end = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-keyword">auto</span> ms = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end - start);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;耗时: &quot;</span> &lt;&lt; ms.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>C++20 起支持日历日期（year_month_day等）。</li></ul><hr><h2 id="三、std-format-C-20-类型安全格式化输出"><a href="#三、std-format-C-20-类型安全格式化输出" class="headerlink" title="三、std::format (C++20) 类型安全格式化输出"></a>三、std::format (C++20) 类型安全格式化输出</h2><h3 id="1-典型用法-1"><a href="#1-典型用法-1" class="headerlink" title="1. 典型用法"></a>1. 典型用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;format&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string s = std::format(<span class="hljs-string">&quot;Hello, &#123;&#125;! The answer is &#123;&#125;.&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-number">42</span>);<br>    std::cout &lt;&lt; s &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-底层原理与性能"><a href="#2-底层原理与性能" class="headerlink" title="2. 底层原理与性能"></a>2. 底层原理与性能</h3><ul><li>基于开源 {fmt} 库，类型安全、编译期格式检查。</li><li>性能优于 sprintf&#x2F;ostringstream。</li></ul><h3 id="3-自定义类型格式化"><a href="#3-自定义类型格式化" class="headerlink" title="3. 自定义类型格式化"></a>3. 自定义类型格式化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;format&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123; <span class="hljs-type">int</span> x, y; &#125;;<br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::formatter&lt;Point&gt; : std::formatter&lt;std::string&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">format</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p, <span class="hljs-keyword">auto</span>&amp; ctx)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::format_to(ctx.<span class="hljs-built_in">out</span>(), <span class="hljs-string">&quot;(&#123;&#125;, &#123;&#125;)&quot;</span>, p.x, p.y);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// std::cout &lt;&lt; std::format(&quot;P = &#123;&#125;&quot;, Point&#123;1,2&#125;);</span><br></code></pre></td></tr></table></figure><hr><h2 id="四、std-variant-std-any-std-optional"><a href="#四、std-variant-std-any-std-optional" class="headerlink" title="四、std::variant, std::any, std::optional"></a>四、std::variant, std::any, std::optional</h2><h3 id="1-std-variant"><a href="#1-std-variant" class="headerlink" title="1. std::variant"></a>1. std::variant</h3><ul><li>类型安全的联合体，类似Rust的enum。</li><li>用于表达多种可能类型的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><br>std::variant&lt;<span class="hljs-type">int</span>, std::string&gt; v = <span class="hljs-number">42</span>;<br>v = <span class="hljs-string">&quot;hello&quot;</span>;<br>std::<span class="hljs-built_in">visit</span>([](<span class="hljs-keyword">auto</span>&amp;&amp; arg)&#123; std::cout &lt;&lt; arg &lt;&lt; std::endl; &#125;, v);<br></code></pre></td></tr></table></figure><ul><li>源码结构：variant内部用union+索引+类型擦除。</li></ul><h3 id="2-std-any"><a href="#2-std-any" class="headerlink" title="2. std::any"></a>2. std::any</h3><ul><li>可存放任意类型，类型安全但无编译期检查。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;any&gt;</span></span><br>std::any a = <span class="hljs-number">1</span>;<br>a = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br><span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(std::string)) std::cout &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(a);<br></code></pre></td></tr></table></figure><ul><li>源码结构：内部用type_info+堆分配+类型擦除。</li></ul><h3 id="3-std-optional"><a href="#3-std-optional" class="headerlink" title="3. std::optional"></a>3. std::optional</h3><ul><li>可选值，表达“可能无值”，避免裸指针&#x2F;null。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br>std::optional&lt;<span class="hljs-type">int</span>&gt; o = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">if</span> (o) std::cout &lt;&lt; *o;<br></code></pre></td></tr></table></figure><ul><li>源码结构：union+bool标志，零开销。</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><ul><li>variant适合有限类型分支，any适合插件&#x2F;反射，optional适合返回“可能失败”的值。</li></ul><hr><h2 id="五、std-expected-C-23-错误和值处理"><a href="#五、std-expected-C-23-错误和值处理" class="headerlink" title="五、std::expected (C++23) 错误和值处理"></a>五、std::expected (C++23) 错误和值处理</h2><h3 id="1-典型用法-2"><a href="#1-典型用法-2" class="headerlink" title="1. 典型用法"></a>1. 典型用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;expected&gt;</span></span><br><span class="hljs-function">std::expected&lt;<span class="hljs-type">int</span>, std::string&gt; <span class="hljs-title">parse</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">stoi</span>(s); &#125;<br>    <span class="hljs-built_in">catch</span> (...) &#123; <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unexpected</span>(<span class="hljs-string">&quot;parse error&quot;</span>); &#125;<br>&#125;<br><span class="hljs-keyword">auto</span> res = <span class="hljs-built_in">parse</span>(<span class="hljs-string">&quot;42&quot;</span>);<br><span class="hljs-keyword">if</span> (res) std::cout &lt;&lt; *res;<br><span class="hljs-keyword">else</span> std::cout &lt;&lt; res.<span class="hljs-built_in">error</span>();<br></code></pre></td></tr></table></figure><h3 id="2-源码结构与对比"><a href="#2-源码结构与对比" class="headerlink" title="2. 源码结构与对比"></a>2. 源码结构与对比</h3><ul><li>expected内部用union存储值或错误，类似optional但有error分支。</li><li>对比optional&#x2F;异常：expected适合显式错误处理，异常适合不可恢复错误。</li></ul><hr><p>如需某一部分更深入源码分析或实战案例，请随时告知！ </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>工具库</tag>
      
      <tag>filesystem</tag>
      
      <tag>chrono</tag>
      
      <tag>format</tag>
      
      <tag>variant</tag>
      
      <tag>optional</tag>
      
      <tag>expected</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++内存管理详解</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="C-内存管理详解"><a href="#C-内存管理详解" class="headerlink" title="C++ 内存管理详解"></a>C++ 内存管理详解</h1><hr><h2 id="一、手动内存管理的陷阱与规避"><a href="#一、手动内存管理的陷阱与规避" class="headerlink" title="一、手动内存管理的陷阱与规避"></a>一、手动内存管理的陷阱与规避</h2><h3 id="1-new-delete-源码与底层实现"><a href="#1-new-delete-源码与底层实现" class="headerlink" title="1. new&#x2F;delete 源码与底层实现"></a>1. new&#x2F;delete 源码与底层实现</h3><h4 id="new-delete-源码简析"><a href="#new-delete-源码简析" class="headerlink" title="new&#x2F;delete 源码简析"></a>new&#x2F;delete 源码简析</h4><ul><li>C++ new 实际调用 operator new，底层通常是 malloc 或 ::operator new。</li><li>delete[] 需要记录数组长度，常见实现会在分配区头部存储元素个数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// operator new 源码（简化）</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-type">void</span>* p = <span class="hljs-built_in">malloc</span>(size)) <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_alloc</span>();<br>&#125;<br><br><span class="hljs-comment">// operator delete[] 伪代码</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span>* p) <span class="hljs-keyword">noexcept</span> &#123;<br>    <span class="hljs-keyword">if</span> (p) &#123;<br>        <span class="hljs-comment">// 读取头部元素个数，循环析构</span><br>        <span class="hljs-built_in">free</span>(p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="placement-new-底层原理"><a href="#placement-new-底层原理" class="headerlink" title="placement new 底层原理"></a>placement new 底层原理</h4><ul><li>placement new 只是调用构造函数，不分配内存。</li><li>必须手动析构，否则资源泄漏。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span> &#123; <span class="hljs-built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;ctor\n&quot;</span>; &#125; ~<span class="hljs-built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;dtor\n&quot;</span>; &#125; &#125;;<br><span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(Foo)];<br>Foo* p = <span class="hljs-built_in">new</span> (buf) <span class="hljs-built_in">Foo</span>(); <span class="hljs-comment">// 只构造</span><br>p-&gt;~<span class="hljs-built_in">Foo</span>(); <span class="hljs-comment">// 必须手动析构</span><br></code></pre></td></tr></table></figure><h4 id="实战案例：悬垂指针与越界"><a href="#实战案例：悬垂指针与越界" class="headerlink" title="实战案例：悬垂指针与越界"></a>实战案例：悬垂指针与越界</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">delete</span> p;<br>*p = <span class="hljs-number">100</span>; <span class="hljs-comment">// 悬垂指针，未定义行为</span><br><br><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 越界写，可能破坏堆结构</span><br></code></pre></td></tr></table></figure><p><strong>调试技巧</strong>：用 AddressSanitizer&#x2F;Valgrind 检查悬垂指针和越界。</p><hr><h2 id="二、智能指针深入剖析"><a href="#二、智能指针深入剖析" class="headerlink" title="二、智能指针深入剖析"></a>二、智能指针深入剖析</h2><h3 id="1-unique-ptr-源码与用法"><a href="#1-unique-ptr-源码与用法" class="headerlink" title="1. unique_ptr 源码与用法"></a>1. unique_ptr 源码与用法</h3><h4 id="unique-ptr-核心实现"><a href="#unique-ptr-核心实现" class="headerlink" title="unique_ptr 核心实现"></a>unique_ptr 核心实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// libstdc++ 源码片段</span><br><span class="hljs-comment">// unique_ptr 只持有裸指针和删除器</span><br>pointer _M_ptr;<br>_Deleter _M_deleter;<br>~<span class="hljs-built_in">unique_ptr</span>() &#123; <span class="hljs-keyword">if</span> (_M_ptr) _M_deleter(_M_ptr); &#125;<br></code></pre></td></tr></table></figure><h4 id="实战：unique-ptr-管理数组和自定义资源"><a href="#实战：unique-ptr-管理数组和自定义资源" class="headerlink" title="实战：unique_ptr 管理数组和自定义资源"></a>实战：unique_ptr 管理数组和自定义资源</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">arr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br><span class="hljs-function">std::unique_ptr&lt;FILE, <span class="hljs-title">decltype</span><span class="hljs-params">(&amp;fclose)</span>&gt; <span class="hljs-title">fp</span><span class="hljs-params">(fopen(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>), fclose)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="2-shared-ptr-weak-ptr-源码与循环引用"><a href="#2-shared-ptr-weak-ptr-源码与循环引用" class="headerlink" title="2. shared_ptr&#x2F;weak_ptr 源码与循环引用"></a>2. shared_ptr&#x2F;weak_ptr 源码与循环引用</h3><h4 id="shared-ptr-控制块与引用计数"><a href="#shared-ptr-控制块与引用计数" class="headerlink" title="shared_ptr 控制块与引用计数"></a>shared_ptr 控制块与引用计数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// libstdc++ 源码片段</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_Sp_counted_base</span> &#123;<br>    std::atomic&lt;<span class="hljs-type">long</span>&gt; _M_use_count;<br>    std::atomic&lt;<span class="hljs-type">long</span>&gt; _M_weak_count;<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> _M_dispose() <span class="hljs-keyword">noexcept</span> = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">// shared_ptr 持有指针和控制块指针</span><br></code></pre></td></tr></table></figure><h4 id="实战：循环引用与-weak-ptr-规避"><a href="#实战：循环引用与-weak-ptr-规避" class="headerlink" title="实战：循环引用与 weak_ptr 规避"></a>实战：循环引用与 weak_ptr 规避</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    std::shared_ptr&lt;Node&gt; next;<br>    std::weak_ptr&lt;Node&gt; prev;<br>&#125;;<br><span class="hljs-keyword">auto</span> a = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br><span class="hljs-keyword">auto</span> b = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br>a-&gt;next = b;<br>b-&gt;prev = a; <span class="hljs-comment">// 不会泄漏</span><br></code></pre></td></tr></table></figure><h4 id="自定义删除器与资源管理"><a href="#自定义删除器与资源管理" class="headerlink" title="自定义删除器与资源管理"></a>自定义删除器与资源管理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FileCloser</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(FILE* f)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">if</span> (f) <span class="hljs-built_in">fclose</span>(f); &#125;<br>&#125;;<br><span class="hljs-function">std::shared_ptr&lt;FILE&gt; <span class="hljs-title">fp</span><span class="hljs-params">(fopen(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>), FileCloser())</span></span>;<br></code></pre></td></tr></table></figure><h3 id="3-性能与多线程"><a href="#3-性能与多线程" class="headerlink" title="3. 性能与多线程"></a>3. 性能与多线程</h3><ul><li>shared_ptr 控制块引用计数是原子操作，libc++&#x2F;libstdc++ 源码均用 std::atomic<long>。</li><li>unique_ptr 无锁，适合高性能场景。</li></ul><hr><h2 id="三、自定义内存分配器（allocator）设计与实现"><a href="#三、自定义内存分配器（allocator）设计与实现" class="headerlink" title="三、自定义内存分配器（allocator）设计与实现"></a>三、自定义内存分配器（allocator）设计与实现</h2><h3 id="1-STL-allocator-接口与实现细节"><a href="#1-STL-allocator-接口与实现细节" class="headerlink" title="1. STL allocator 接口与实现细节"></a>1. STL allocator 接口与实现细节</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyAllocator</span> &#123;<br>    <span class="hljs-keyword">using</span> value_type = T;<br>    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> n)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Alloc &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; x &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(T) &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(n * <span class="hljs-built_in">sizeof</span>(T)));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* p, std::<span class="hljs-type">size_t</span>)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Dealloc&quot;</span> &lt;&lt; std::endl;<br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<br>    &#125;<br>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>, MyAllocator&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">v</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h3 id="2-池化分配器完整实战"><a href="#2-池化分配器完整实战" class="headerlink" title="2. 池化分配器完整实战"></a>2. 池化分配器完整实战</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>    std::vector&lt;<span class="hljs-type">void</span>*&gt; free_blocks;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> sz)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!free_blocks.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">void</span>* p = free_blocks.<span class="hljs-built_in">back</span>(); free_blocks.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(sz);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-type">void</span>* p)</span> </span>&#123; free_blocks.<span class="hljs-built_in">push_back</span>(p); &#125;<br>    ~<span class="hljs-built_in">Pool</span>() &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">void</span>* p : free_blocks) ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>; &#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyObj</span> &#123; <span class="hljs-type">int</span> x; &#125;;<br>Pool pool;<br>MyObj* obj = <span class="hljs-built_in">new</span> (pool.<span class="hljs-built_in">allocate</span>(<span class="hljs-built_in">sizeof</span>(MyObj))) <span class="hljs-built_in">MyObj</span>();<br>obj-&gt;~<span class="hljs-built_in">MyObj</span>(); pool.<span class="hljs-built_in">deallocate</span>(obj);<br></code></pre></td></tr></table></figure><h3 id="3-对齐分配器源码与-benchmark"><a href="#3-对齐分配器源码与-benchmark" class="headerlink" title="3. 对齐分配器源码与 benchmark"></a>3. 对齐分配器源码与 benchmark</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-type">void</span>* p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">auto</span> t1 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) &#123;<br>    <span class="hljs-built_in">posix_memalign</span>(&amp;p, <span class="hljs-number">64</span>, <span class="hljs-number">1024</span>);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br><span class="hljs-keyword">auto</span> t2 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Aligned alloc time: &quot;</span> &lt;&lt; (t2-t1).<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><hr><h2 id="四、内存模型与-memory-order（并发相关）"><a href="#四、内存模型与-memory-order（并发相关）" class="headerlink" title="四、内存模型与 memory_order（并发相关）"></a>四、内存模型与 memory_order（并发相关）</h2><h3 id="1-atomic-源码与内存序可视化"><a href="#1-atomic-源码与内存序可视化" class="headerlink" title="1. atomic 源码与内存序可视化"></a>1. atomic 源码与内存序可视化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; x&#123;<span class="hljs-number">0</span>&#125;;<br>x.<span class="hljs-built_in">store</span>(<span class="hljs-number">1</span>, std::memory_order_relaxed);<br><span class="hljs-type">int</span> y = x.<span class="hljs-built_in">load</span>(std::memory_order_acquire);<br><span class="hljs-comment">// libstdc++源码: atomic&lt;T&gt; 内部用 __atomic_store_n/__atomic_load_n</span><br></code></pre></td></tr></table></figure><h3 id="2-并发-bug-实战"><a href="#2-并发-bug-实战" class="headerlink" title="2. 并发 bug 实战"></a>2. 并发 bug 实战</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br>std::atomic&lt;<span class="hljs-type">bool</span>&gt; ready&#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;<br>    data = <span class="hljs-number">42</span>;<br>    ready.<span class="hljs-built_in">store</span>(<span class="hljs-literal">true</span>, std::memory_order_release);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!ready.<span class="hljs-built_in">load</span>(std::memory_order_acquire));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data=%d\n&quot;</span>, data); <span class="hljs-comment">// 保证看到 data=42</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>若不用 acquire&#x2F;release，reader 可能看到 data&#x3D;0。</li></ul><hr><h2 id="五、内存泄漏检测工具与方法论"><a href="#五、内存泄漏检测工具与方法论" class="headerlink" title="五、内存泄漏检测工具与方法论"></a>五、内存泄漏检测工具与方法论</h2><h3 id="1-Valgrind-ASan-实际输出样例"><a href="#1-Valgrind-ASan-实际输出样例" class="headerlink" title="1. Valgrind&#x2F;ASan 实际输出样例"></a>1. Valgrind&#x2F;ASan 实际输出样例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">==12345== LEAK SUMMARY:<br>==12345==    definitely lost: 4 bytes <span class="hljs-keyword">in</span> 1 blocks<br>==12345==    indirectly lost: 0 bytes <span class="hljs-keyword">in</span> 0 blocks<br>==12345==    possibly lost: 0 bytes <span class="hljs-keyword">in</span> 0 blocks<br>==12345==    still reachable: 0 bytes <span class="hljs-keyword">in</span> 0 blocks<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// AddressSanitizer 检查悬垂指针</span><br><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">delete</span> p;<br>*p = <span class="hljs-number">2</span>; <span class="hljs-comment">// 运行时报错：heap-use-after-free</span><br></code></pre></td></tr></table></figure><h3 id="2-定位和修复真实泄漏案例"><a href="#2-定位和修复真实泄漏案例" class="headerlink" title="2. 定位和修复真实泄漏案例"></a>2. 定位和修复真实泄漏案例</h3><ul><li>通过工具定位泄漏位置，结合代码审查修复。</li><li>实战建议：每次 new&#x2F;new[] 必须有唯一 delete&#x2F;delete[] 路径。</li><li>用智能指针和容器规避绝大多数泄漏。</li></ul><hr><h2 id="六、std-make-shared-vs-new-std-shared-ptr"><a href="#六、std-make-shared-vs-new-std-shared-ptr" class="headerlink" title="六、std::make_shared vs new + std::shared_ptr"></a>六、std::make_shared vs new + std::shared_ptr</h2><h3 id="1-libc-libstdc-源码片段"><a href="#1-libc-libstdc-源码片段" class="headerlink" title="1. libc++&#x2F;libstdc++ 源码片段"></a>1. libc++&#x2F;libstdc++ 源码片段</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// make_shared 源码核心</span><br><span class="hljs-comment">// libc++: _Sp_counted_ptr_inplace&lt;T, Alloc, ...&gt; 控制块和对象一起分配</span><br><span class="hljs-comment">// new+shared_ptr: _Sp_counted_ptr&lt;T, ...&gt; 控制块和对象分开分配</span><br></code></pre></td></tr></table></figure><h3 id="2-异常安全测试代码"><a href="#2-异常安全测试代码" class="headerlink" title="2. 异常安全测试代码"></a>2. 异常安全测试代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bad</span> &#123; <span class="hljs-built_in">Bad</span>() &#123; <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;fail&quot;</span>); &#125; &#125;;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">shared_ptr</span>&lt;Bad&gt;(<span class="hljs-keyword">new</span> Bad); <span class="hljs-comment">// 可能泄漏</span><br>&#125; <span class="hljs-built_in">catch</span> (...) &#123;&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_shared</span>&lt;Bad&gt;(); <span class="hljs-comment">// 不会泄漏</span><br>&#125; <span class="hljs-built_in">catch</span> (...) &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="3-性能-benchmark-实测"><a href="#3-性能-benchmark-实测" class="headerlink" title="3. 性能 benchmark 实测"></a>3. 性能 benchmark 实测</h3><pre><code class="cpp">#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;chrono&gt;int main() &#123;    std::vector&lt;std::shared_ptr&lt;int&gt;&gt; v1, v2;    auto t1 = std::chrono::high_resolution_clock::now();    for (int i = 0; i &lt; 100000; ++i) v1.push_back(std::make_shared&lt;int&gt;(i));    auto t2 = std::chrono::high_resolution_clock::now();    for (int i = 0; i &lt; 100000; ++i) v2.push_back(std::shared_ptr&lt;int&gt;(new int(i)));    auto t3 = std::chrono::high_resolution_clock::now();    std::cout &lt;&lt; &quot;make_shared: &quot; &lt;&lt; (t2-t1).count() &lt;&lt; &quot;, new+shared_ptr: &quot; &lt;&lt; (t3-t2).count() &lt;&lt; std::endl;&#125; </code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>内存管理</tag>
      
      <tag>智能指针</tag>
      
      <tag>分配器</tag>
      
      <tag>并发</tag>
      
      <tag>性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++工程实践与性能优化</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="C-工程实践与性能优化"><a href="#C-工程实践与性能优化" class="headerlink" title="C++ 工程实践与性能优化"></a>C++ 工程实践与性能优化</h1><hr><h2 id="一、C-项目结构组织与模块划分实践"><a href="#一、C-项目结构组织与模块划分实践" class="headerlink" title="一、C++项目结构组织与模块划分实践"></a>一、C++项目结构组织与模块划分实践</h2><h3 id="1-典型目录结构"><a href="#1-典型目录结构" class="headerlink" title="1. 典型目录结构"></a>1. 典型目录结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">project/<br>  CMakeLists<span class="hljs-selector-class">.txt</span><br>  include/<br>    project/<br>      foo<span class="hljs-selector-class">.h</span><br>      bar<span class="hljs-selector-class">.h</span><br>  <span class="hljs-attribute">src</span>/<br>    foo<span class="hljs-selector-class">.cpp</span><br>    bar<span class="hljs-selector-class">.cpp</span><br>  tests/<br>    test_foo<span class="hljs-selector-class">.cpp</span><br>  third_party/<br></code></pre></td></tr></table></figure><ul><li>include&#x2F; 头文件，src&#x2F; 源文件，tests&#x2F; 单元测试，third_party&#x2F; 外部依赖。</li><li>建议每个模块独立头&#x2F;源文件，接口与实现分离。</li></ul><h3 id="2-分层设计案例"><a href="#2-分层设计案例" class="headerlink" title="2. 分层设计案例"></a>2. 分层设计案例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// include/project/foo.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">namespace</span> project &#123; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span></span>; &#125;; &#125;<br><br><span class="hljs-comment">// src/foo.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;project/foo.h&quot;</span></span><br><span class="hljs-type">void</span> project::Foo::<span class="hljs-built_in">do_something</span>() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><hr><h2 id="二、CMake-Bazel现代构建系统高级用法与最佳实践"><a href="#二、CMake-Bazel现代构建系统高级用法与最佳实践" class="headerlink" title="二、CMake&#x2F;Bazel现代构建系统高级用法与最佳实践"></a>二、CMake&#x2F;Bazel现代构建系统高级用法与最佳实践</h2><h3 id="1-CMake-跨平台配置"><a href="#1-CMake-跨平台配置" class="headerlink" title="1. CMake 跨平台配置"></a>1. CMake 跨平台配置</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><span class="hljs-keyword">project</span>(MyApp)<br><span class="hljs-keyword">add_library</span>(core src/foo.cpp src/bar.cpp)<br><span class="hljs-keyword">target_include_directories</span>(core PUBLIC <span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">add_executable</span>(main src/main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(main core)<br></code></pre></td></tr></table></figure><ul><li>使用 target_xxx 接口，避免全局变量污染。</li><li>支持多平台（Windows&#x2F;Linux&#x2F;macOS），条件编译：</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(WIN32)<br>  <span class="hljs-keyword">target_compile_definitions</span>(core PRIVATE PLATFORM_WINDOWS)<br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><h3 id="2-Bazel-基本用法"><a href="#2-Bazel-基本用法" class="headerlink" title="2. Bazel 基本用法"></a>2. Bazel 基本用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># BUILD</span><br>cc_library(<br>  name = <span class="hljs-string">&quot;core&quot;</span>,<br>  srcs = [<span class="hljs-string">&quot;foo.cpp&quot;</span>, <span class="hljs-string">&quot;bar.cpp&quot;</span>],<br>  hdrs = [<span class="hljs-string">&quot;foo.h&quot;</span>, <span class="hljs-string">&quot;bar.h&quot;</span>],<br>  includes = [<span class="hljs-string">&quot;include&quot;</span>],<br>)<br>cc_binary(<br>  name = <span class="hljs-string">&quot;main&quot;</span>,<br>  srcs = [<span class="hljs-string">&quot;main.cpp&quot;</span>],<br>  deps = [<span class="hljs-string">&quot;:core&quot;</span>],<br>)<br></code></pre></td></tr></table></figure><hr><h2 id="三、接口设计原则在C-中的应用（SOLID-RAII-PIMPL）"><a href="#三、接口设计原则在C-中的应用（SOLID-RAII-PIMPL）" class="headerlink" title="三、接口设计原则在C++中的应用（SOLID, RAII, PIMPL）"></a>三、接口设计原则在C++中的应用（SOLID, RAII, PIMPL）</h2><h3 id="1-SOLID原则"><a href="#1-SOLID原则" class="headerlink" title="1. SOLID原则"></a>1. SOLID原则</h3><ul><li>单一职责、开放封闭、里氏替换、接口隔离、依赖倒置。</li><li>C++接口用纯虚类、模板、RAII等实现。</li></ul><h3 id="2-RAII与资源管理"><a href="#2-RAII与资源管理" class="headerlink" title="2. RAII与资源管理"></a>2. RAII与资源管理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> &#123;<br>    FILE* fp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">File</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name) : <span class="hljs-built_in">fp</span>(<span class="hljs-built_in">fopen</span>(name, <span class="hljs-string">&quot;r&quot;</span>)) &#123;&#125;<br>    ~<span class="hljs-built_in">File</span>() &#123; <span class="hljs-keyword">if</span> (fp) <span class="hljs-built_in">fclose</span>(fp); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-PIMPL惯用法详解"><a href="#3-PIMPL惯用法详解" class="headerlink" title="3. PIMPL惯用法详解"></a>3. PIMPL惯用法详解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// foo.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>();<br>    ~<span class="hljs-built_in">Foo</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_something</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Impl</span>;<br>    Impl* pImpl;<br>&#125;;<br><span class="hljs-comment">// foo.cpp</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>::Impl &#123; <span class="hljs-type">int</span> data; &#125;;<br>Foo::<span class="hljs-built_in">Foo</span>() : <span class="hljs-built_in">pImpl</span>(<span class="hljs-keyword">new</span> Impl) &#123;&#125;<br>Foo::~<span class="hljs-built_in">Foo</span>() &#123; <span class="hljs-keyword">delete</span> pImpl; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Foo::do_something</span><span class="hljs-params">()</span> </span>&#123; pImpl-&gt;data = <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure><ul><li>优点：降低编译依赖，提升二进制兼容性。</li><li>缺点：多一次间接，略有性能损耗。</li></ul><hr><h2 id="四、依赖管理（vcpkg-conan-build2）"><a href="#四、依赖管理（vcpkg-conan-build2）" class="headerlink" title="四、依赖管理（vcpkg, conan, build2）"></a>四、依赖管理（vcpkg, conan, build2）</h2><h3 id="1-vcpkg"><a href="#1-vcpkg" class="headerlink" title="1. vcpkg"></a>1. vcpkg</h3><ul><li>微软开源，跨平台包管理。</li><li>用法：<code>vcpkg install boost</code></li><li>CMake集成：</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(boost CONFIG REQUIRED)<br><span class="hljs-keyword">target_link_libraries</span>(main PRIVATE boost::boost)<br></code></pre></td></tr></table></figure><h3 id="2-conan"><a href="#2-conan" class="headerlink" title="2. conan"></a>2. conan</h3><ul><li>Python实现，支持多版本、二进制包。</li><li>用法：<code>conan install . --build=missing</code></li><li>CMake集成：</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">include</span>(<span class="hljs-variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/conanbuildinfo.cmake)<br>conan_basic_setup()<br></code></pre></td></tr></table></figure><h3 id="3-build2"><a href="#3-build2" class="headerlink" title="3. build2"></a>3. build2</h3><ul><li>现代C++构建+包管理一体化。</li><li>用法：<code>b install libfoo</code></li></ul><hr><h2 id="五、跨平台开发挑战与解决方案"><a href="#五、跨平台开发挑战与解决方案" class="headerlink" title="五、跨平台开发挑战与解决方案"></a>五、跨平台开发挑战与解决方案</h2><h3 id="1-平台差异"><a href="#1-平台差异" class="headerlink" title="1. 平台差异"></a>1. 平台差异</h3><ul><li>路径分隔符、文件权限、动态库加载、线程API等。</li><li>解决：用CMake条件编译、抽象平台相关代码。</li></ul><h3 id="2-CMake跨平台配置"><a href="#2-CMake跨平台配置" class="headerlink" title="2. CMake跨平台配置"></a>2. CMake跨平台配置</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(WIN32)<br>  <span class="hljs-comment"># Windows特有设置</span><br><span class="hljs-keyword">elseif</span>(APPLE)<br>  <span class="hljs-comment"># macOS特有设置</span><br><span class="hljs-keyword">else</span>()<br>  <span class="hljs-comment"># Linux特有设置</span><br><span class="hljs-keyword">endif</span>()<br></code></pre></td></tr></table></figure><hr><h2 id="六、使用CMake管理大型跨平台C-项目的实战经验"><a href="#六、使用CMake管理大型跨平台C-项目的实战经验" class="headerlink" title="六、使用CMake管理大型跨平台C++项目的实战经验"></a>六、使用CMake管理大型跨平台C++项目的实战经验</h2><h3 id="1-完整CMakeLists-txt案例"><a href="#1-完整CMakeLists-txt案例" class="headerlink" title="1. 完整CMakeLists.txt案例"></a>1. 完整CMakeLists.txt案例</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.20</span>)<br><span class="hljs-keyword">project</span>(BigProject)<br><span class="hljs-keyword">add_subdirectory</span>(core)<br><span class="hljs-keyword">add_subdirectory</span>(app)<br><span class="hljs-keyword">add_subdirectory</span>(tests)<br></code></pre></td></tr></table></figure><ul><li>每个模块独立CMakeLists.txt，支持可选组件、自动测试。</li><li>建议用target_xxx接口，避免全局变量。</li></ul><hr><h2 id="七、PIMPL惯用法详解：降低编译依赖与二进制兼容性"><a href="#七、PIMPL惯用法详解：降低编译依赖与二进制兼容性" class="headerlink" title="七、PIMPL惯用法详解：降低编译依赖与二进制兼容性"></a>七、PIMPL惯用法详解：降低编译依赖与二进制兼容性</h2><h3 id="1-源码与优缺点"><a href="#1-源码与优缺点" class="headerlink" title="1. 源码与优缺点"></a>1. 源码与优缺点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// bar.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Bar</span>();<br>    ~<span class="hljs-built_in">Bar</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_work</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Impl</span>;<br>    Impl* pImpl;<br>&#125;;<br><span class="hljs-comment">// bar.cpp</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bar</span>::Impl &#123; <span class="hljs-type">int</span> state; &#125;;<br>Bar::<span class="hljs-built_in">Bar</span>() : <span class="hljs-built_in">pImpl</span>(<span class="hljs-keyword">new</span> Impl) &#123;&#125;<br>Bar::~<span class="hljs-built_in">Bar</span>() &#123; <span class="hljs-keyword">delete</span> pImpl; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bar::do_work</span><span class="hljs-params">()</span> </span>&#123; pImpl-&gt;state = <span class="hljs-number">100</span>; &#125;<br></code></pre></td></tr></table></figure><ul><li>只需重新编译实现文件，接口二进制兼容。</li></ul><hr><h2 id="八、高级调试与诊断"><a href="#八、高级调试与诊断" class="headerlink" title="八、高级调试与诊断"></a>八、高级调试与诊断</h2><h3 id="1-gdb-lldb命令与core-dump分析"><a href="#1-gdb-lldb命令与core-dump分析" class="headerlink" title="1. gdb&#x2F;lldb命令与core dump分析"></a>1. gdb&#x2F;lldb命令与core dump分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb ./main core<br>bt <span class="hljs-comment"># 打印调用栈</span><br>frame 2<br><span class="hljs-built_in">print</span> var<br></code></pre></td></tr></table></figure><h3 id="2-Sanitizers检测"><a href="#2-Sanitizers检测" class="headerlink" title="2. Sanitizers检测"></a>2. Sanitizers检测</h3><ul><li>AddressSanitizer: 检查越界、悬垂指针。</li><li>ThreadSanitizer: 检查数据竞争。</li><li>MemorySanitizer: 检查未初始化。</li><li>UndefinedBehaviorSanitizer: 检查未定义行为。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -fsanitize=address -g main.cpp<br>./a.out<br></code></pre></td></tr></table></figure><h3 id="3-静态分析工具集成"><a href="#3-静态分析工具集成" class="headerlink" title="3. 静态分析工具集成"></a>3. 静态分析工具集成</h3><ul><li>clang-tidy, Cppcheck, PVS-Studio。</li><li>CMake集成：</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(CMAKE_CXX_CLANG_TIDY <span class="hljs-string">&quot;clang-tidy&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-性能剖析工具"><a href="#4-性能剖析工具" class="headerlink" title="4. 性能剖析工具"></a>4. 性能剖析工具</h3><ul><li>perf, vtune, valgrind&#x2F;callgrind, gprof。</li><li>用法与结果解读见前文。</li></ul><hr><h2 id="九、性能优化实践"><a href="#九、性能优化实践" class="headerlink" title="九、性能优化实践"></a>九、性能优化实践</h2><h3 id="1-CPU缓存友好性编程"><a href="#1-CPU缓存友好性编程" class="headerlink" title="1. CPU缓存友好性编程"></a>1. CPU缓存友好性编程</h3><ul><li>优先顺序访问、结构体紧凑、避免链表。</li></ul><h4 id="案例：矩阵乘法优化"><a href="#案例：矩阵乘法优化" class="headerlink" title="案例：矩阵乘法优化"></a>案例：矩阵乘法优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">matmul</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">float</span>&gt;&gt;&amp; A,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">float</span>&gt;&gt;&amp; B,</span></span><br><span class="hljs-params"><span class="hljs-function">            std::vector&lt;std::vector&lt;<span class="hljs-type">float</span>&gt;&gt;&amp; C)</span> </span>&#123;<br>    <span class="hljs-type">int</span> N = A.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; N; ++k)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>                C[i][j] += A[i][k] * B[k][j];<br>&#125;<br><span class="hljs-comment">// 优化：块状乘法（cache blocking）</span><br></code></pre></td></tr></table></figure><h3 id="2-SIMD向量化优化（SSE-AVX）"><a href="#2-SIMD向量化优化（SSE-AVX）" class="headerlink" title="2. SIMD向量化优化（SSE&#x2F;AVX）"></a>2. SIMD向量化优化（SSE&#x2F;AVX）</h3><h4 id="案例：AVX2加速图像处理"><a href="#案例：AVX2加速图像处理" class="headerlink" title="案例：AVX2加速图像处理"></a>案例：AVX2加速图像处理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;immintrin.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_avx2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">float</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">float</span>* b, <span class="hljs-type">float</span>* out, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i + <span class="hljs-number">8</span> &lt;= n; i += <span class="hljs-number">8</span>) &#123;<br>        __m256 va = _mm256_loadu_ps(a + i);<br>        __m256 vb = _mm256_loadu_ps(b + i);<br>        __m256 vc = _mm256_add_ps(va, vb);<br>        _mm256_storeu_ps(out + i, vc);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; i &lt; n; ++i) out[i] = a[i] + b[i];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-减少动态内存分配"><a href="#3-减少动态内存分配" class="headerlink" title="3. 减少动态内存分配"></a>3. 减少动态内存分配</h3><ul><li>用对象池、自定义分配器、预分配vector等。</li></ul><h3 id="4-虚函数调用优化"><a href="#4-虚函数调用优化" class="headerlink" title="4. 虚函数调用优化"></a>4. 虚函数调用优化</h3><ul><li>用CRTP、函数对象、内联等替代虚函数。</li></ul><h3 id="5-分支预测优化"><a href="#5-分支预测优化" class="headerlink" title="5. 分支预测优化"></a>5. 分支预测优化</h3><ul><li>likely&#x2F;unlikely宏，GCC&#x2F;Clang: <code>__builtin_expect</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (__builtin_expect(x &gt; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><hr><p>如需某一部分更深入源码分析或实战案例，请随时告知！ </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>工程实践</tag>
      
      <tag>构建系统</tag>
      
      <tag>CMake</tag>
      
      <tag>Bazel</tag>
      
      <tag>依赖管理</tag>
      
      <tag>跨平台</tag>
      
      <tag>调试</tag>
      
      <tag>性能优化</tag>
      
      <tag>SIMD</tag>
      
      <tag>PIMPL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级并发机制详解</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/C++%E9%AB%98%E7%BA%A7%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/C++%E9%AB%98%E7%BA%A7%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="C-高级并发机制详解"><a href="#C-高级并发机制详解" class="headerlink" title="C++ 高级并发机制详解"></a>C++ 高级并发机制详解</h1><hr><h2 id="一、std-atomic-类型与-memory-order-详解"><a href="#一、std-atomic-类型与-memory-order-详解" class="headerlink" title="一、std::atomic 类型与 memory_order 详解"></a>一、std::atomic 类型与 memory_order 详解</h2><h3 id="1-std-atomic-基础"><a href="#1-std-atomic-基础" class="headerlink" title="1. std::atomic 基础"></a>1. std::atomic 基础</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; x&#123;<span class="hljs-number">0</span>&#125;;<br>x.<span class="hljs-built_in">store</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 默认seq_cst</span><br><span class="hljs-type">int</span> y = x.<span class="hljs-built_in">load</span>();<br></code></pre></td></tr></table></figure><ul><li>std::atomic 保证多线程下的原子性和可见性。</li></ul><h3 id="2-memory-order-详解"><a href="#2-memory-order-详解" class="headerlink" title="2. memory_order 详解"></a>2. memory_order 详解</h3><ul><li><strong>memory_order_relaxed</strong>：仅保证原子性，不保证有序性。</li><li><strong>memory_order_consume</strong>：数据依赖同步（极少用）。</li><li><strong>memory_order_acquire</strong>：读屏障，保证前序写对本线程可见。</li><li><strong>memory_order_release</strong>：写屏障，保证前序写对后续acquire可见。</li><li><strong>memory_order_acq_rel</strong>：同时acquire和release。</li><li><strong>memory_order_seq_cst</strong>：全序，最强保证，默认。</li></ul><h4 id="典型代码"><a href="#典型代码" class="headerlink" title="典型代码"></a>典型代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br>std::atomic&lt;<span class="hljs-type">int</span>&gt; flag&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;<br>    data = <span class="hljs-number">42</span>;<br>    flag.<span class="hljs-built_in">store</span>(<span class="hljs-number">1</span>, std::memory_order_release);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (!flag.<span class="hljs-built_in">load</span>(std::memory_order_acquire));<br>    <span class="hljs-built_in">assert</span>(data == <span class="hljs-number">42</span>); <span class="hljs-comment">// acquire-release保证可见性</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><ul><li>release写 -&gt; happens-before -&gt; acquire读</li><li>relaxed下不保证顺序，seq_cst全局有序</li></ul><hr><h2 id="二、无锁编程基础与典型案例"><a href="#二、无锁编程基础与典型案例" class="headerlink" title="二、无锁编程基础与典型案例"></a>二、无锁编程基础与典型案例</h2><h3 id="1-无锁栈（Treiber-Stack）"><a href="#1-无锁栈（Treiber-Stack）" class="headerlink" title="1. 无锁栈（Treiber Stack）"></a>1. 无锁栈（Treiber Stack）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123; <span class="hljs-type">int</span> val; Node* next; &#125;;<br>std::atomic&lt;Node*&gt; head&#123;<span class="hljs-literal">nullptr</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>    Node* n = <span class="hljs-keyword">new</span> Node&#123;v&#125;;<br>    <span class="hljs-keyword">do</span> &#123;<br>        n-&gt;next = head.<span class="hljs-built_in">load</span>();<br>    &#125; <span class="hljs-keyword">while</span> (!head.<span class="hljs-built_in">compare_exchange_weak</span>(n-&gt;next, n));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    Node* n;<br>    <span class="hljs-keyword">do</span> &#123;<br>        n = head.<span class="hljs-built_in">load</span>();<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">while</span> (!head.<span class="hljs-built_in">compare_exchange_weak</span>(n, n-&gt;next));<br>    <span class="hljs-type">int</span> v = n-&gt;val; <span class="hljs-keyword">delete</span> n; <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>ABA问题</strong>：节点被反复插入&#x2F;删除，CAS误判。解决：加版本号或用hazard pointer。</li></ul><h3 id="2-无锁队列（Michael-Scott-Queue）"><a href="#2-无锁队列（Michael-Scott-Queue）" class="headerlink" title="2. 无锁队列（Michael-Scott Queue）"></a>2. 无锁队列（Michael-Scott Queue）</h3><ul><li>见libcds&#x2F;concurrentqueue等库源码。</li></ul><hr><h2 id="三、std-promise-std-future-std-async-实现异步操作"><a href="#三、std-promise-std-future-std-async-实现异步操作" class="headerlink" title="三、std::promise, std::future, std::async 实现异步操作"></a>三、std::promise, std::future, std::async 实现异步操作</h2><h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; f = std::<span class="hljs-built_in">async</span>(std::launch::async, compute);<br>    std::cout &lt;&lt; f.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-promise-future-通信"><a href="#2-promise-future-通信" class="headerlink" title="2. promise-future 通信"></a>2. promise-future 通信</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::promise&lt;<span class="hljs-type">int</span>&gt; p;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; f = p.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;p]&#123; p.set_value(<span class="hljs-number">123</span>); &#125;)</span></span>;<br>    std::cout &lt;&lt; f.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>    t.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>std::async 底层用线程池&#x2F;线程调度，future&#x2F;promise用共享状态通信。</li></ul><hr><h2 id="四、std-shared-mutex（读写锁）应用"><a href="#四、std-shared-mutex（读写锁）应用" class="headerlink" title="四、std::shared_mutex（读写锁）应用"></a>四、std::shared_mutex（读写锁）应用</h2><h3 id="1-用法与性能"><a href="#1-用法与性能" class="headerlink" title="1. 用法与性能"></a>1. 用法与性能</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>std::shared_mutex mtx;<br><span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::shared_lock <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    std::cout &lt;&lt; data &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>    data++;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>多读单写，读操作可并发，写操作独占。</li><li>性能优于互斥锁（std::mutex）在读多写少场景。</li></ul><hr><h2 id="五、C-20-std-latch-std-barrier-std-counting-semaphore"><a href="#五、C-20-std-latch-std-barrier-std-counting-semaphore" class="headerlink" title="五、C++20 std::latch, std::barrier, std::counting_semaphore"></a>五、C++20 std::latch, std::barrier, std::counting_semaphore</h2><h3 id="1-std-latch"><a href="#1-std-latch" class="headerlink" title="1. std::latch"></a>1. std::latch</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;latch&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-function">std::latch <span class="hljs-title">done</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* ... */</span> done.<span class="hljs-built_in">count_down</span>(); &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(worker)</span>, <span class="hljs-title">t2</span><span class="hljs-params">(worker)</span>, <span class="hljs-title">t3</span><span class="hljs-params">(worker)</span></span>;<br>    done.<span class="hljs-built_in">wait</span>();<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>(); t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>(); t<span class="hljs-number">3.</span><span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-std-barrier"><a href="#2-std-barrier" class="headerlink" title="2. std::barrier"></a>2. std::barrier</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;barrier&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function">std::barrier <span class="hljs-title">sync</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    sync.<span class="hljs-built_in">arrive_and_wait</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-std-counting-semaphore"><a href="#3-std-counting-semaphore" class="headerlink" title="3. std::counting_semaphore"></a>3. std::counting_semaphore</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function">std::counting_semaphore&lt;2&gt; <span class="hljs-title">sem</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">worker</span><span class="hljs-params">()</span> </span>&#123;<br>    sem.<span class="hljs-built_in">acquire</span>();<br>    <span class="hljs-comment">// ...</span><br>    sem.<span class="hljs-built_in">release</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="六、理解C-内存模型：happens-before关系与memory-order的选择"><a href="#六、理解C-内存模型：happens-before关系与memory-order的选择" class="headerlink" title="六、理解C++内存模型：happens-before关系与memory_order的选择"></a>六、理解C++内存模型：happens-before关系与memory_order的选择</h2><h3 id="1-happens-before-原理"><a href="#1-happens-before-原理" class="headerlink" title="1. happens-before 原理"></a>1. happens-before 原理</h3><ul><li>A happens-before B：A的写对B可见，保证有序。</li><li>acquire-release、seq_cst、mutex等都建立happens-before。</li></ul><h3 id="2-memory-order选择建议"><a href="#2-memory-order选择建议" class="headerlink" title="2. memory_order选择建议"></a>2. memory_order选择建议</h3><ul><li>默认用seq_cst，保证全局有序。</li><li>性能敏感场景可用acquire&#x2F;release。</li><li>relaxed仅用于无依赖、无顺序要求的统计等。</li></ul><h4 id="典型调试技巧"><a href="#典型调试技巧" class="headerlink" title="典型调试技巧"></a>典型调试技巧</h4><ul><li>用ThreadSanitizer检测数据竞争。</li><li>用assert验证并发可见性。</li></ul><hr><p>如需某一部分更深入源码分析或实战案例，请随时告知！ </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>并发</tag>
      
      <tag>原子操作</tag>
      
      <tag>无锁编程</tag>
      
      <tag>异步</tag>
      
      <tag>读写锁</tag>
      
      <tag>同步原语</tag>
      
      <tag>内存模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++对象模型与性能详解</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="C-对象模型与性能详解"><a href="#C-对象模型与性能详解" class="headerlink" title="C++ 对象模型与性能详解"></a>C++ 对象模型与性能详解</h1><hr><h2 id="一、C-对象内存布局"><a href="#一、C-对象内存布局" class="headerlink" title="一、C++ 对象内存布局"></a>一、C++ 对象内存布局</h2><h3 id="1-vptr-vtbl-机制"><a href="#1-vptr-vtbl-机制" class="headerlink" title="1. vptr&#x2F;vtbl 机制"></a>1. vptr&#x2F;vtbl 机制</h3><ul><li>带虚函数的类，编译器会在对象头部插入一个指向虚表（vtbl）的指针（vptr）。</li><li>虚表存储所有虚函数的地址，实现动态多态。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : Base &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; &#125;<br>    <span class="hljs-type">int</span> y;<br>&#125;;<br><br>Base b;<br>Derived d;<br></code></pre></td></tr></table></figure><ul><li>内存布局（64位）：<ul><li>Base: [vptr][x]</li><li>Derived: [vptr][x][y]</li></ul></li></ul><h4 id="内存结构图"><a href="#内存结构图" class="headerlink" title="内存结构图"></a>内存结构图</h4><pre><code class=" mermaid">graph TD  A[&quot;Base对象&quot;] --&gt; B[&quot;vptr&quot;]  A --&gt; C[&quot;x&quot;]  D[&quot;Derived对象&quot;] --&gt; B  D --&gt; C  D --&gt; E[&quot;y&quot;]</code></pre><h3 id="2-多重继承与虚继承"><a href="#2-多重继承与虚继承" class="headerlink" title="2. 多重继承与虚继承"></a>2. 多重继承与虚继承</h3><ul><li>多重继承：每个基类有独立的子对象和vptr。</li><li>虚继承：只保留一份虚基类子对象，子对象中有指向虚基类的指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-type">int</span> a; <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fa</span><span class="hljs-params">()</span> </span>&#123;&#125; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123; <span class="hljs-type">int</span> b; <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fb</span><span class="hljs-params">()</span> </span>&#123;&#125; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> : A, B &#123; <span class="hljs-type">int</span> c; &#125;;<br><br>C obj;<br></code></pre></td></tr></table></figure><ul><li><p>内存布局：</p><ul><li>[A::vptr][A::a][B::vptr][B::b][c]</li></ul></li><li><p>虚继承：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VBase</span> &#123; <span class="hljs-type">int</span> v; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D1</span> : <span class="hljs-keyword">virtual</span> VBase &#123; <span class="hljs-type">int</span> d1; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D2</span> : <span class="hljs-keyword">virtual</span> VBase &#123; <span class="hljs-type">int</span> d2; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MI</span> : D1, D2 &#123; <span class="hljs-type">int</span> mi; &#125;;<br></code></pre></td></tr></table></figure><ul><li>MI对象只包含一份VBase子对象，布局更复杂。</li></ul><h4 id="查看对象布局的技巧"><a href="#查看对象布局的技巧" class="headerlink" title="查看对象布局的技巧"></a>查看对象布局的技巧</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123; <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;&#125;; <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(X) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">offsetof</span>(X, a) &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="二、返回值优化（RVO）与命名返回值优化（NRVO）"><a href="#二、返回值优化（RVO）与命名返回值优化（NRVO）" class="headerlink" title="二、返回值优化（RVO）与命名返回值优化（NRVO）"></a>二、返回值优化（RVO）与命名返回值优化（NRVO）</h2><h3 id="1-RVO-NRVO-原理"><a href="#1-RVO-NRVO-原理" class="headerlink" title="1. RVO&#x2F;NRVO 原理"></a>1. RVO&#x2F;NRVO 原理</h3><ul><li>RVO：编译器直接在调用者栈上构造返回值对象，避免拷贝&#x2F;移动。</li><li>NRVO：返回具名局部变量时，编译器可消除拷贝。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123; <span class="hljs-built_in">S</span>() &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;ctor&quot;</span>); &#125; <span class="hljs-built_in">S</span>(<span class="hljs-type">const</span> S&amp;) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;copy&quot;</span>); &#125; &#125;;<br><span class="hljs-function">S <span class="hljs-title">makeS</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">S</span>(); &#125; <span class="hljs-comment">// RVO</span><br><span class="hljs-function">S <span class="hljs-title">makeS2</span><span class="hljs-params">()</span> </span>&#123; S s; <span class="hljs-keyword">return</span> s; &#125; <span class="hljs-comment">// NRVO</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; S s1 = <span class="hljs-built_in">makeS</span>(); S s2 = <span class="hljs-built_in">makeS2</span>(); &#125;<br></code></pre></td></tr></table></figure><h4 id="反汇编与编译器选项"><a href="#反汇编与编译器选项" class="headerlink" title="反汇编与编译器选项"></a>反汇编与编译器选项</h4><ul><li>g++ -O2 -fno-elide-constructors 可禁用RVO，观察拷贝次数。</li><li>默认开启RVO&#x2F;NRVO，现代编译器几乎总能优化。</li></ul><hr><h2 id="三、内联函数（inline）机制与优化建议"><a href="#三、内联函数（inline）机制与优化建议" class="headerlink" title="三、内联函数（inline）机制与优化建议"></a>三、内联函数（inline）机制与优化建议</h2><h3 id="1-inline-机制"><a href="#1-inline-机制" class="headerlink" title="1. inline 机制"></a>1. inline 机制</h3><ul><li>inline 只是建议，最终由编译器决定是否内联。</li><li>内联可减少函数调用开销，但过度内联会导致代码膨胀。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-type">int</span> x = <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); &#125;<br></code></pre></td></tr></table></figure><h3 id="2-优化建议"><a href="#2-优化建议" class="headerlink" title="2. 优化建议"></a>2. 优化建议</h3><ul><li>小型、频繁调用的函数适合内联。</li><li>不要内联大型、复杂函数。</li><li>内联模板和lambda常见。</li></ul><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">fast</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">slow</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; ++i) sum += <span class="hljs-built_in">fast</span>(i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; ++i) sum += <span class="hljs-built_in">slow</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用 -O2 -fno-inline 测试性能差异。</li></ul><hr><h2 id="四、理解-std-launder-和-std-start-lifetime-as"><a href="#四、理解-std-launder-和-std-start-lifetime-as" class="headerlink" title="四、理解 std::launder 和 std::start_lifetime_as"></a>四、理解 std::launder 和 std::start_lifetime_as</h2><h3 id="1-std-launder"><a href="#1-std-launder" class="headerlink" title="1. std::launder"></a>1. std::launder</h3><ul><li>用于指针别名、placement new 后访问新对象。</li><li>避免未定义行为，保证指针合法。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123; <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-built_in">alignas</span>(X) <span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(X)];<br>X* p = <span class="hljs-built_in">new</span> (buf) X&#123;<span class="hljs-number">42</span>&#125;;<br>X* q = std::<span class="hljs-built_in">launder</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;X*&gt;(buf));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, q-&gt;a);<br></code></pre></td></tr></table></figure><h3 id="2-std-start-lifetime-as-C-23"><a href="#2-std-start-lifetime-as-C-23" class="headerlink" title="2. std::start_lifetime_as (C++23)"></a>2. std::start_lifetime_as (C++23)</h3><ul><li>用于在原始存储上显式开始对象生命周期。</li><li>适合自定义分配器、对象池等底层场景。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-built_in">alignas</span>(<span class="hljs-type">int</span>) <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> storage[<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)];<br><span class="hljs-type">int</span>* p = std::<span class="hljs-built_in">start_lifetime_as</span>&lt;<span class="hljs-type">int</span>&gt;(storage);<br>*p = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);<br></code></pre></td></tr></table></figure><hr><h2 id="五、C-代码性能瓶颈分析工具与技巧"><a href="#五、C-代码性能瓶颈分析工具与技巧" class="headerlink" title="五、C++ 代码性能瓶颈分析工具与技巧"></a>五、C++ 代码性能瓶颈分析工具与技巧</h2><h3 id="1-perf"><a href="#1-perf" class="headerlink" title="1. perf"></a>1. perf</h3><ul><li>Linux 下的系统级性能分析工具。</li><li>用法：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -g -O2 test.cpp -o <span class="hljs-built_in">test</span><br>perf record ./test<br>perf report<br></code></pre></td></tr></table></figure><ul><li>输出热点函数、调用栈。</li></ul><h3 id="2-valgrind-callgrind"><a href="#2-valgrind-callgrind" class="headerlink" title="2. valgrind&#x2F;callgrind"></a>2. valgrind&#x2F;callgrind</h3><ul><li>适合分析函数调用次数、缓存命中率。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --tool=callgrind ./test<br>callgrind_annotate callgrind.out.*<br></code></pre></td></tr></table></figure><ul><li>可用 KCachegrind 可视化分析。</li></ul><h3 id="3-Intel-VTune"><a href="#3-Intel-VTune" class="headerlink" title="3. Intel VTune"></a>3. Intel VTune</h3><ul><li>商业级性能分析器，支持多核、矢量化、内存带宽等分析。</li><li>支持 GUI 和命令行，适合深度优化。</li></ul><h3 id="4-性能分析实战技巧"><a href="#4-性能分析实战技巧" class="headerlink" title="4. 性能分析实战技巧"></a>4. 性能分析实战技巧</h3><ul><li>先用 perf&#x2F;valgrind 找热点，再用 VTune 深挖。</li><li>关注 cache miss、分支预测失败、锁竞争等。</li><li>用 -O2&#x2F;-O3 编译，profile-guided optimization (PGO) 可进一步提升。</li><li>结合源码、汇编、工具报告定位瓶颈。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>对象模型</tag>
      
      <tag>虚函数</tag>
      
      <tag>RVO</tag>
      
      <tag>内联</tag>
      
      <tag>性能分析</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++底层系统与领域特定实践</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%BA%95%E5%B1%82%E7%B3%BB%E7%BB%9F%E4%B8%8E%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%BA%95%E5%B1%82%E7%B3%BB%E7%BB%9F%E4%B8%8E%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="C-底层、系统与领域特定实践"><a href="#C-底层、系统与领域特定实践" class="headerlink" title="C++ 底层、系统与领域特定实践"></a>C++ 底层、系统与领域特定实践</h1><hr><h2 id="一、与系统交互"><a href="#一、与系统交互" class="headerlink" title="一、与系统交互"></a>一、与系统交互</h2><h3 id="1-Linux-Windows系统编程"><a href="#1-Linux-Windows系统编程" class="headerlink" title="1. Linux&#x2F;Windows系统编程"></a>1. Linux&#x2F;Windows系统编程</h3><h4 id="POSIX-API-Linux"><a href="#POSIX-API-Linux" class="headerlink" title="POSIX API (Linux)"></a>POSIX API (Linux)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, O_CREAT | O_WRONLY, <span class="hljs-number">0644</span>); <span class="hljs-comment">// 打开/创建文件</span><br>    <span class="hljs-built_in">write</span>(fd, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 写入数据</span><br>    <span class="hljs-built_in">close</span>(fd); <span class="hljs-comment">// 关闭文件</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="WinAPI-Windows"><a href="#WinAPI-Windows" class="headerlink" title="WinAPI (Windows)"></a>WinAPI (Windows)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    HANDLE h = <span class="hljs-built_in">CreateFileA</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, GENERIC_WRITE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="hljs-literal">NULL</span>);<br>    DWORD written;<br>    <span class="hljs-built_in">WriteFile</span>(h, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">5</span>, &amp;written, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">CloseHandle</span>(h);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-文件I-O高级操作"><a href="#2-文件I-O高级操作" class="headerlink" title="2. 文件I&#x2F;O高级操作"></a>2. 文件I&#x2F;O高级操作</h3><h4 id="mmap-Linux"><a href="#mmap-Linux" class="headerlink" title="mmap (Linux)"></a>mmap (Linux)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-type">char</span>* data = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4096</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">strcpy</span>(data, <span class="hljs-string">&quot;mmap write&quot;</span>);<br>    <span class="hljs-built_in">munmap</span>(data, <span class="hljs-number">4096</span>);<br>    <span class="hljs-built_in">close</span>(fd);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="io-uring-Linux-5-1"><a href="#io-uring-Linux-5-1" class="headerlink" title="io_uring (Linux, 5.1+)"></a>io_uring (Linux, 5.1+)</h4><ul><li>需liburing库，适合高性能异步I&#x2F;O，详见liburing官方文档。</li></ul><h3 id="3-网络编程"><a href="#3-网络编程" class="headerlink" title="3. 网络编程"></a>3. 网络编程</h3><h4 id="socket-POSIX"><a href="#socket-POSIX" class="headerlink" title="socket (POSIX)"></a>socket (POSIX)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    sockaddr_in addr&#123;&#125;;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8080</span>);<br>    addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    <span class="hljs-built_in">connect</span>(sock, (sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br>    <span class="hljs-built_in">send</span>(sock, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">close</span>(sock);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Boost-Asio"><a href="#Boost-Asio" class="headerlink" title="Boost.Asio"></a>Boost.Asio</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    boost::asio::io_context io;<br>    <span class="hljs-function">tcp::socket <span class="hljs-title">s</span><span class="hljs-params">(io)</span></span>;<br>    s.<span class="hljs-built_in">connect</span>(&#123;boost::asio::ip::<span class="hljs-built_in">make_address</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>), <span class="hljs-number">8080</span>&#125;);<br>    boost::asio::<span class="hljs-built_in">write</span>(s, boost::asio::<span class="hljs-built_in">buffer</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="libuv-C风格"><a href="#libuv-C风格" class="headerlink" title="libuv (C风格)"></a>libuv (C风格)</h4><ul><li>适合高性能事件驱动网络，详见libuv官方文档。</li></ul><h3 id="4-进程间通信-IPC"><a href="#4-进程间通信-IPC" class="headerlink" title="4. 进程间通信 (IPC)"></a>4. 进程间通信 (IPC)</h3><h4 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">pipe</span>(fd);<br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">10</span>];<br>        <span class="hljs-built_in">read</span>(fd[<span class="hljs-number">0</span>], buf, <span class="hljs-number">10</span>);<br>        std::cout &lt;&lt; buf &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">close</span>(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">write</span>(fd[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="shared-memory"><a href="#shared-memory" class="headerlink" title="shared memory"></a>shared memory</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> shmid = <span class="hljs-built_in">shmget</span>(IPC_PRIVATE, <span class="hljs-number">1024</span>, IPC_CREAT|<span class="hljs-number">0666</span>);<br>    <span class="hljs-type">char</span>* shm = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">shmat</span>(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">strcpy</span>(shm, <span class="hljs-string">&quot;shared mem&quot;</span>);<br>    <span class="hljs-built_in">shmdt</span>(shm);<br>    <span class="hljs-built_in">shmctl</span>(shmid, IPC_RMID, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="message-queue"><a href="#message-queue" class="headerlink" title="message queue"></a>message queue</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msgbuf</span> &#123; <span class="hljs-type">long</span> mtype; <span class="hljs-type">char</span> mtext[<span class="hljs-number">100</span>]; &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> msqid = <span class="hljs-built_in">msgget</span>(IPC_PRIVATE, IPC_CREAT|<span class="hljs-number">0666</span>);<br>    msgbuf msg = &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;hello&quot;</span>&#125;;<br>    <span class="hljs-built_in">msgsnd</span>(msqid, &amp;msg, <span class="hljs-built_in">strlen</span>(msg.mtext)<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">msgrcv</span>(msqid, &amp;msg, <span class="hljs-built_in">sizeof</span>(msg.mtext), <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="二、嵌入式与实时系统"><a href="#二、嵌入式与实时系统" class="headerlink" title="二、嵌入式与实时系统"></a>二、嵌入式与实时系统</h2><h3 id="1-资源受限环境C-技巧"><a href="#1-资源受限环境C-技巧" class="headerlink" title="1. 资源受限环境C++技巧"></a>1. 资源受限环境C++技巧</h3><ul><li>禁用RTTI: <code>-fno-rtti</code>，禁用异常: <code>-fno-exceptions</code>。</li><li>用自定义分配器、对象池，避免动态分配。</li></ul><h3 id="2-实时性保障与C-特性选择"><a href="#2-实时性保障与C-特性选择" class="headerlink" title="2. 实时性保障与C++特性选择"></a>2. 实时性保障与C++特性选择</h3><ul><li>避免不确定性操作（如new、虚函数、异常）。</li><li>用constexpr、模板元编程提升编译期计算。</li></ul><h3 id="3-与硬件寄存器交互"><a href="#3-与硬件寄存器交互" class="headerlink" title="3. 与硬件寄存器交互"></a>3. 与硬件寄存器交互</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span>* reg = (<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span>*)<span class="hljs-number">0x40000000</span>;<br>*reg = <span class="hljs-number">0x1234</span>; <span class="hljs-comment">// 写寄存器</span><br><span class="hljs-type">uint32_t</span> val = *reg; <span class="hljs-comment">// 读寄存器</span><br></code></pre></td></tr></table></figure><ul><li>内存映射I&#x2F;O常用于驱动开发。</li></ul><hr><h2 id="三、游戏开发"><a href="#三、游戏开发" class="headerlink" title="三、游戏开发"></a>三、游戏开发</h2><h3 id="1-游戏引擎架构中的C-应用"><a href="#1-游戏引擎架构中的C-应用" class="headerlink" title="1. 游戏引擎架构中的C++应用"></a>1. 游戏引擎架构中的C++应用</h3><h4 id="ECS模式（实体-组件-系统）"><a href="#ECS模式（实体-组件-系统）" class="headerlink" title="ECS模式（实体-组件-系统）"></a>ECS模式（实体-组件-系统）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Position</span> &#123; <span class="hljs-type">float</span> x, y; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Velocity</span> &#123; <span class="hljs-type">float</span> vx, vy; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Entity</span> &#123; <span class="hljs-type">int</span> id; &#125;;<br>std::vector&lt;Entity&gt; entities;<br>std::unordered_map&lt;<span class="hljs-type">int</span>, Position&gt; positions;<br>std::unordered_map&lt;<span class="hljs-type">int</span>, Velocity&gt; velocities;<br><span class="hljs-comment">// 系统遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : entities) &#123;<br>    positions[e.id].x += velocities[e.id].vx;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-资源管理与脚本绑定"><a href="#2-资源管理与脚本绑定" class="headerlink" title="2. 资源管理与脚本绑定"></a>2. 资源管理与脚本绑定</h3><ul><li>用智能指针、资源池管理纹理&#x2F;模型。</li><li>脚本绑定：pybind11&#x2F;Lua&#x2F;C#等。</li></ul><h3 id="3-游戏物理、图形、AI算法实现"><a href="#3-游戏物理、图形、AI算法实现" class="headerlink" title="3. 游戏物理、图形、AI算法实现"></a>3. 游戏物理、图形、AI算法实现</h3><ul><li>物理：刚体动力学、碰撞检测（AABB、BVH）。</li><li>图形：OpenGL&#x2F;Vulkan渲染管线。</li><li>AI：A*寻路、行为树。</li></ul><h3 id="4-实时渲染优化技巧"><a href="#4-实时渲染优化技巧" class="headerlink" title="4. 实时渲染优化技巧"></a>4. 实时渲染优化技巧</h3><ul><li>批量绘制、GPU实例化、延迟渲染。</li></ul><hr><h2 id="四、金融与高频交易"><a href="#四、金融与高频交易" class="headerlink" title="四、金融与高频交易"></a>四、金融与高频交易</h2><h3 id="1-极致低延迟编程"><a href="#1-极致低延迟编程" class="headerlink" title="1. 极致低延迟编程"></a>1. 极致低延迟编程</h3><ul><li>cache line对齐：<code>alignas(64) struct Data &#123; ... &#125;</code>。</li><li>避免分支、用无锁结构（如环形缓冲区）。</li></ul><h4 id="案例：无锁环形缓冲区"><a href="#案例：无锁环形缓冲区" class="headerlink" title="案例：无锁环形缓冲区"></a>案例：无锁环形缓冲区</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RingBuffer</span> &#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; buf;<br>    std::atomic&lt;<span class="hljs-type">size_t</span>&gt; head&#123;<span class="hljs-number">0</span>&#125;, tail&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">size_t</span> size;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RingBuffer</span>(<span class="hljs-type">size_t</span> n) : <span class="hljs-built_in">buf</span>(n), <span class="hljs-built_in">size</span>(n) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-type">size_t</span> h = head.<span class="hljs-built_in">load</span>(), t = tail.<span class="hljs-built_in">load</span>();<br>        <span class="hljs-keyword">if</span> ((h<span class="hljs-number">+1</span>)%size == t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        buf[h] = v; head.<span class="hljs-built_in">store</span>((h<span class="hljs-number">+1</span>)%size); <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; v)</span> </span>&#123;<br>        <span class="hljs-type">size_t</span> h = head.<span class="hljs-built_in">load</span>(), t = tail.<span class="hljs-built_in">load</span>();<br>        <span class="hljs-keyword">if</span> (t == h) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        v = buf[t]; tail.<span class="hljs-built_in">store</span>((t<span class="hljs-number">+1</span>)%size); <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-内存访问模式优化"><a href="#2-内存访问模式优化" class="headerlink" title="2. 内存访问模式优化"></a>2. 内存访问模式优化</h3><ul><li>顺序访问、预取、避免false sharing。</li></ul><hr><h2 id="五、与其他语言交互"><a href="#五、与其他语言交互" class="headerlink" title="五、与其他语言交互"></a>五、与其他语言交互</h2><h3 id="1-C接口（extern-“C”）"><a href="#1-C接口（extern-“C”）" class="headerlink" title="1. C接口（extern “C”）"></a>1. C接口（extern “C”）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br></code></pre></td></tr></table></figure><h3 id="2-Python绑定（pybind11）"><a href="#2-Python绑定（pybind11）" class="headerlink" title="2. Python绑定（pybind11）"></a>2. Python绑定（pybind11）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pybind11/pybind11.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-built_in">PYBIND11_MODULE</span>(mymod, m) &#123;<br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;add&quot;</span>, &amp;add);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Rust-FFI"><a href="#3-Rust-FFI" class="headerlink" title="3. Rust FFI"></a>3. Rust FFI</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">// Rust</span><br><span class="hljs-comment">// #[link(name = &quot;mylib&quot;)]</span><br><span class="hljs-comment">// extern &quot;C&quot; &#123; fn add(a: i32, b: i32) -&gt; i32; &#125;</span><br></code></pre></td></tr></table></figure><hr><p>如需某一部分更深入源码分析或实战案例，请随时告知！ </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>游戏开发</tag>
      
      <tag>系统编程</tag>
      
      <tag>嵌入式</tag>
      
      <tag>实时系统</tag>
      
      <tag>高频交易</tag>
      
      <tag>FFI</tag>
      
      <tag>Python绑定</tag>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++并行算法与加速实践</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%A0%E9%80%9F%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/C++%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E4%B8%8E%E5%8A%A0%E9%80%9F%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="C-并行算法与加速实践"><a href="#C-并行算法与加速实践" class="headerlink" title="C++ 并行算法与加速实践"></a>C++ 并行算法与加速实践</h1><hr><h2 id="一、STL算法的并行执行策略"><a href="#一、STL算法的并行执行策略" class="headerlink" title="一、STL算法的并行执行策略"></a>一、STL算法的并行执行策略</h2><h3 id="1-std-execution-策略概览"><a href="#1-std-execution-策略概览" class="headerlink" title="1. std::execution 策略概览"></a>1. std::execution 策略概览</h3><ul><li><code>std::execution::seq</code>：串行执行（默认）。</li><li><code>std::execution::par</code>：多线程并行。</li><li><code>std::execution::par_unseq</code>：多线程+SIMD并行。</li><li><code>std::execution::unseq</code>：单线程SIMD并行。</li></ul><h3 id="2-原理与源码结构"><a href="#2-原理与源码结构" class="headerlink" title="2. 原理与源码结构"></a>2. 原理与源码结构</h3><ul><li>并行策略由标准库实现，底层用线程池、分块、SIMD指令。</li><li>典型实现：libc++&#x2F;libstdc++调用TBB、PPL或自带线程池。</li></ul><h3 id="3-典型用法与性能对比"><a href="#3-典型用法与性能对比" class="headerlink" title="3. 典型用法与性能对比"></a>3. 典型用法与性能对比</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">1&#x27;000&#x27;000</span>)</span></span>;<br>    std::<span class="hljs-built_in">iota</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> t1 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    std::<span class="hljs-built_in">sort</span>(std::execution::par, v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">auto</span> t2 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    std::<span class="hljs-built_in">sort</span>(std::execution::seq, v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">auto</span> t3 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;par: &quot;</span> &lt;&lt; (t2-t1).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;, seq: &quot;</span> &lt;&lt; (t3-t2).<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>并行算法适合大数据量、无数据依赖的场景。</li><li>小数据量或有副作用的操作不建议并行。</li></ul><hr><h2 id="二、OpenMP在C-中的并行化"><a href="#二、OpenMP在C-中的并行化" class="headerlink" title="二、OpenMP在C++中的并行化"></a>二、OpenMP在C++中的并行化</h2><h3 id="1-OpenMP基础用法"><a href="#1-OpenMP基础用法" class="headerlink" title="1. OpenMP基础用法"></a>1. OpenMP基础用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;omp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">1000000</span>, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> omp parallel for reduction(+:sum)</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        sum += v[i];<br>    &#125;<br>    std::cout &lt;&lt; sum &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译时加 <code>-fopenmp</code>（GCC&#x2F;Clang）。</li><li>OpenMP适合循环并行，易用但不如STL并行算法灵活。</li></ul><h3 id="2-常见陷阱与对比"><a href="#2-常见陷阱与对比" class="headerlink" title="2. 常见陷阱与对比"></a>2. 常见陷阱与对比</h3><ul><li>变量作用域（private&#x2F;shared）、数据竞争、false sharing。</li><li>OpenMP适合for循环，STL并行适合算法链式组合。</li></ul><hr><h2 id="三、利用C-17并行STL加速你的数据处理"><a href="#三、利用C-17并行STL加速你的数据处理" class="headerlink" title="三、利用C++17并行STL加速你的数据处理"></a>三、利用C++17并行STL加速你的数据处理</h2><h3 id="1-实战案例：并行排序与统计"><a href="#1-实战案例：并行排序与统计" class="headerlink" title="1. 实战案例：并行排序与统计"></a>1. 实战案例：并行排序与统计</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">10&#x27;000&#x27;000</span>)</span></span>;<br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">rng</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;<br>    std::<span class="hljs-built_in">generate</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [&amp;]&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">rng</span>()%<span class="hljs-number">1000000</span>; &#125;);<br>    <span class="hljs-keyword">auto</span> t1 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    std::<span class="hljs-built_in">sort</span>(std::execution::par, v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">auto</span> t2 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = std::<span class="hljs-built_in">reduce</span>(std::execution::par, v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0LL</span>);<br>    <span class="hljs-keyword">auto</span> t3 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sort: &quot;</span> &lt;&lt; (t2-t1).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;, reduce: &quot;</span> &lt;&lt; (t3-t2).<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-性能benchmark与工程建议"><a href="#2-性能benchmark与工程建议" class="headerlink" title="2. 性能benchmark与工程建议"></a>2. 性能benchmark与工程建议</h3><ul><li>并行STL算法在多核CPU上可获得2-10倍加速。</li><li>避免在小数据量、频繁分配、数据依赖强的场景下滥用并行。</li><li>可与OpenMP、TBB等混合使用，需注意线程数和资源竞争。</li></ul><hr><p>如需某一部分更深入源码分析或实战案例，请随时告知！ </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>性能优化</tag>
      
      <tag>并行算法</tag>
      
      <tag>STL</tag>
      
      <tag>OpenMP</tag>
      
      <tag>数据处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01_%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01_%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数组详解与C-实现"><a href="#数组详解与C-实现" class="headerlink" title="数组详解与C++实现"></a>数组详解与C++实现</h1><h2 id="1-数组概念（详细）"><a href="#1-数组概念（详细）" class="headerlink" title="1. 数组概念（详细）"></a>1. 数组概念（详细）</h2><p>数组（Array）是一种<strong>顺序存储</strong>的数据结构，用一段<strong>连续内存</strong>存储相同类型的数据元素。每个元素通过<strong>下标（索引）</strong>访问，支持高效的随机访问。</p><ul><li><strong>顺序存储</strong>：所有元素在内存中连续排列，便于通过下标直接定位。</li><li><strong>下标访问</strong>：第i个元素地址 &#x3D; 起始地址 + i × 元素大小，访问时间O(1)。</li><li><strong>内存布局</strong>：数组在声明时分配一整块内存，大小固定。</li><li><strong>优点</strong>：<ul><li>支持O(1)随机访问。</li><li>内存局部性好，适合批量操作。</li></ul></li><li><strong>缺点</strong>：<ul><li>插入&#x2F;删除元素需整体移动，效率低。</li><li>大小固定，扩容需重新分配内存。</li><li>不适合频繁变长的场景。</li></ul></li></ul><h2 id="2-C-实现与常用操作"><a href="#2-C-实现与常用操作" class="headerlink" title="2. C++实现与常用操作"></a>2. C++实现与常用操作</h2><h3 id="2-1-静态数组"><a href="#2-1-静态数组" class="headerlink" title="2.1 静态数组"></a>2.1 静态数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// 访问</span><br><span class="hljs-type">int</span> x = arr[<span class="hljs-number">2</span>]; <span class="hljs-comment">// x = 3</span><br><span class="hljs-comment">// 修改</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) std::cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-动态数组（vector）"><a href="#2-2-动态数组（vector）" class="headerlink" title="2.2 动态数组（vector）"></a>2.2 动态数组（vector）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-comment">// 增加</span><br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 删除</span><br>vec.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-comment">// 访问</span><br><span class="hljs-type">int</span> y = vec[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 修改</span><br>vec[<span class="hljs-number">2</span>] = <span class="hljs-number">100</span>;<br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : vec) std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-3-常用操作封装"><a href="#2-3-常用操作封装" class="headerlink" title="2.3 常用操作封装"></a>2.3 常用操作封装</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyArray</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">data</span>(n) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data[idx]; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123; data[idx] = val; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        data.<span class="hljs-built_in">insert</span>(data.<span class="hljs-built_in">begin</span>() + idx, val);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>&#123;<br>        data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">begin</span>() + idx);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">size</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>访问：O(1)</li><li>插入&#x2F;删除：O(n)</li><li>遍历：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>需要高效随机访问的场景，如查表、缓存、批量数据处理。</li><li>适合存储元素数量固定或变化不频繁的数据。</li><li>常用于实现其他数据结构（如栈、队列、哈希表底层）。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>越界访问</strong>：数组下标从0到n-1，越界会导致未定义行为。</li><li><strong>内存分配失败</strong>：大数组需注意栈&#x2F;堆空间限制。</li><li><strong>浅拷贝与深拷贝</strong>：C++数组赋值为浅拷贝，vector支持深拷贝。</li><li><strong>二维&#x2F;多维数组</strong>：行优先存储，访问顺序影响缓存命中率。</li><li><strong>初始化问题</strong>：未初始化的数组元素值不确定。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：前缀和快速区间求和"><a href="#案例1：前缀和快速区间求和" class="headerlink" title="案例1：前缀和快速区间求和"></a>案例1：前缀和快速区间求和</h3><p><strong>题意</strong>：给定一个长度为n的数组，多次查询区间[l, r]的元素和。</p><p><strong>思路</strong>：预处理前缀和数组，区间和为sum[r] - sum[l-1]。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefixSum</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) sum[i + <span class="hljs-number">1</span>] = sum[i] + arr[i];<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-comment">// 查询区间[l, r]的和（1-based）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; sum, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> sum[r] - sum[l - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：预处理O(n)，单次查询O(1)。</p><p><strong>应用说明</strong>：适用于频繁区间求和，如子数组和、统计等。</p><hr><h3 id="案例2：滑动窗口最大值"><a href="#案例2：滑动窗口最大值" class="headerlink" title="案例2：滑动窗口最大值"></a>案例2：滑动窗口最大值</h3><p><strong>题意</strong>：给定长度为n的数组和窗口大小k，输出每个长度为k的子数组的最大值。</p><p><strong>思路</strong>：用双端队列维护窗口内最大值的下标。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">front</span>() &lt;= i - k) dq.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[dq.<span class="hljs-built_in">back</span>()] &lt;= nums[i]) dq.<span class="hljs-built_in">pop_back</span>();<br>        dq.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) res.<span class="hljs-built_in">push_back</span>(nums[dq.<span class="hljs-built_in">front</span>()]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于信号处理、数据流分析、最大&#x2F;最小区间值等。</p><hr><h3 id="案例3：二维数组——图像旋转"><a href="#案例3：二维数组——图像旋转" class="headerlink" title="案例3：二维数组——图像旋转"></a>案例3：二维数组——图像旋转</h3><p><strong>题意</strong>：给定n×n二维数组，顺时针旋转90度。</p><p><strong>思路</strong>：先转置再左右翻转，或直接按层旋转。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 转置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j)<br>            std::<span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>    <span class="hljs-comment">// 左右翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n / <span class="hljs-number">2</span>; ++j)<br>            std::<span class="hljs-built_in">swap</span>(matrix[i][j], matrix[i][n - <span class="hljs-number">1</span> - j]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n^2)</p><p><strong>应用说明</strong>：常用于图像处理、棋盘变换、矩阵算法等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02_%E9%93%BE%E8%A1%A8%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02_%E9%93%BE%E8%A1%A8%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="链表详解与C-实现"><a href="#链表详解与C-实现" class="headerlink" title="链表详解与C++实现"></a>链表详解与C++实现</h1><h2 id="1-链表概念（详细）"><a href="#1-链表概念（详细）" class="headerlink" title="1. 链表概念（详细）"></a>1. 链表概念（详细）</h2><p>链表（Linked List）是一种<strong>链式存储</strong>的数据结构，由一组节点（Node）通过指针连接而成。每个节点包含数据域和指针域。</p><ul><li><strong>单链表</strong>：每个节点只包含指向下一个节点的指针。</li><li><strong>双向链表</strong>：每个节点包含指向前驱和后继的指针，支持双向遍历。</li><li><strong>循环链表</strong>：最后一个节点指向头节点，形成环状结构。</li><li><strong>节点结构</strong>：<ul><li>数据域：存储实际数据。</li><li>指针域：存储下一个（和&#x2F;或上一个）节点的地址。</li></ul></li><li><strong>优点</strong>：<ul><li>插入&#x2F;删除操作无需整体移动元素，O(1)（已知位置）。</li><li>动态分配内存，大小灵活。</li></ul></li><li><strong>缺点</strong>：<ul><li>访问元素需从头遍历，随机访问效率低O(n)。</li><li>额外指针域占用空间。</li><li>不利于CPU缓存。</li></ul></li></ul><h2 id="2-C-实现与常用操作"><a href="#2-C-实现与常用操作" class="headerlink" title="2. C++实现与常用操作"></a>2. C++实现与常用操作</h2><h3 id="2-1-单链表节点与基本操作"><a href="#2-1-单链表节点与基本操作" class="headerlink" title="2.1 单链表节点与基本操作"></a>2.1 单链表节点与基本操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-comment">// 插入头部</span><br><span class="hljs-function">ListNode* <span class="hljs-title">insertHead</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>    node-&gt;next = head;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-comment">// 删除指定值节点</span><br><span class="hljs-function">ListNode* <span class="hljs-title">deleteVal</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>; dummy.next = head;<br>    ListNode* p = &amp;dummy;<br>    <span class="hljs-keyword">while</span> (p-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;next-&gt;val == val) &#123;<br>            ListNode* tmp = p-&gt;next;<br>            p-&gt;next = tmp-&gt;next;<br>            <span class="hljs-keyword">delete</span> tmp;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><span class="hljs-comment">// 查找</span><br><span class="hljs-function">ListNode* <span class="hljs-title">find</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (head) &#123;<br>        <span class="hljs-keyword">if</span> (head-&gt;val == val) <span class="hljs-keyword">return</span> head;<br>        head = head-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><span class="hljs-comment">// 反转链表</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (head) &#123;<br>        ListNode* next = head-&gt;next;<br>        head-&gt;next = prev;<br>        prev = head;<br>        head = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-双向链表节点"><a href="#2-2-双向链表节点" class="headerlink" title="2.2 双向链表节点"></a>2.2 双向链表节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    DListNode* prev;<br>    DListNode* next;<br>    <span class="hljs-built_in">DListNode</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-3-STL链表"><a href="#2-3-STL链表" class="headerlink" title="2.3 STL链表"></a>2.3 STL链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br>std::list&lt;<span class="hljs-type">int</span>&gt; l;<br>l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>l.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">2</span>);<br>l.<span class="hljs-built_in">pop_back</span>();<br>l.<span class="hljs-built_in">pop_front</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : l) std::cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>插入&#x2F;删除（已知节点）：O(1)</li><li>查找&#x2F;访问：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>频繁插入&#x2F;删除的场景，如LRU缓存、队列、哈希表拉链法。</li><li>需要动态扩容、元素数量不确定的数据。</li><li>实现栈、队列、图的邻接表等。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>头指针处理</strong>：插入&#x2F;删除头节点时需特殊处理，常用虚拟头节点(dummy head)。</li><li><strong>内存泄漏</strong>：删除节点后需手动释放内存，防止泄漏。</li><li><strong>指针悬挂</strong>：节点被删除后，其他指针仍指向已释放内存。</li><li><strong>环形链表</strong>：不慎形成环会导致死循环，需检测环。</li><li><strong>多链表操作</strong>：合并、交叉、分割等需注意指针操作顺序。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：链表反转"><a href="#案例1：链表反转" class="headerlink" title="案例1：链表反转"></a>案例1：链表反转</h3><p><strong>题意</strong>：给定单链表头指针，反转链表并返回新头。</p><p><strong>思路</strong>：用三个指针依次反转next指向。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">while</span> (head) &#123;<br>        ListNode* next = head-&gt;next;<br>        head-&gt;next = prev;<br>        prev = head;<br>        head = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于链表倒序、栈模拟、递归反转等。</p><hr><h3 id="案例2：LRU缓存（双向链表-哈希表）"><a href="#案例2：LRU缓存（双向链表-哈希表）" class="headerlink" title="案例2：LRU缓存（双向链表+哈希表）"></a>案例2：LRU缓存（双向链表+哈希表）</h3><p><strong>题意</strong>：实现LRU缓存，支持O(1)插入、删除、访问。</p><p><strong>思路</strong>：用双向链表维护访问顺序，哈希表定位节点。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DListNode</span> &#123;<br>    <span class="hljs-type">int</span> key, val;<br>    DListNode *prev, *next;<br>    <span class="hljs-built_in">DListNode</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v) : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br>    <span class="hljs-type">int</span> cap;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, DListNode*&gt; mp;<br>    DListNode *head, *tail;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DListNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == head) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// remove</span><br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        <span class="hljs-keyword">if</span> (node-&gt;next) node-&gt;next-&gt;prev = node-&gt;prev;<br>        <span class="hljs-keyword">else</span> tail = node-&gt;prev;<br>        <span class="hljs-comment">// insert to head</span><br>        node-&gt;next = head;<br>        node-&gt;prev = <span class="hljs-literal">nullptr</span>;<br>        head-&gt;prev = node;<br>        head = node;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">cap</span>(capacity), <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">tail</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!mp.<span class="hljs-built_in">count</span>(key)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">moveToHead</span>(mp[key]);<br>        <span class="hljs-keyword">return</span> mp[key]-&gt;val;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(key)) &#123;<br>            mp[key]-&gt;val = value;<br>            <span class="hljs-built_in">moveToHead</span>(mp[key]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            DListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DListNode</span>(key, value);<br>            node-&gt;next = head;<br>            <span class="hljs-keyword">if</span> (head) head-&gt;prev = node;<br>            head = node;<br>            <span class="hljs-keyword">if</span> (!tail) tail = node;<br>            mp[key] = node;<br>            <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">size</span>() &gt; cap) &#123;<br>                mp.<span class="hljs-built_in">erase</span>(tail-&gt;key);<br>                DListNode* pre = tail-&gt;prev;<br>                <span class="hljs-keyword">if</span> (pre) pre-&gt;next = <span class="hljs-literal">nullptr</span>;<br>                <span class="hljs-keyword">delete</span> tail;<br>                tail = pre;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(1)</p><p><strong>应用说明</strong>：常用于缓存淘汰、内存管理、最近最少使用策略。</p><hr><h3 id="案例3：环形链表检测（快慢指针）"><a href="#案例3：环形链表检测（快慢指针）" class="headerlink" title="案例3：环形链表检测（快慢指针）"></a>案例3：环形链表检测（快慢指针）</h3><p><strong>题意</strong>：判断链表是否有环。</p><p><strong>思路</strong>：快慢指针，快指针每次走两步，慢指针走一步，若相遇则有环。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode *slow = head, *fast = head;<br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于链表环检测、死锁检测、循环依赖等。</p><hr><h3 id="案例4：合并两个有序链表"><a href="#案例4：合并两个有序链表" class="headerlink" title="案例4：合并两个有序链表"></a>案例4：合并两个有序链表</h3><p><strong>题意</strong>：合并两个升序链表为一个新链表。</p><p><strong>思路</strong>：双指针逐步比较，依次连接。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>    <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, *cur </span>= &amp;dummy;<br>    <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;<br>        <span class="hljs-keyword">else</span> &#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    cur-&gt;next = l1 ? l1 : l2;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n+m)</p><p><strong>应用说明</strong>：常用于归并排序、合并区间、数据流合并等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03_%E6%A0%88%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03_%E6%A0%88%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="栈详解与C-实现"><a href="#栈详解与C-实现" class="headerlink" title="栈详解与C++实现"></a>栈详解与C++实现</h1><h2 id="1-栈概念（详细）"><a href="#1-栈概念（详细）" class="headerlink" title="1. 栈概念（详细）"></a>1. 栈概念（详细）</h2><p>栈（Stack）是一种<strong>后进先出（LIFO）</strong>的数据结构，只允许在一端进行插入和删除操作。</p><ul><li><strong>后进先出</strong>：最后入栈的元素最先出栈。</li><li><strong>顺序实现</strong>：用数组&#x2F;向量实现，栈顶指针指向当前元素。</li><li><strong>链式实现</strong>：用链表实现，头部为栈顶。</li><li><strong>常见操作</strong>：push（入栈）、pop（出栈）、top（取栈顶）、empty（判空）、size（元素个数）。</li><li><strong>优点</strong>：<ul><li>操作简单，O(1)时间复杂度。</li><li>适合递归、回溯、表达式求值等场景。</li></ul></li><li><strong>缺点</strong>：<ul><li>只能访问栈顶元素，无法随机访问。</li><li>顺序栈容量固定，需扩容。</li></ul></li></ul><h2 id="2-C-实现与常用操作"><a href="#2-C-实现与常用操作" class="headerlink" title="2. C++实现与常用操作"></a>2. C++实现与常用操作</h2><h3 id="2-1-顺序栈（数组-向量）"><a href="#2-1-顺序栈（数组-向量）" class="headerlink" title="2.1 顺序栈（数组&#x2F;向量）"></a>2.1 顺序栈（数组&#x2F;向量）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; data.<span class="hljs-built_in">push_back</span>(x); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123; data.<span class="hljs-built_in">pop_back</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">back</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">empty</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">size</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-链式栈"><a href="#2-2-链式栈" class="headerlink" title="2.2 链式栈"></a>2.2 链式栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    Node* next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LinkedStack</span>() : <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(x);<br>        node-&gt;next = head;<br>        head = node;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head) &#123;<br>            Node* tmp = head;<br>            head = head-&gt;next;<br>            <span class="hljs-keyword">delete</span> tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> head-&gt;val; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> head == <span class="hljs-literal">nullptr</span>; &#125;<br><span class="hljs-keyword">private</span>:<br>    Node* head;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-3-STL栈"><a href="#2-3-STL栈" class="headerlink" title="2.3 STL栈"></a>2.3 STL栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br>std::stack&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>s.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> t = s.<span class="hljs-built_in">top</span>();<br><span class="hljs-type">bool</span> e = s.<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>入栈&#x2F;出栈&#x2F;取栈顶：O(1)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>表达式求值、括号匹配、递归、回溯、浏览器前进后退、函数调用栈等。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>栈溢出</strong>：顺序栈空间有限，递归过深或数据过大易溢出。</li><li><strong>空栈操作</strong>：pop&#x2F;top前需判空，避免访问非法内存。</li><li><strong>数据类型一致性</strong>：表达式求值等需注意栈内数据类型。</li><li><strong>多栈协作</strong>：如双栈实现队列、最小栈等需注意同步。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：括号匹配"><a href="#案例1：括号匹配" class="headerlink" title="案例1：括号匹配"></a>案例1：括号匹配</h3><p><strong>题意</strong>：判断字符串中的括号是否成对匹配。</p><p><strong>思路</strong>：遇到左括号入栈，遇到右括号判断栈顶是否匹配。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) stk.<span class="hljs-built_in">push</span>(c);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">char</span> t = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> ((c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; t != <span class="hljs-string">&#x27;(&#x27;</span>) || (c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; t != <span class="hljs-string">&#x27;[&#x27;</span>) || (c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; t != <span class="hljs-string">&#x27;&#123;&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于编译器、表达式解析、代码检查等。</p><hr><h3 id="案例2：最小栈"><a href="#案例2：最小栈" class="headerlink" title="案例2：最小栈"></a>案例2：最小栈</h3><p><strong>题意</strong>：实现一个支持O(1)获取最小值的栈。</p><p><strong>思路</strong>：用辅助栈同步维护当前最小值。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; stk, minstk;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stk.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">if</span> (minstk.<span class="hljs-built_in">empty</span>() || x &lt;= minstk.<span class="hljs-built_in">top</span>()) minstk.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">top</span>() == minstk.<span class="hljs-built_in">top</span>()) minstk.<span class="hljs-built_in">pop</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> minstk.<span class="hljs-built_in">top</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(1)</p><p><strong>应用说明</strong>：常用于区间最小值、单调栈优化、滑动窗口等。</p><hr><h3 id="案例3：逆波兰表达式求值"><a href="#案例3：逆波兰表达式求值" class="headerlink" title="案例3：逆波兰表达式求值"></a>案例3：逆波兰表达式求值</h3><p><strong>题意</strong>：给定逆波兰表达式（后缀表达式），计算其值。</p><p><strong>思路</strong>：遇到数字入栈，遇到运算符弹出两个数计算后入栈。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::string&gt;&amp; tokens)</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; t : tokens) &#123;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-string">&quot;+&quot;</span> || t == <span class="hljs-string">&quot;-&quot;</span> || t == <span class="hljs-string">&quot;*&quot;</span> || t == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>            <span class="hljs-type">int</span> b = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> a = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-string">&quot;+&quot;</span>) stk.<span class="hljs-built_in">push</span>(a + b);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t == <span class="hljs-string">&quot;-&quot;</span>) stk.<span class="hljs-built_in">push</span>(a - b);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t == <span class="hljs-string">&quot;*&quot;</span>) stk.<span class="hljs-built_in">push</span>(a * b);<br>            <span class="hljs-keyword">else</span> stk.<span class="hljs-built_in">push</span>(a / b);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stk.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">stoi</span>(t));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于表达式求值、编译器、计算器实现等。</p><hr><h3 id="案例4：直方图最大矩形面积"><a href="#案例4：直方图最大矩形面积" class="headerlink" title="案例4：直方图最大矩形面积"></a>案例4：直方图最大矩形面积</h3><p><strong>题意</strong>：给定直方图高度数组，求最大矩形面积。</p><p><strong>思路</strong>：用单调栈维护递增高度，遇到矮柱时计算面积。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    <span class="hljs-type">int</span> maxA = <span class="hljs-number">0</span>, n = heights.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-type">int</span> h = (i == n ? <span class="hljs-number">0</span> : heights[i]);<br>        <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; h &lt; heights[stk.<span class="hljs-built_in">top</span>()]) &#123;<br>            <span class="hljs-type">int</span> height = heights[stk.<span class="hljs-built_in">top</span>()]; stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> left = stk.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : stk.<span class="hljs-built_in">top</span>();<br>            maxA = std::<span class="hljs-built_in">max</span>(maxA, height * (i - left - <span class="hljs-number">1</span>));<br>        &#125;<br>        stk.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxA;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于区间最大值、滑动窗口、矩阵最大子矩形等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04_%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04_%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="队列详解与C-实现"><a href="#队列详解与C-实现" class="headerlink" title="队列详解与C++实现"></a>队列详解与C++实现</h1><h2 id="1-队列概念（详细）"><a href="#1-队列概念（详细）" class="headerlink" title="1. 队列概念（详细）"></a>1. 队列概念（详细）</h2><p>队列（Queue）是一种<strong>先进先出（FIFO）</strong>的数据结构，只允许在一端插入、另一端删除。</p><ul><li><strong>先进先出</strong>：最先入队的元素最先出队。</li><li><strong>顺序实现</strong>：用数组&#x2F;向量实现，维护头尾指针。</li><li><strong>链式实现</strong>：用链表实现，头部出队，尾部入队。</li><li><strong>循环队列</strong>：数组实现，头尾指针循环利用，避免假溢出。</li><li><strong>常见操作</strong>：push（入队）、pop（出队）、front（取队头）、back（取队尾）、empty（判空）、size（元素个数）。</li><li><strong>优点</strong>：<ul><li>操作简单，O(1)时间复杂度。</li><li>适合排队、缓冲、异步处理等场景。</li></ul></li><li><strong>缺点</strong>：<ul><li>只能访问队头&#x2F;队尾，无法随机访问。</li><li>顺序队列容量固定，需扩容或用循环队列。</li></ul></li></ul><h2 id="2-C-实现与常用操作"><a href="#2-C-实现与常用操作" class="headerlink" title="2. C++实现与常用操作"></a>2. C++实现与常用操作</h2><h3 id="2-1-顺序队列"><a href="#2-1-顺序队列" class="headerlink" title="2.1 顺序队列"></a>2.1 顺序队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; data.<span class="hljs-built_in">push_back</span>(x); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123; data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">begin</span>()); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">front</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">back</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">empty</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">size</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-链式队列"><a href="#2-2-链式队列" class="headerlink" title="2.2 链式队列"></a>2.2 链式队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">QNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    QNode* next;<br>    <span class="hljs-built_in">QNode</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LinkedQueue</span>() : <span class="hljs-built_in">head</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">tail</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        QNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QNode</span>(x);<br>        <span class="hljs-keyword">if</span> (!tail) head = tail = node;<br>        <span class="hljs-keyword">else</span> &#123;<br>            tail-&gt;next = node;<br>            tail = node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head) &#123;<br>            QNode* tmp = head;<br>            head = head-&gt;next;<br>            <span class="hljs-keyword">if</span> (!head) tail = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">delete</span> tmp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> head-&gt;val; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> tail-&gt;val; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> head == <span class="hljs-literal">nullptr</span>; &#125;<br><span class="hljs-keyword">private</span>:<br>    QNode* head;<br>    QNode* tail;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-3-STL队列"><a href="#2-3-STL队列" class="headerlink" title="2.3 STL队列"></a>2.3 STL队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-type">int</span> f = q.<span class="hljs-built_in">front</span>();<br><span class="hljs-type">int</span> b = q.<span class="hljs-built_in">back</span>();<br><span class="hljs-type">bool</span> e = q.<span class="hljs-built_in">empty</span>();<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>入队&#x2F;出队&#x2F;取队头&#x2F;队尾：O(1)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>排队、缓冲区、广度优先搜索、异步消息、生产者-消费者模型等。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>假溢出</strong>：顺序队列不循环时，头尾指针到末尾后即使有空位也无法入队。</li><li><strong>循环队列判满&#x2F;判空</strong>：需区分队满和队空，常用“浪费一个空间”法。</li><li><strong>链式队列尾指针维护</strong>：出队后若队空需同步置空尾指针。</li><li><strong>多队列协作</strong>：如双端队列、优先队列等需注意操作一致性。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：循环队列实现"><a href="#案例1：循环队列实现" class="headerlink" title="案例1：循环队列实现"></a>案例1：循环队列实现</h3><p><strong>题意</strong>：用数组实现循环队列，支持高效入队&#x2F;出队。</p><p><strong>思路</strong>：头尾指针循环递增，判满&#x2F;判空需特殊处理。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularQueue</span> &#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;<br>    <span class="hljs-type">int</span> head, tail, cap, cnt;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CircularQueue</span>(<span class="hljs-type">int</span> k) : <span class="hljs-built_in">data</span>(k), <span class="hljs-built_in">head</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">tail</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">cap</span>(k), <span class="hljs-built_in">cnt</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cnt == cap) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        data[tail] = x;<br>        tail = (tail + <span class="hljs-number">1</span>) % cap;<br>        ++cnt;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        head = (head + <span class="hljs-number">1</span>) % cap;<br>        --cnt;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cnt ? data[head] : <span class="hljs-number">-1</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cnt ? data[(tail - <span class="hljs-number">1</span> + cap) % cap] : <span class="hljs-number">-1</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cnt == <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cnt == cap; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(1)</p><p><strong>应用说明</strong>：常用于缓冲区、生产者-消费者模型、流式数据处理等。</p><hr><h3 id="案例2：滑动窗口最大值（队列解法）"><a href="#案例2：滑动窗口最大值（队列解法）" class="headerlink" title="案例2：滑动窗口最大值（队列解法）"></a>案例2：滑动窗口最大值（队列解法）</h3><p><strong>题意</strong>：同数组专题案例2，队列实现。</p><p><strong>思路</strong>：用单调队列维护窗口最大值。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; dq.<span class="hljs-built_in">front</span>() &lt;= i - k) dq.<span class="hljs-built_in">pop_front</span>();<br>        <span class="hljs-keyword">while</span> (!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[dq.<span class="hljs-built_in">back</span>()] &lt;= nums[i]) dq.<span class="hljs-built_in">pop_back</span>();<br>        dq.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) res.<span class="hljs-built_in">push_back</span>(nums[dq.<span class="hljs-built_in">front</span>()]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于数据流最大&#x2F;最小值、实时监控、信号处理等。</p><hr><h3 id="案例3：用队列实现栈"><a href="#案例3：用队列实现栈" class="headerlink" title="案例3：用队列实现栈"></a>案例3：用队列实现栈</h3><p><strong>题意</strong>：只用队列实现栈的push、pop、top操作。</p><p><strong>思路</strong>：每次push后将前面元素依次出队再入队，保证队首为栈顶。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        q.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; q.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            q.<span class="hljs-built_in">push</span>(q.<span class="hljs-built_in">front</span>());<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123; q.<span class="hljs-built_in">pop</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">front</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：push O(n)，pop&#x2F;top&#x2F;empty O(1)</p><p><strong>应用说明</strong>：常用于数据结构设计、面试题、栈队列互模拟。</p><hr><h3 id="案例4：广度优先搜索（BFS）"><a href="#案例4：广度优先搜索（BFS）" class="headerlink" title="案例4：广度优先搜索（BFS）"></a>案例4：广度优先搜索（BFS）</h3><p><strong>题意</strong>：用队列实现图&#x2F;树的层次遍历。</p><p><strong>思路</strong>：每次弹出队首节点，将其所有未访问邻居入队。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, std::vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    visited[start] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>                visited[v] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(V+E)</p><p><strong>应用说明</strong>：常用于最短路、连通分量、层次遍历、迷宫等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05_%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05_%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表详解与C-实现"><a href="#哈希表详解与C-实现" class="headerlink" title="哈希表详解与C++实现"></a>哈希表详解与C++实现</h1><h2 id="1-哈希表概念（详细）"><a href="#1-哈希表概念（详细）" class="headerlink" title="1. 哈希表概念（详细）"></a>1. 哈希表概念（详细）</h2><p>哈希表（Hash Table）是一种基于<strong>哈希函数</strong>实现的键值对存储结构，支持高效的插入、查找和删除操作。</p><ul><li><strong>哈希函数</strong>：将键（Key）映射为数组下标，决定数据分布。</li><li><strong>冲突处理</strong>：不同键可能映射到同一位置，需处理冲突。<ul><li><strong>拉链法</strong>：每个桶存储一个链表，冲突元素链入同一桶。</li><li><strong>开放寻址</strong>：冲突时在表内寻找下一个空位（如线性探测、二次探测、双哈希）。</li></ul></li><li><strong>负载因子</strong>：元素个数&#x2F;桶数，过高需扩容再哈希。</li><li><strong>优点</strong>：<ul><li>插入、查找、删除平均O(1)。</li><li>适合大规模数据快速查找。</li></ul></li><li><strong>缺点</strong>：<ul><li>最坏O(n)，如哈希冲突严重。</li><li>需设计高质量哈希函数。</li><li>不支持有序遍历。</li></ul></li></ul><h2 id="2-C-实现与常用操作"><a href="#2-C-实现与常用操作" class="headerlink" title="2. C++实现与常用操作"></a>2. C++实现与常用操作</h2><h3 id="2-1-拉链法实现"><a href="#2-1-拉链法实现" class="headerlink" title="2.1 拉链法实现"></a>2.1 拉链法实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> key, val;<br>    Node* next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v) : <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HashMap</span>(<span class="hljs-type">int</span> cap = <span class="hljs-number">1009</span>) : <span class="hljs-built_in">cap</span>(cap), <span class="hljs-built_in">data</span>(cap, <span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123; <span class="hljs-keyword">return</span> key % cap; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">hash</span>(key);<br>        Node* node = data[idx];<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;key == key) &#123; node-&gt;val = val; <span class="hljs-keyword">return</span>; &#125;<br>            node = node-&gt;next;<br>        &#125;<br>        Node* n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, val);<br>        n-&gt;next = data[idx];<br>        data[idx] = n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span>&amp; val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">hash</span>(key);<br>        Node* node = data[idx];<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;key == key) &#123; val = node-&gt;val; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> idx = <span class="hljs-built_in">hash</span>(key);<br>        Node* node = data[idx], *prev = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            <span class="hljs-keyword">if</span> (node-&gt;key == key) &#123;<br>                <span class="hljs-keyword">if</span> (prev) prev-&gt;next = node-&gt;next;<br>                <span class="hljs-keyword">else</span> data[idx] = node-&gt;next;<br>                <span class="hljs-keyword">delete</span> node;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            prev = node; node = node-&gt;next;<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">HashMap</span>() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> head : data) &#123;<br>            <span class="hljs-keyword">while</span> (head) &#123;<br>                Node* tmp = head;<br>                head = head-&gt;next;<br>                <span class="hljs-keyword">delete</span> tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> cap;<br>    std::vector&lt;Node*&gt; data;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-STL哈希表"><a href="#2-2-STL哈希表" class="headerlink" title="2.2 STL哈希表"></a>2.2 STL哈希表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br>std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>mp[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> v = mp[<span class="hljs-number">1</span>];<br>mp.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [k, v] : mp) std::cout &lt;&lt; k &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>插入&#x2F;查找&#x2F;删除：O(1)均摊，最坏O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>需要高效查找、去重、计数的场景，如缓存、索引、唯一性判定、频率统计等。</li><li>常用于实现集合、映射、LRU缓存、哈希集合等。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>哈希冲突</strong>：哈希函数设计不佳或负载因子过高会导致冲突严重，性能退化。</li><li><strong>扩容与再哈希</strong>：元素过多需扩容，rehash代价高。</li><li><strong>哈希攻击</strong>：恶意输入可导致哈希表退化为链表。</li><li><strong>自定义类型哈希</strong>：C++自定义类型需重载hash和&#x3D;&#x3D;。</li><li><strong>遍历无序</strong>：哈希表遍历顺序不确定。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：两数之和"><a href="#案例1：两数之和" class="headerlink" title="案例1：两数之和"></a>案例1：两数之和</h3><p><strong>题意</strong>：给定数组和目标值，找出两数之和为目标的下标。</p><p><strong>思路</strong>：用哈希表记录已访问元素，查找target-x是否存在。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-type">int</span> t = target - nums[i];<br>        <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">count</span>(t)) <span class="hljs-keyword">return</span> &#123;mp[t], i&#125;;<br>        mp[nums[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于数组查找、去重、配对等。</p><hr><h3 id="案例2：LRU缓存（哈希表-双向链表）"><a href="#案例2：LRU缓存（哈希表-双向链表）" class="headerlink" title="案例2：LRU缓存（哈希表+双向链表）"></a>案例2：LRU缓存（哈希表+双向链表）</h3><p><strong>题意</strong>：同链表专题案例2。</p><p><strong>思路</strong>：哈希表定位节点，双向链表维护顺序。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 见链表专题案例2</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(1)</p><p><strong>应用说明</strong>：缓存淘汰、内存管理、最近最少使用策略。</p><hr><h3 id="案例3：字符串去重"><a href="#案例3：字符串去重" class="headerlink" title="案例3：字符串去重"></a>案例3：字符串去重</h3><p><strong>题意</strong>：给定字符串，去除重复字符，保留顺序。</p><p><strong>思路</strong>：用哈希表记录已出现字符。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::string <span class="hljs-title">removeDuplicate</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; s)</span> </span>&#123;<br>    std::unordered_set&lt;<span class="hljs-type">char</span>&gt; seen;<br>    std::string res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s) &#123;<br>        <span class="hljs-keyword">if</span> (!seen.<span class="hljs-built_in">count</span>(c)) &#123;<br>            seen.<span class="hljs-built_in">insert</span>(c);<br>            res += c;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于数据去重、唯一性判定、字符串处理等。</p><hr><h3 id="案例4：哈希冲突分析与自定义哈希"><a href="#案例4：哈希冲突分析与自定义哈希" class="headerlink" title="案例4：哈希冲突分析与自定义哈希"></a>案例4：哈希冲突分析与自定义哈希</h3><p><strong>题意</strong>：分析哈希冲突，设计自定义类型哈希。</p><p><strong>思路</strong>：自定义结构体需重载hash和&#x3D;&#x3D;。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Point&amp; o) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> x == o.x &amp;&amp; y == o.y; &#125;<br>&#125;;<br><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span>&lt;&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hash</span>&lt;Point&gt; &#123;<br>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p)</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(p.x) ^ (<span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int</span>&gt;()(p.y) &lt;&lt; <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;;<br>&#125;<br>std::unordered_set&lt;Point&gt; s;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(1)均摊</p><p><strong>应用说明</strong>：常用于几何、坐标判重、工程自定义key等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06_%E4%BA%8C%E5%8F%89%E6%A0%91%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06_%E4%BA%8C%E5%8F%89%E6%A0%91%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树详解与C-实现"><a href="#二叉树详解与C-实现" class="headerlink" title="二叉树详解与C++实现"></a>二叉树详解与C++实现</h1><h2 id="1-二叉树概念（详细）"><a href="#1-二叉树概念（详细）" class="headerlink" title="1. 二叉树概念（详细）"></a>1. 二叉树概念（详细）</h2><p>二叉树（Binary Tree）是一种每个节点最多有两个子节点（左、右）的树形结构，是最常用的树结构。</p><ul><li><strong>节点结构</strong>：每个节点包含数据域、左子指针、右子指针。</li><li><strong>递归定义</strong>：二叉树为空，或由根节点、左子树、右子树组成。</li><li><strong>分类</strong>：<ul><li><strong>满二叉树</strong>：所有非叶节点都有两个子节点，所有叶节点在同一层。</li><li><strong>完全二叉树</strong>：除最后一层外，其他层节点数均满，最后一层节点从左到右连续。</li><li><strong>平衡二叉树</strong>：任意节点左右子树高度差不超过1。</li><li><strong>二叉搜索树（BST）</strong>：左子树所有节点小于根，右子树所有节点大于根。</li></ul></li><li><strong>遍历方式</strong>：前序、中序、后序、层序遍历。</li><li><strong>优点</strong>：<ul><li>结构灵活，便于递归处理。</li><li>可高效实现查找、排序、区间操作。</li></ul></li><li><strong>缺点</strong>：<ul><li>退化为链表时效率低。</li><li>需平衡机制保证性能。</li></ul></li></ul><h2 id="2-C-实现与常用操作"><a href="#2-C-实现与常用操作" class="headerlink" title="2. C++实现与常用操作"></a>2. C++实现与常用操作</h2><h3 id="2-1-二叉树节点"><a href="#2-1-二叉树节点" class="headerlink" title="2.1 二叉树节点"></a>2.1 二叉树节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-插入与查找（以二叉搜索树为例）"><a href="#2-2-插入与查找（以二叉搜索树为例）" class="headerlink" title="2.2 插入与查找（以二叉搜索树为例）"></a>2.2 插入与查找（以二叉搜索树为例）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>    <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="hljs-built_in">insert</span>(root-&gt;left, val);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; root-&gt;val) root-&gt;right = <span class="hljs-built_in">insert</span>(root-&gt;right, val);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function">TreeNode* <span class="hljs-title">find</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(root-&gt;left, val);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(root-&gt;right, val);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-遍历"><a href="#2-3-遍历" class="headerlink" title="2.3 遍历"></a>2.3 遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 前序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    std::cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preorder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preorder</span>(root-&gt;right);<br>&#125;<br><span class="hljs-comment">// 中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>    std::cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>&#125;<br><span class="hljs-comment">// 后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">postorder</span>(root-&gt;left);<br>    <span class="hljs-built_in">postorder</span>(root-&gt;right);<br>    std::cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">// 层序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">levelorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    std::queue&lt;TreeNode*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        TreeNode* node = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        std::cout &lt;&lt; node-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">if</span> (node-&gt;left) q.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (node-&gt;right) q.<span class="hljs-built_in">push</span>(node-&gt;right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-删除节点（BST）"><a href="#2-4-删除节点（BST）" class="headerlink" title="2.4 删除节点（BST）"></a>2.4 删除节点（BST）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">remove</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="hljs-built_in">remove</span>(root-&gt;left, val);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; root-&gt;val) root-&gt;right = <span class="hljs-built_in">remove</span>(root-&gt;right, val);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left) &#123;<br>            TreeNode* r = root-&gt;right;<br>            <span class="hljs-keyword">delete</span> root;<br>            <span class="hljs-keyword">return</span> r;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root-&gt;right) &#123;<br>            TreeNode* l = root-&gt;left;<br>            <span class="hljs-keyword">delete</span> root;<br>            <span class="hljs-keyword">return</span> l;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            TreeNode* p = root-&gt;right;<br>            <span class="hljs-keyword">while</span> (p-&gt;left) p = p-&gt;left;<br>            root-&gt;val = p-&gt;val;<br>            root-&gt;right = <span class="hljs-built_in">remove</span>(root-&gt;right, p-&gt;val);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>查找&#x2F;插入&#x2F;删除：O(log n)（平衡树），最坏O(n)</li><li>遍历：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>有序数据存储、查找、区间查询、表达式树、堆、平衡树等。</li><li>常用于实现集合、映射、优先队列、数据库索引等。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>递归栈溢出</strong>：树高过大时递归遍历易栈溢出。</li><li><strong>空指针访问</strong>：遍历&#x2F;插入&#x2F;删除时需判空。</li><li><strong>BST重复元素</strong>：二叉搜索树通常不允许重复元素，需特殊处理。</li><li><strong>删除节点复杂</strong>：BST删除需分三种情况，注意指针调整。</li><li><strong>树的平衡性</strong>：普通二叉树易退化为链表，需平衡机制。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：二叉树的前中后序遍历"><a href="#案例1：二叉树的前中后序遍历" class="headerlink" title="案例1：二叉树的前中后序遍历"></a>案例1：二叉树的前中后序遍历</h3><p><strong>题意</strong>：实现二叉树的前序、中序、后序遍历。</p><p><strong>思路</strong>：递归或栈实现。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    std::cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">preorder</span>(root-&gt;left);<br>    <span class="hljs-built_in">preorder</span>(root-&gt;right);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>    std::cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">postorder</span>(root-&gt;left);<br>    <span class="hljs-built_in">postorder</span>(root-&gt;right);<br>    std::cout &lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于树结构遍历、表达式树、序列化等。</p><hr><h3 id="案例2：二叉搜索树插入与查找"><a href="#案例2：二叉搜索树插入与查找" class="headerlink" title="案例2：二叉搜索树插入与查找"></a>案例2：二叉搜索树插入与查找</h3><p><strong>题意</strong>：实现二叉搜索树的插入和查找操作。</p><p><strong>思路</strong>：递归或迭代，左小右大。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">insert</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>    <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="hljs-built_in">insert</span>(root-&gt;left, val);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; root-&gt;val) root-&gt;right = <span class="hljs-built_in">insert</span>(root-&gt;right, val);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function">TreeNode* <span class="hljs-title">find</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(root-&gt;left, val);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(root-&gt;right, val);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)~O(n)</p><p><strong>应用说明</strong>：常用于有序数据存储、查找、集合等。</p><hr><h3 id="案例3：最近公共祖先（LCA）"><a href="#案例3：最近公共祖先（LCA）" class="headerlink" title="案例3：最近公共祖先（LCA）"></a>案例3：最近公共祖先（LCA）</h3><p><strong>题意</strong>：给定二叉树和两个节点，求它们的最近公共祖先。</p><p><strong>思路</strong>：递归查找，若左右子树分别包含目标节点则当前节点为LCA。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>    TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>    TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>    <span class="hljs-keyword">if</span> (left &amp;&amp; right) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">return</span> left ? left : right;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于家谱、组织结构、文件系统等。</p><hr><h3 id="案例4：二叉树的最大路径和"><a href="#案例4：二叉树的最大路径和" class="headerlink" title="案例4：二叉树的最大路径和"></a>案例4：二叉树的最大路径和</h3><p><strong>题意</strong>：求二叉树中任意两节点间的最大路径和。</p><p><strong>思路</strong>：递归计算每个节点的最大贡献值，更新全局最大值。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = INT_MIN;<br>    std::function&lt;<span class="hljs-type">int</span>(TreeNode*)&gt; dfs = [&amp;](TreeNode* node) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dfs</span>(node-&gt;left));<br>        <span class="hljs-type">int</span> r = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dfs</span>(node-&gt;right));<br>        res = std::<span class="hljs-built_in">max</span>(res, node-&gt;val + l + r);<br>        <span class="hljs-keyword">return</span> node-&gt;val + std::<span class="hljs-built_in">max</span>(l, r);<br>    &#125;;<br>    <span class="hljs-built_in">dfs</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)</p><p><strong>应用说明</strong>：常用于路径规划、树形DP、最大收益等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>平衡树详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/07_%E5%B9%B3%E8%A1%A1%E6%A0%91%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/07_%E5%B9%B3%E8%A1%A1%E6%A0%91%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="平衡树详解与C-实现"><a href="#平衡树详解与C-实现" class="headerlink" title="平衡树详解与C++实现"></a>平衡树详解与C++实现</h1><h2 id="1-平衡树概念（详细）"><a href="#1-平衡树概念（详细）" class="headerlink" title="1. 平衡树概念（详细）"></a>1. 平衡树概念（详细）</h2><p>平衡树（Balanced Tree）是一类通过结构调整保持树高对数级的数据结构，常见有AVL树、红黑树等。</p><ul><li><strong>平衡条件</strong>：任意节点左右子树高度差不超过某一常数（如AVL树为1）。</li><li><strong>AVL树</strong>：最早的自平衡二叉搜索树，插入&#x2F;删除后通过旋转保持平衡。</li><li><strong>红黑树</strong>：每个节点有颜色标记，满足红黑性质，插入&#x2F;删除后通过变色和旋转保持平衡。</li><li><strong>旋转操作</strong>：包括左旋、右旋、双旋，用于恢复平衡。</li><li><strong>优点</strong>：<ul><li>查找、插入、删除均为O(log n)。</li><li>保证最坏情况下性能。</li></ul></li><li><strong>缺点</strong>：<ul><li>实现复杂，旋转和维护高度&#x2F;颜色需额外操作。</li><li>常数开销略大于普通BST。</li></ul></li></ul><h2 id="2-C-实现与常用操作（以AVL树为例）"><a href="#2-C-实现与常用操作（以AVL树为例）" class="headerlink" title="2. C++实现与常用操作（以AVL树为例）"></a>2. C++实现与常用操作（以AVL树为例）</h2><h3 id="2-1-AVL树节点"><a href="#2-1-AVL树节点" class="headerlink" title="2.1 AVL树节点"></a>2.1 AVL树节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AVLNode</span> &#123;<br>    <span class="hljs-type">int</span> val, height;<br>    AVLNode* left;<br>    AVLNode* right;<br>    <span class="hljs-built_in">AVLNode</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">height</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-旋转操作"><a href="#2-2-旋转操作" class="headerlink" title="2.2 旋转操作"></a>2.2 旋转操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(AVLNode* node)</span> </span>&#123; <span class="hljs-keyword">return</span> node ? node-&gt;height : <span class="hljs-number">0</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getBalance</span><span class="hljs-params">(AVLNode* node)</span> </span>&#123; <span class="hljs-keyword">return</span> node ? <span class="hljs-built_in">getHeight</span>(node-&gt;left) - <span class="hljs-built_in">getHeight</span>(node-&gt;right) : <span class="hljs-number">0</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateHeight</span><span class="hljs-params">(AVLNode* node)</span> </span>&#123; node-&gt;height = <span class="hljs-number">1</span> + std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">getHeight</span>(node-&gt;left), <span class="hljs-built_in">getHeight</span>(node-&gt;right)); &#125;<br><span class="hljs-function">AVLNode* <span class="hljs-title">rightRotate</span><span class="hljs-params">(AVLNode* y)</span> </span>&#123;<br>    AVLNode* x = y-&gt;left;<br>    AVLNode* T2 = x-&gt;right;<br>    x-&gt;right = y;<br>    y-&gt;left = T2;<br>    <span class="hljs-built_in">updateHeight</span>(y);<br>    <span class="hljs-built_in">updateHeight</span>(x);<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function">AVLNode* <span class="hljs-title">leftRotate</span><span class="hljs-params">(AVLNode* x)</span> </span>&#123;<br>    AVLNode* y = x-&gt;right;<br>    AVLNode* T2 = y-&gt;left;<br>    y-&gt;left = x;<br>    x-&gt;right = T2;<br>    <span class="hljs-built_in">updateHeight</span>(x);<br>    <span class="hljs-built_in">updateHeight</span>(y);<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-插入操作"><a href="#2-3-插入操作" class="headerlink" title="2.3 插入操作"></a>2.3 插入操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">AVLNode* <span class="hljs-title">insert</span><span class="hljs-params">(AVLNode* node, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">AVLNode</span>(val);<br>    <span class="hljs-keyword">if</span> (val &lt; node-&gt;val) node-&gt;left = <span class="hljs-built_in">insert</span>(node-&gt;left, val);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; node-&gt;val) node-&gt;right = <span class="hljs-built_in">insert</span>(node-&gt;right, val);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> node;<br>    <span class="hljs-built_in">updateHeight</span>(node);<br>    <span class="hljs-type">int</span> balance = <span class="hljs-built_in">getBalance</span>(node);<br>    <span class="hljs-comment">// LL型</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; val &lt; node-&gt;left-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br>    <span class="hljs-comment">// RR型</span><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; val &gt; node-&gt;right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br>    <span class="hljs-comment">// LR型</span><br>    <span class="hljs-keyword">if</span> (balance &gt; <span class="hljs-number">1</span> &amp;&amp; val &gt; node-&gt;left-&gt;val) &#123;<br>        node-&gt;left = <span class="hljs-built_in">leftRotate</span>(node-&gt;left);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rightRotate</span>(node);<br>    &#125;<br>    <span class="hljs-comment">// RL型</span><br>    <span class="hljs-keyword">if</span> (balance &lt; <span class="hljs-number">-1</span> &amp;&amp; val &lt; node-&gt;right-&gt;val) &#123;<br>        node-&gt;right = <span class="hljs-built_in">rightRotate</span>(node-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">leftRotate</span>(node);<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-查找操作"><a href="#2-4-查找操作" class="headerlink" title="2.4 查找操作"></a>2.4 查找操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">AVLNode* <span class="hljs-title">find</span><span class="hljs-params">(AVLNode* node, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!node || node-&gt;val == val) <span class="hljs-keyword">return</span> node;<br>    <span class="hljs-keyword">if</span> (val &lt; node-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(node-&gt;left, val);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(node-&gt;right, val);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>查找&#x2F;插入&#x2F;删除：O(log n)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>需要高效有序查找、区间查询、数据库索引、集合&#x2F;映射底层等。</li><li>STL的map&#x2F;set底层为红黑树。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>旋转操作易错</strong>：左旋、右旋、双旋指针调整需细致。</li><li><strong>高度&#x2F;颜色维护</strong>：插入&#x2F;删除后需及时更新高度或颜色。</li><li><strong>红黑树变色规则复杂</strong>：插入&#x2F;删除时需多步变色和旋转。</li><li><strong>区间操作实现难度大</strong>：如区间第k大、区间和等需额外维护信息。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：AVL树插入与旋转"><a href="#案例1：AVL树插入与旋转" class="headerlink" title="案例1：AVL树插入与旋转"></a>案例1：AVL树插入与旋转</h3><p><strong>题意</strong>：实现AVL树的插入操作，保持平衡。</p><p><strong>思路</strong>：插入后自底向上更新高度，必要时旋转。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 见正文2.3插入操作</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：有序集合、区间查询、数据库索引等。</p><hr><h3 id="案例2：红黑树插入（伪代码）"><a href="#案例2：红黑树插入（伪代码）" class="headerlink" title="案例2：红黑树插入（伪代码）"></a>案例2：红黑树插入（伪代码）</h3><p><strong>题意</strong>：实现红黑树插入，保持红黑性质。</p><p><strong>思路</strong>：插入为红，父红需旋转&#x2F;变色，分多种情况。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 伪代码，实际工程建议用STL map/set</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertRB</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 按BST插入新节点，颜色为红</span><br>    <span class="hljs-comment">// 2. 若父为黑，结束；若父为红，分叔叔红/黑多种情况</span><br>    <span class="hljs-comment">// 3. 旋转/变色，递归向上修正</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：STL map&#x2F;set、数据库索引、内存管理等。</p><hr><h3 id="案例3：区间第k大（平衡树-权值统计）"><a href="#案例3：区间第k大（平衡树-权值统计）" class="headerlink" title="案例3：区间第k大（平衡树+权值统计）"></a>案例3：区间第k大（平衡树+权值统计）</h3><p><strong>题意</strong>：支持插入、删除、查询区间第k大。</p><p><strong>思路</strong>：平衡树节点维护子树大小，递归查找第k大。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需实现带size域的平衡树，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：在线排名、动态区间统计、竞赛题等。</p><hr><h3 id="案例4：平衡树动态区间和"><a href="#案例4：平衡树动态区间和" class="headerlink" title="案例4：平衡树动态区间和"></a>案例4：平衡树动态区间和</h3><p><strong>题意</strong>：支持区间插入、删除、区间和查询。</p><p><strong>思路</strong>：平衡树节点维护子树和，递归更新。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需实现带sum域的平衡树，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：区间统计、动态数据分析、工程数据库等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>平衡树</tag>
      
      <tag>AVL树</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/08_%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/08_%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="线段树详解与C-实现"><a href="#线段树详解与C-实现" class="headerlink" title="线段树详解与C++实现"></a>线段树详解与C++实现</h1><h2 id="1-线段树概念（详细）"><a href="#1-线段树概念（详细）" class="headerlink" title="1. 线段树概念（详细）"></a>1. 线段树概念（详细）</h2><p>线段树（Segment Tree）是一种支持区间查询和区间修改的树状数据结构，常用于处理区间最值、区间和、区间更新等问题。</p><ul><li><strong>区间分治</strong>：将区间递归划分为左右两部分，节点存储区间信息。</li><li><strong>节点结构</strong>：每个节点表示一个区间[l, r]，存储区间统计信息（如和、最值）。</li><li><strong>懒惰标记</strong>：用于延迟区间修改，提升批量操作效率。</li><li><strong>优点</strong>：<ul><li>支持O(log n)区间查询和修改。</li><li>灵活处理多种区间问题。</li></ul></li><li><strong>缺点</strong>：<ul><li>实现复杂，递归和懒惰标记需细致处理。</li><li>空间开销大于树状数组。</li></ul></li></ul><h2 id="2-C-实现与常用操作"><a href="#2-C-实现与常用操作" class="headerlink" title="2. C++实现与常用操作"></a>2. C++实现与常用操作</h2><h3 id="2-1-节点结构与建树"><a href="#2-1-节点结构与建树" class="headerlink" title="2.1 节点结构与建树"></a>2.1 节点结构与建树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> l, r, sum, lazy;<br>    Node* left;<br>    Node* right;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) : <span class="hljs-built_in">l</span>(l), <span class="hljs-built_in">r</span>(r), <span class="hljs-built_in">sum</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">lazy</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-function">Node* <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(l, r);<br>    <span class="hljs-keyword">if</span> (l == r) &#123; node-&gt;sum = arr[l]; <span class="hljs-keyword">return</span> node; &#125;<br>    <span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>    node-&gt;left = <span class="hljs-built_in">build</span>(arr, l, m);<br>    node-&gt;right = <span class="hljs-built_in">build</span>(arr, m + <span class="hljs-number">1</span>, r);<br>    node-&gt;sum = node-&gt;left-&gt;sum + node-&gt;right-&gt;sum;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-区间查询与修改"><a href="#2-2-区间查询与修改" class="headerlink" title="2.2 区间查询与修改"></a>2.2 区间查询与修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node-&gt;lazy) &#123;<br>        <span class="hljs-type">int</span> lz = node-&gt;lazy;<br>        node-&gt;left-&gt;sum += lz * (node-&gt;left-&gt;r - node-&gt;left-&gt;l + <span class="hljs-number">1</span>);<br>        node-&gt;right-&gt;sum += lz * (node-&gt;right-&gt;r - node-&gt;right-&gt;l + <span class="hljs-number">1</span>);<br>        node-&gt;left-&gt;lazy += lz;<br>        node-&gt;right-&gt;lazy += lz;<br>        node-&gt;lazy = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Node* node, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node-&gt;r &lt; l || node-&gt;l &gt; r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r) &#123;<br>        node-&gt;sum += val * (node-&gt;r - node-&gt;l + <span class="hljs-number">1</span>);<br>        node-&gt;lazy += val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">pushDown</span>(node);<br>    <span class="hljs-built_in">update</span>(node-&gt;left, l, r, val);<br>    <span class="hljs-built_in">update</span>(node-&gt;right, l, r, val);<br>    node-&gt;sum = node-&gt;left-&gt;sum + node-&gt;right-&gt;sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(Node* node, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node-&gt;r &lt; l || node-&gt;l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r) <span class="hljs-keyword">return</span> node-&gt;sum;<br>    <span class="hljs-built_in">pushDown</span>(node);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(node-&gt;left, l, r) + <span class="hljs-built_in">query</span>(node-&gt;right, l, r);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>建树：O(n)</li><li>区间查询&#x2F;修改：O(log n)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>区间和&#x2F;最值&#x2F;计数、区间批量修改、动态区间问题、竞赛题等。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>懒惰标记下推易错</strong>：区间修改时需及时下推懒标，防止统计错误。</li><li><strong>节点合并&#x2F;分裂</strong>：递归合并&#x2F;分裂节点时需注意边界。</li><li><strong>空间开销</strong>：动态开点线段树空间大，静态线段树需4n空间。</li><li><strong>多种信息维护</strong>：如区间最小值、最大值、gcd等需自定义合并函数。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：区间和查询与修改"><a href="#案例1：区间和查询与修改" class="headerlink" title="案例1：区间和查询与修改"></a>案例1：区间和查询与修改</h3><p><strong>题意</strong>：支持区间加法和区间和查询。</p><p><strong>思路</strong>：见正文2.2 update&#x2F;query。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 见正文2.2 update/query</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：区间统计、动态数据分析、竞赛题等。</p><hr><h3 id="案例2：区间最值查询"><a href="#案例2：区间最值查询" class="headerlink" title="案例2：区间最值查询"></a>案例2：区间最值查询</h3><p><strong>题意</strong>：支持区间最大&#x2F;最小值查询。</p><p><strong>思路</strong>：节点维护区间最值，递归查询合并。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 只需将sum改为max/min，合并时取max/min</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：最大子段和、区间最值、动态规划优化等。</p><hr><h3 id="案例3：区间第k大（主席树-权值线段树）"><a href="#案例3：区间第k大（主席树-权值线段树）" class="headerlink" title="案例3：区间第k大（主席树&#x2F;权值线段树）"></a>案例3：区间第k大（主席树&#x2F;权值线段树）</h3><p><strong>题意</strong>：支持区间第k大查询。</p><p><strong>思路</strong>：权值线段树或主席树维护前缀权值分布，二分查找。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需实现权值线段树/主席树，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：在线排名、动态区间统计、竞赛题等。</p><hr><h3 id="案例4：区间gcd-最大公约数"><a href="#案例4：区间gcd-最大公约数" class="headerlink" title="案例4：区间gcd&#x2F;最大公约数"></a>案例4：区间gcd&#x2F;最大公约数</h3><p><strong>题意</strong>：支持区间gcd查询。</p><p><strong>思路</strong>：节点维护区间gcd，合并时取gcd。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 只需将sum改为gcd，合并时取gcd</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：数论区间问题、最大公约数统计等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/09_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/09_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="树状数组详解与C-实现"><a href="#树状数组详解与C-实现" class="headerlink" title="树状数组详解与C++实现"></a>树状数组详解与C++实现</h1><h2 id="1-树状数组概念（详细）"><a href="#1-树状数组概念（详细）" class="headerlink" title="1. 树状数组概念（详细）"></a>1. 树状数组概念（详细）</h2><p>树状数组（Binary Indexed Tree, Fenwick Tree）是一种高效支持前缀和&#x2F;区间和查询与单点修改的数据结构。</p><ul><li><strong>低位原理</strong>：利用二进制最低位性质，快速定位父子区间。</li><li><strong>单点修改</strong>：通过更新相关节点，O(log n)完成单点加法。</li><li><strong>前缀和查询</strong>：通过累加相关节点，O(log n)查询前缀和。</li><li><strong>区间和</strong>：前缀和差值。</li><li><strong>优点</strong>：<ul><li>实现简单，空间小。</li><li>支持动态数组。</li></ul></li><li><strong>缺点</strong>：<ul><li>仅支持单点修改+区间查询，或区间修改+单点查询。</li><li>不支持区间修改+区间查询（需线段树）。</li></ul></li></ul><h2 id="2-C-实现与常用操作"><a href="#2-C-实现与常用操作" class="headerlink" title="2. C++实现与常用操作"></a>2. C++实现与常用操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FenwickTree</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FenwickTree</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">tree</span>(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (++i; i &lt; tree.<span class="hljs-built_in">size</span>(); i += i &amp; -i) tree[i] += x;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prefixSum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (++i; i &gt; <span class="hljs-number">0</span>; i -= i &amp; -i) res += tree[i];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">prefixSum</span>(r) - <span class="hljs-built_in">prefixSum</span>(l - <span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>单点修改&#x2F;前缀和&#x2F;区间和：O(log n)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>前缀和、区间和、逆序对、动态计数、竞赛题等。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>下标从1开始</strong>：树状数组实现通常下标从1，易越界。</li><li><strong>区间修改与单点查询</strong>：需用差分或双树状数组实现。</li><li><strong>空间浪费</strong>：数组大小需大于数据最大下标。</li><li><strong>多维树状数组</strong>：二维&#x2F;多维BIT实现复杂。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：区间和查询与单点修改"><a href="#案例1：区间和查询与单点修改" class="headerlink" title="案例1：区间和查询与单点修改"></a>案例1：区间和查询与单点修改</h3><p><strong>题意</strong>：支持单点加法和区间和查询。</p><p><strong>思路</strong>：见正文2。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 见正文2</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：前缀和、动态计数、竞赛题等。</p><hr><h3 id="案例2：逆序对计数"><a href="#案例2：逆序对计数" class="headerlink" title="案例2：逆序对计数"></a>案例2：逆序对计数</h3><p><strong>题意</strong>：给定数组，统计逆序对数量。</p><p><strong>思路</strong>：从后往前遍历，用BIT统计已出现小于当前值的个数。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countInversions</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bit</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span>, arr </span>= nums;<br>    std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : arr) mp[v] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">1</span>; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [k, v] : mp) v = idx++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-type">int</span> x = mp[arr[i]];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = x - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j -= j &amp; -j) res += bit[j];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = x; j &lt; bit.<span class="hljs-built_in">size</span>(); j += j &amp; -j) bit[j]++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n log n)</p><p><strong>应用说明</strong>：逆序对、动态排名、区间计数等。</p><hr><h3 id="案例3：区间修改与单点查询"><a href="#案例3：区间修改与单点查询" class="headerlink" title="案例3：区间修改与单点查询"></a>案例3：区间修改与单点查询</h3><p><strong>题意</strong>：支持区间加法和单点查询。</p><p><strong>思路</strong>：用差分或双树状数组实现。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需实现差分BIT或双BIT，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：区间更新、动态数据分析、竞赛题等。</p><hr><h3 id="案例4：二维树状数组"><a href="#案例4：二维树状数组" class="headerlink" title="案例4：二维树状数组"></a>案例4：二维树状数组</h3><p><strong>题意</strong>：支持二维矩阵的区间和查询与单点修改。</p><p><strong>思路</strong>：二维BIT实现，维护二维前缀和。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需实现二维BIT，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log^2 n)</p><p><strong>应用说明</strong>：二维前缀和、图像处理、矩阵统计等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳表详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10_%E8%B7%B3%E8%A1%A8%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10_%E8%B7%B3%E8%A1%A8%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="跳表详解与C-实现"><a href="#跳表详解与C-实现" class="headerlink" title="跳表详解与C++实现"></a>跳表详解与C++实现</h1><h2 id="1-跳表概念（详细）"><a href="#1-跳表概念（详细）" class="headerlink" title="1. 跳表概念（详细）"></a>1. 跳表概念（详细）</h2><p>跳表（Skip List）是一种基于多级索引的概率型有序链表，支持高效的查找、插入和删除。</p><ul><li><strong>多级索引</strong>：每个节点可有多层指针，形成多级链表。</li><li><strong>概率平衡</strong>：通过随机化决定节点层数，期望高度O(log n)。</li><li><strong>节点结构</strong>：包含值和多级指针数组。</li><li><strong>优点</strong>：<ul><li>查找、插入、删除均为O(log n)期望复杂度。</li><li>实现简单，易于并发扩展。</li></ul></li><li><strong>缺点</strong>：<ul><li>需随机数支持。</li><li>最坏复杂度O(n)。</li><li>空间开销大于普通链表。</li></ul></li></ul><h2 id="2-C-实现与常用操作"><a href="#2-C-实现与常用操作" class="headerlink" title="2. C++实现与常用操作"></a>2. C++实现与常用操作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        std::vector&lt;Node*&gt; next;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> level) : <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">next</span>(level, <span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    &#125;;<br>    <span class="hljs-type">int</span> maxLevel;<br>    <span class="hljs-type">float</span> p;<br>    Node* head;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomLevel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> lvl = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> ((<span class="hljs-type">float</span>)<span class="hljs-built_in">rand</span>() / RAND_MAX &lt; p &amp;&amp; lvl &lt; maxLevel) ++lvl;<br>        <span class="hljs-keyword">return</span> lvl;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SkipList</span>(<span class="hljs-type">int</span> maxLevel = <span class="hljs-number">16</span>, <span class="hljs-type">float</span> p = <span class="hljs-number">0.5</span>) : <span class="hljs-built_in">maxLevel</span>(maxLevel), <span class="hljs-built_in">p</span>(p) &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, maxLevel);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-function">std::vector&lt;Node*&gt; <span class="hljs-title">update</span><span class="hljs-params">(maxLevel, <span class="hljs-literal">nullptr</span>)</span></span>;<br>        Node* cur = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">while</span> (cur-&gt;next[i] &amp;&amp; cur-&gt;next[i]-&gt;val &lt; val) cur = cur-&gt;next[i];<br>            update[i] = cur;<br>        &#125;<br>        <span class="hljs-type">int</span> lvl = <span class="hljs-built_in">randomLevel</span>();<br>        Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val, lvl);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lvl; ++i) &#123;<br>            node-&gt;next[i] = update[i]-&gt;next[i];<br>            update[i]-&gt;next[i] = node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        Node* cur = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">while</span> (cur-&gt;next[i] &amp;&amp; cur-&gt;next[i]-&gt;val &lt; val) cur = cur-&gt;next[i];<br>        &#125;<br>        cur = cur-&gt;next[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> cur &amp;&amp; cur-&gt;val == val;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-function">std::vector&lt;Node*&gt; <span class="hljs-title">update</span><span class="hljs-params">(maxLevel, <span class="hljs-literal">nullptr</span>)</span></span>;<br>        Node* cur = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = maxLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">while</span> (cur-&gt;next[i] &amp;&amp; cur-&gt;next[i]-&gt;val &lt; val) cur = cur-&gt;next[i];<br>            update[i] = cur;<br>        &#125;<br>        cur = cur-&gt;next[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (cur &amp;&amp; cur-&gt;val == val) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxLevel; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (update[i]-&gt;next[i] != cur) <span class="hljs-keyword">break</span>;<br>                update[i]-&gt;next[i] = cur-&gt;next[i];<br>            &#125;<br>            <span class="hljs-keyword">delete</span> cur;<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">SkipList</span>() &#123;<br>        Node* cur = head;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            Node* next = cur-&gt;next[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">delete</span> cur;<br>            cur = next;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>查找&#x2F;插入&#x2F;删除：O(log n)期望，最坏O(n)</li><li>空间复杂度：O(n log n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>有序集合、数据库索引、分布式系统、并发场景等。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>随机层数实现</strong>：需保证层数分布合理，避免退化。</li><li><strong>节点插入&#x2F;删除指针维护</strong>：多层指针需同步更新，易出错。</li><li><strong>空间开销</strong>：高层节点多，空间大于普通链表。</li><li><strong>并发安全</strong>：多线程环境下需加锁或用无锁算法。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：有序集合查找与插入"><a href="#案例1：有序集合查找与插入" class="headerlink" title="案例1：有序集合查找与插入"></a>案例1：有序集合查找与插入</h3><p><strong>题意</strong>：支持有序集合的查找、插入、删除。</p><p><strong>思路</strong>：跳表多级索引，查找&#x2F;插入&#x2F;删除均为O(log n)期望。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 见正文2</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)期望</p><p><strong>应用说明</strong>：有序集合、数据库索引、Redis底层等。</p><hr><h3 id="案例2：区间查询"><a href="#案例2：区间查询" class="headerlink" title="案例2：区间查询"></a>案例2：区间查询</h3><p><strong>题意</strong>：支持区间[l, r]的元素遍历。</p><p><strong>思路</strong>：查找l起点，顺序遍历到r。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需在节点结构中增加指向下一个节点的指针，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n + k)</p><p><strong>应用说明</strong>：区间统计、范围查询、数据库等。</p><hr><h3 id="案例3：并发跳表"><a href="#案例3：并发跳表" class="headerlink" title="案例3：并发跳表"></a>案例3：并发跳表</h3><p><strong>题意</strong>：多线程环境下安全插入、查找、删除。</p><p><strong>思路</strong>：加锁或用无锁算法保证并发安全。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需用mutex或无锁算法实现，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)期望</p><p><strong>应用说明</strong>：高并发数据库、缓存、分布式系统等。</p><hr><h3 id="案例4：Redis底层跳表"><a href="#案例4：Redis底层跳表" class="headerlink" title="案例4：Redis底层跳表"></a>案例4：Redis底层跳表</h3><p><strong>题意</strong>：分析Redis有序集合底层跳表实现。</p><p><strong>思路</strong>：Redis用跳表实现zset，支持范围查找、排名、分数区间等。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 参考Redis源码，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)期望</p><p><strong>应用说明</strong>：分布式缓存、排行榜、区间统计等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>跳表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>B树与B+树详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11_B%E6%A0%91%E4%B8%8EB+%E6%A0%91%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11_B%E6%A0%91%E4%B8%8EB+%E6%A0%91%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="B树与B-树详解与C-实现"><a href="#B树与B-树详解与C-实现" class="headerlink" title="B树与B+树详解与C++实现"></a>B树与B+树详解与C++实现</h1><h2 id="1-B树-B-树概念（详细）"><a href="#1-B树-B-树概念（详细）" class="headerlink" title="1. B树&#x2F;B+树概念（详细）"></a>1. B树&#x2F;B+树概念（详细）</h2><p>B树（Balanced Tree）和B+树是多路平衡查找树，广泛用于数据库和文件系统索引。</p><ul><li><strong>B树</strong>：每个节点可有多个子节点和关键字，所有叶子在同一层，插入&#x2F;删除时分裂与合并节点。</li><li><strong>B+树</strong>：B树的变种，所有数据只存储在叶子节点，叶子节点通过链表相连，便于区间查询。</li><li><strong>节点结构</strong>：包含若干关键字和子指针。</li><li><strong>分裂与合并</strong>：节点满时分裂，空时合并，保持平衡。</li><li><strong>磁盘友好</strong>：节点大，减少IO次数，适合大规模外存。</li><li><strong>优点</strong>：<ul><li>高度平衡，查找&#x2F;插入&#x2F;删除O(log n)。</li><li>适合磁盘&#x2F;SSD等块存储。</li></ul></li><li><strong>缺点</strong>：<ul><li>实现复杂。</li><li>不适合频繁内存操作。</li></ul></li><li><strong>B树与B+树区别</strong>：B+树所有数据在叶子，非叶节点只做索引，叶子链表便于区间查询。</li></ul><h2 id="2-C-实现与常用操作（结构-伪代码为主）"><a href="#2-C-实现与常用操作（结构-伪代码为主）" class="headerlink" title="2. C++实现与常用操作（结构&#x2F;伪代码为主）"></a>2. C++实现与常用操作（结构&#x2F;伪代码为主）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// B树节点结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BTreeNode</span> &#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; keys;<br>    std::vector&lt;BTreeNode*&gt; children;<br>    <span class="hljs-type">bool</span> isLeaf;<br>    <span class="hljs-built_in">BTreeNode</span>(<span class="hljs-type">bool</span> leaf) : <span class="hljs-built_in">isLeaf</span>(leaf) &#123;&#125;<br>&#125;;<br><span class="hljs-comment">// B+树节点结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BPlusTreeNode</span> &#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; keys;<br>    std::vector&lt;BPlusTreeNode*&gt; children;<br>    BPlusTreeNode* next; <span class="hljs-comment">// 叶子链表</span><br>    <span class="hljs-type">bool</span> isLeaf;<br>    <span class="hljs-built_in">BPlusTreeNode</span>(<span class="hljs-type">bool</span> leaf) : <span class="hljs-built_in">isLeaf</span>(leaf), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-comment">// 具体插入/查找/分裂等操作略，实际工程多用库实现</span><br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>查找&#x2F;插入&#x2F;删除：O(log n)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>数据库索引、文件系统、SSD存储、区间查询、大规模外存数据。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>节点分裂&#x2F;合并复杂</strong>：插入&#x2F;删除时需递归分裂或合并节点。</li><li><strong>磁盘IO优化</strong>：节点大小需与磁盘块对齐，减少IO。</li><li><strong>B树与B+树遍历差异</strong>：B+树叶子链表便于区间遍历，B树需递归。</li><li><strong>多路分支指针维护</strong>：插入&#x2F;删除时多指针同步，易出错。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：数据库索引实现"><a href="#案例1：数据库索引实现" class="headerlink" title="案例1：数据库索引实现"></a>案例1：数据库索引实现</h3><p><strong>题意</strong>：分析数据库如何用B+树实现高效索引。</p><p><strong>思路</strong>：B+树叶子节点存储所有数据，非叶节点做索引，便于范围查找。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 见正文2 B+树节点结构</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：数据库、文件系统、SSD索引等。</p><hr><h3 id="案例2：区间查找与范围查询"><a href="#案例2：区间查找与范围查询" class="headerlink" title="案例2：区间查找与范围查询"></a>案例2：区间查找与范围查询</h3><p><strong>题意</strong>：支持区间[l, r]的高效查找。</p><p><strong>思路</strong>：B+树叶子链表顺序遍历，B树需递归遍历。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需实现B+树叶子链表遍历，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n + k)</p><p><strong>应用说明</strong>：数据库区间查询、文件系统、分布式存储等。</p><hr><h3 id="案例3：磁盘IO优化"><a href="#案例3：磁盘IO优化" class="headerlink" title="案例3：磁盘IO优化"></a>案例3：磁盘IO优化</h3><p><strong>题意</strong>：分析B树&#x2F;B+树如何减少磁盘IO。</p><p><strong>思路</strong>：节点大小与磁盘块对齐，减少树高和访问次数。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 结构设计与块对齐，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：大规模外存索引、SSD优化、数据库等。</p><hr><h3 id="案例4：B-树范围查询与排名"><a href="#案例4：B-树范围查询与排名" class="headerlink" title="案例4：B+树范围查询与排名"></a>案例4：B+树范围查询与排名</h3><p><strong>题意</strong>：支持区间范围查询和元素排名。</p><p><strong>思路</strong>：B+树叶子链表顺序遍历，节点维护排名信息。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需实现带排名的B+树，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n + k)</p><p><strong>应用说明</strong>：数据库、搜索引擎、分布式系统等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>B树</tag>
      
      <tag>B+树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树详解与C++实现</title>
    <link href="/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12_%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12_%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树详解与C-实现"><a href="#红黑树详解与C-实现" class="headerlink" title="红黑树详解与C++实现"></a>红黑树详解与C++实现</h1><h2 id="1-红黑树概念（详细）"><a href="#1-红黑树概念（详细）" class="headerlink" title="1. 红黑树概念（详细）"></a>1. 红黑树概念（详细）</h2><p>红黑树（Red-Black Tree）是一种自平衡二叉搜索树，通过节点颜色和旋转操作保证树高对数级。</p><ul><li><strong>红黑性质</strong>：<ol><li>每个节点非红即黑。</li><li>根节点为黑。</li><li>叶子（空节点）为黑。</li><li>红节点的子节点必须为黑。</li><li>任意节点到叶子的所有路径黑节点数相同。</li></ol></li><li><strong>节点结构</strong>：包含值、颜色、左右子指针、父指针。</li><li><strong>插入&#x2F;删除&#x2F;旋转</strong>：插入后通过变色和旋转恢复红黑性质，删除同理。</li><li><strong>平衡性</strong>：最长路径不超过最短路径2倍，保证O(log n)操作。</li><li><strong>优点</strong>：<ul><li>查找、插入、删除均为O(log n)。</li><li>性能稳定，最坏情况有保证。</li></ul></li><li><strong>缺点</strong>：<ul><li>实现复杂，旋转和变色逻辑繁琐。</li><li>常数开销略大于AVL树。</li></ul></li></ul><h2 id="2-C-实现与常用操作（结构-伪代码为主）"><a href="#2-C-实现与常用操作（结构-伪代码为主）" class="headerlink" title="2. C++实现与常用操作（结构&#x2F;伪代码为主）"></a>2. C++实现与常用操作（结构&#x2F;伪代码为主）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; RED, BLACK &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RBNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    Color color;<br>    RBNode *left, *right, *parent;<br>    <span class="hljs-built_in">RBNode</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">color</span>(RED), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">parent</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-comment">// 插入、旋转、变色等操作较复杂，实际工程多用STL map/set或成熟库</span><br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>查找&#x2F;插入&#x2F;删除：O(log n)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>STL map&#x2F;set底层、数据库索引、操作系统调度、内存管理等。</li></ul><h2 id="5-深入扩展与常见陷阱"><a href="#5-深入扩展与常见陷阱" class="headerlink" title="5. 深入扩展与常见陷阱"></a>5. 深入扩展与常见陷阱</h2><ul><li><strong>插入&#x2F;删除修正复杂</strong>：需多步旋转和变色，易出错。</li><li><strong>父指针维护</strong>：插入&#x2F;删除时父指针需同步更新。</li><li><strong>红黑性质破坏</strong>：插入&#x2F;删除后需递归修正红黑性质。</li><li><strong>区间操作实现难度大</strong>：如区间第k大、区间和等需额外维护信息。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：红黑树插入与删除"><a href="#案例1：红黑树插入与删除" class="headerlink" title="案例1：红黑树插入与删除"></a>案例1：红黑树插入与删除</h3><p><strong>题意</strong>：实现红黑树的插入和删除操作。</p><p><strong>思路</strong>：插入为红，父红需旋转&#x2F;变色，删除需修正红黑性质。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 见正文2 伪代码</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：STL map&#x2F;set、数据库索引、内存管理等。</p><hr><h3 id="案例2：区间统计与排名"><a href="#案例2：区间统计与排名" class="headerlink" title="案例2：区间统计与排名"></a>案例2：区间统计与排名</h3><p><strong>题意</strong>：支持区间第k大、区间和等操作。</p><p><strong>思路</strong>：红黑树节点维护size&#x2F;sum等信息，递归统计。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需实现带size/sum域的红黑树，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：在线排名、区间统计、动态数据分析等。</p><hr><h3 id="案例3：STL-map-set底层实现"><a href="#案例3：STL-map-set底层实现" class="headerlink" title="案例3：STL map&#x2F;set底层实现"></a>案例3：STL map&#x2F;set底层实现</h3><p><strong>题意</strong>：分析STL map&#x2F;set底层为何选用红黑树。</p><p><strong>思路</strong>：红黑树性能稳定，最坏O(log n)，插入&#x2F;删除&#x2F;查找均衡。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// STL源码分析，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：C++标准库、工程开发、数据库等。</p><hr><h3 id="案例4：内存管理与区间分配"><a href="#案例4：内存管理与区间分配" class="headerlink" title="案例4：内存管理与区间分配"></a>案例4：内存管理与区间分配</h3><p><strong>题意</strong>：用红黑树管理内存区间分配与回收。</p><p><strong>思路</strong>：每个节点存区间，插入&#x2F;删除时合并或分割区间。</p><p><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需实现区间合并/分割的红黑树，略</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)</p><p><strong>应用说明</strong>：操作系统内存管理、数据库空间分配等。</p><hr><p>如需更多数据结构专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>平衡树</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL语法与场景详解</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/MySQL%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%9C%BA%E6%99%AF%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/MySQL%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%9C%BA%E6%99%AF%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL语法与场景详解"><a href="#MySQL语法与场景详解" class="headerlink" title="MySQL语法与场景详解"></a>MySQL语法与场景详解</h1><p>本文系统梳理 MySQL 进阶语法与特定业务场景下的典型用法，适合进阶查阅和实战参考。</p><hr><h2 id="一、进阶DDL（数据定义）"><a href="#一、进阶DDL（数据定义）" class="headerlink" title="一、进阶DDL（数据定义）"></a>一、进阶DDL（数据定义）</h2><h3 id="1-分区表"><a href="#1-分区表" class="headerlink" title="1. 分区表"></a>1. 分区表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> orders (<br>  id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>  user_id <span class="hljs-type">INT</span>,<br>  order_time DATETIME<br>) <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (<span class="hljs-keyword">YEAR</span>(order_time)) (<br>  <span class="hljs-keyword">PARTITION</span> p2023 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2024</span>),<br>  <span class="hljs-keyword">PARTITION</span> p2024 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2025</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：大表按时间分区，提升查询和归档效率。</li></ul><h3 id="2-外键约束"><a href="#2-外键约束" class="headerlink" title="2. 外键约束"></a>2. 外键约束</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> users (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span><br>);<br><span class="hljs-keyword">CREATE TABLE</span> orders (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>  user_id <span class="hljs-type">INT</span>,<br>  <span class="hljs-keyword">FOREIGN KEY</span> (user_id) <span class="hljs-keyword">REFERENCES</span> users(id)<br>);<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：保证数据一致性，如订单必须有合法用户。</li></ul><h3 id="3-视图"><a href="#3-视图" class="headerlink" title="3. 视图"></a>3. 视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> active_users <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> status<span class="hljs-operator">=</span><span class="hljs-string">&#x27;active&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：简化复杂查询、权限隔离。</li></ul><h3 id="4-触发器"><a href="#4-触发器" class="headerlink" title="4. 触发器"></a>4. 触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> before_insert_order<br>BEFORE <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> orders<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">SET</span> NEW.create_time <span class="hljs-operator">=</span> NOW();<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：自动填充字段、审计、数据同步。</li></ul><h3 id="5-存储过程与函数"><a href="#5-存储过程与函数" class="headerlink" title="5. 存储过程与函数"></a>5. 存储过程与函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> add_user(<span class="hljs-keyword">IN</span> uname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>))<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-keyword">INSERT INTO</span> users(name) <span class="hljs-keyword">VALUES</span>(uname);<br><span class="hljs-keyword">END</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><br>DELIMITER ;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> get_order_count(uid <span class="hljs-type">INT</span>) <span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span><br><span class="hljs-keyword">RETURN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> user_id<span class="hljs-operator">=</span>uid);<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：封装业务逻辑、批量处理、复杂计算。</li></ul><h3 id="6-事件调度器"><a href="#6-事件调度器" class="headerlink" title="6. 事件调度器"></a>6. 事件调度器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> EVENT archive_orders<br><span class="hljs-keyword">ON</span> SCHEDULE <span class="hljs-keyword">EVERY</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DAY</span><br>DO<br>  <span class="hljs-keyword">INSERT INTO</span> orders_archive <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> order_time <span class="hljs-operator">&lt;</span> CURDATE();<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：定时归档、自动清理。</li></ul><h3 id="7-用户与权限"><a href="#7-用户与权限" class="headerlink" title="7. 用户与权限"></a>7. 用户与权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;report&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ON</span> db.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;report&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> db.orders <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;report&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：权限最小化、数据安全。</li></ul><hr><h2 id="二、复杂DML与查询"><a href="#二、复杂DML与查询" class="headerlink" title="二、复杂DML与查询"></a>二、复杂DML与查询</h2><h3 id="1-多表插入"><a href="#1-多表插入" class="headerlink" title="1. 多表插入"></a>1. 多表插入</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> orders (id, user_id) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-number">100</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">101</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：批量导入、数据迁移。</li></ul><h3 id="2-批量更新"><a href="#2-批量更新" class="headerlink" title="2. 批量更新"></a>2. 批量更新</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">SET</span> status<span class="hljs-operator">=</span><span class="hljs-string">&#x27;inactive&#x27;</span> <span class="hljs-keyword">WHERE</span> last_login <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2024-01-01&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：批量冻结、批量修正。</li></ul><h3 id="3-子查询与联合查询"><a href="#3-子查询与联合查询" class="headerlink" title="3. 子查询与联合查询"></a>3. 子查询与联合查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> status<span class="hljs-operator">=</span><span class="hljs-string">&#x27;active&#x27;</span>);<br><span class="hljs-keyword">SELECT</span> u.name, o.id <span class="hljs-keyword">FROM</span> users u <span class="hljs-keyword">JOIN</span> orders o <span class="hljs-keyword">ON</span> u.id <span class="hljs-operator">=</span> o.user_id;<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：复杂筛选、数据整合。</li></ul><h3 id="4-窗口函数"><a href="#4-窗口函数" class="headerlink" title="4. 窗口函数"></a>4. 窗口函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id, score, <span class="hljs-built_in">RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> r <span class="hljs-keyword">FROM</span> exam;<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：排行榜、分组内排序、累计统计。</li></ul><h3 id="5-分组统计与条件聚合"><a href="#5-分组统计与条件聚合" class="headerlink" title="5. 分组统计与条件聚合"></a>5. 分组统计与条件聚合</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> cnt, <span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">AS</span> total <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">HAVING</span> cnt <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：用户活跃度、销售统计。</li></ul><hr><h2 id="三、事务与锁的细节"><a href="#三、事务与锁的细节" class="headerlink" title="三、事务与锁的细节"></a>三、事务与锁的细节</h2><h3 id="1-事务隔离级别"><a href="#1-事务隔离级别" class="headerlink" title="1. 事务隔离级别"></a>1. 事务隔离级别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：防止脏读、不可重复读、幻读。</li></ul><h3 id="2-显式事务控制"><a href="#2-显式事务控制" class="headerlink" title="2. 显式事务控制"></a>2. 显式事务控制</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：转账、订单支付。</li></ul><h3 id="3-行锁与表锁"><a href="#3-行锁与表锁" class="headerlink" title="3. 行锁与表锁"></a>3. 行锁与表锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br>LOCK TABLES orders WRITE;<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：并发写入、数据一致性。</li></ul><hr><h2 id="四、优化与调优"><a href="#四、优化与调优" class="headerlink" title="四、优化与调优"></a>四、优化与调优</h2><h3 id="1-索引设计"><a href="#1-索引设计" class="headerlink" title="1. 索引设计"></a>1. 索引设计</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_user_time <span class="hljs-keyword">ON</span> orders(user_id, order_time <span class="hljs-keyword">DESC</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：高频查询、联合过滤。</li></ul><h3 id="2-执行计划分析"><a href="#2-执行计划分析" class="headerlink" title="2. 执行计划分析"></a>2. 执行计划分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> user_id<span class="hljs-operator">=</span><span class="hljs-number">100</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> order_time <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：SQL调优、索引命中。</li></ul><h3 id="3-慢查询日志"><a href="#3-慢查询日志" class="headerlink" title="3. 慢查询日志"></a>3. 慢查询日志</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> slow_query_log <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;slow_query_log%&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>场景</strong>：定位性能瓶颈。</li></ul><h3 id="4-分区、分库分表"><a href="#4-分区、分库分表" class="headerlink" title="4. 分区、分库分表"></a>4. 分区、分库分表</h3><ul><li><strong>分区</strong>：见前文DDL</li><li><strong>分库分表</strong>：通过中间件（如ShardingSphere、MyCat）或应用层实现。</li><li><strong>场景</strong>：大数据量、分布式扩展。</li></ul><hr><h2 id="五、特定场景示例"><a href="#五、特定场景示例" class="headerlink" title="五、特定场景示例"></a>五、特定场景示例</h2><h3 id="1-电商订单表设计"><a href="#1-电商订单表设计" class="headerlink" title="1. 电商订单表设计"></a>1. 电商订单表设计</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> orders (<br>  id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>  user_id <span class="hljs-type">INT</span>,<br>  product_id <span class="hljs-type">INT</span>,<br>  amount <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>),<br>  status ENUM(<span class="hljs-string">&#x27;pending&#x27;</span>,<span class="hljs-string">&#x27;paid&#x27;</span>,<span class="hljs-string">&#x27;shipped&#x27;</span>,<span class="hljs-string">&#x27;done&#x27;</span>,<span class="hljs-string">&#x27;closed&#x27;</span>),<br>  create_time DATETIME,<br>  INDEX idx_user_time(user_id, create_time)<br>) <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (<span class="hljs-keyword">YEAR</span>(create_time)) (<br>  <span class="hljs-keyword">PARTITION</span> p2023 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2024</span>),<br>  <span class="hljs-keyword">PARTITION</span> p2024 <span class="hljs-keyword">VALUES</span> LESS THAN (<span class="hljs-number">2025</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li><strong>说明</strong>：支持高并发、分区归档、状态流转。</li></ul><h3 id="2-日志归档与冷热分离"><a href="#2-日志归档与冷热分离" class="headerlink" title="2. 日志归档与冷热分离"></a>2. 日志归档与冷热分离</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> logs (<br>  id <span class="hljs-type">BIGINT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>  log_time DATETIME,<br>  content TEXT<br>) <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> (TO_DAYS(log_time)) (<br>  <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DAYS(<span class="hljs-string">&#x27;2024-01-01&#x27;</span>)),<br>  <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> LESS THAN (TO_DAYS(<span class="hljs-string">&#x27;2025-01-01&#x27;</span>))<br>);<br><span class="hljs-comment">-- 定期归档到历史表</span><br><span class="hljs-keyword">INSERT INTO</span> logs_history <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> logs <span class="hljs-keyword">WHERE</span> log_time <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2024-01-01&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><strong>说明</strong>：提升查询效率，便于数据治理。</li></ul><h3 id="3-排行榜与窗口函数"><a href="#3-排行榜与窗口函数" class="headerlink" title="3. 排行榜与窗口函数"></a>3. 排行榜与窗口函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> user_id, score, <span class="hljs-built_in">RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rank <span class="hljs-keyword">FROM</span> user_score;<br></code></pre></td></tr></table></figure><ul><li><strong>说明</strong>：高效实现实时排行榜。</li></ul><h3 id="4-分布式ID生成"><a href="#4-分布式ID生成" class="headerlink" title="4. 分布式ID生成"></a>4. 分布式ID生成</h3><ul><li><strong>方案</strong>：雪花算法（Snowflake）、UUID、数据库自增、Redis分布式ID。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- MySQL自增ID</span><br>id <span class="hljs-type">BIGINT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY KEY</span><br><span class="hljs-comment">-- UUID</span><br>id <span class="hljs-type">CHAR</span>(<span class="hljs-number">36</span>) <span class="hljs-keyword">PRIMARY KEY</span> <span class="hljs-keyword">DEFAULT</span> (UUID())<br></code></pre></td></tr></table></figure></li><li><strong>说明</strong>：保证全局唯一性，适合分布式系统。</li></ul><h3 id="5-数据脱敏与审计"><a href="#5-数据脱敏与审计" class="headerlink" title="5. 数据脱敏与审计"></a>5. 数据脱敏与审计</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 脱敏视图</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> v_user_masked <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> id, CONCAT(<span class="hljs-keyword">LEFT</span>(phone,<span class="hljs-number">3</span>),<span class="hljs-string">&#x27;****&#x27;</span>,<span class="hljs-keyword">RIGHT</span>(phone,<span class="hljs-number">4</span>)) <span class="hljs-keyword">AS</span> phone <span class="hljs-keyword">FROM</span> users;<br><span class="hljs-comment">-- 审计触发器</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> audit_update<br>AFTER <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> users<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-keyword">INSERT INTO</span> audit_log(user_id, old_val, new_val, op_time) <span class="hljs-keyword">VALUES</span> (OLD.id, OLD.name, NEW.name, NOW());<br></code></pre></td></tr></table></figure><ul><li><strong>说明</strong>：保护隐私、合规审计。</li></ul><h3 id="6-分布式锁实现（进阶扩展）"><a href="#6-分布式锁实现（进阶扩展）" class="headerlink" title="6. 分布式锁实现（进阶扩展）"></a>6. 分布式锁实现（进阶扩展）</h3><ul><li><strong>原理详解</strong>：分布式锁需满足互斥性、可重入性、容错性、避免死锁、超时自动释放等特性。</li><li><strong>常见问题</strong>：<ul><li>死锁与锁遗失：如客户端异常未释放锁，需设置超时。</li><li>锁粒度设计：锁粒度过大影响并发，过小增加复杂度。</li><li>性能瓶颈：数据库锁适合低QPS场景，高并发建议用Redis等内存型方案。</li></ul></li><li><strong>MySQL方案进阶</strong>：<ul><li><code>GET_LOCK</code>为全局锁，适合小规模场景，支持超时与自动释放。</li><li>表锁方案可结合唯一索引、乐观锁字段（如version）防止并发写入。</li><li>可结合应用层唯一请求ID防止重复提交。</li></ul></li><li><strong>分布式系统结合</strong>：<ul><li>推荐Redis RedLock、ZooKeeper临时节点等高可用方案。</li><li>MySQL锁适合对一致性要求高、并发量不大、已有MySQL依赖的场景。</li></ul></li><li><strong>业务实战案例</strong>：<ul><li>秒杀库存扣减：先加分布式锁，后查库存并扣减，最后释放锁。</li><li>定时任务幂等：多节点定时任务调度时，抢占分布式锁保证单节点执行。</li></ul></li><li><strong>注意事项</strong>：<ul><li>锁超时需合理设置，防止死锁或误释放。</li><li>业务操作应尽量短小，减少锁持有时间。</li></ul></li></ul><h3 id="7-全局唯一ID生成（进阶扩展）"><a href="#7-全局唯一ID生成（进阶扩展）" class="headerlink" title="7. 全局唯一ID生成（进阶扩展）"></a>7. 全局唯一ID生成（进阶扩展）</h3><ul><li><strong>原理详解</strong>：全局唯一ID需保证分布式环境下唯一、趋势递增、性能高、无单点。</li><li><strong>常见问题</strong>：<ul><li>UUID无序，影响索引性能；自增ID有单点瓶颈；雪花算法需时钟同步。</li><li>号段模式需预分配，存在ID浪费风险。</li></ul></li><li><strong>最佳实践</strong>：<ul><li>雪花算法适合高并发、分布式场景，ID有序且高性能。</li><li>业务分库分表时，推荐每库&#x2F;每表分配不同ID段或workerId。</li><li>重要业务建议ID生成服务高可用部署，防止单点。</li></ul></li><li><strong>MySQL与分布式结合</strong>：<ul><li>MySQL自增ID适合单库单表，分布式建议配合号段表或外部ID服务。</li><li>号段表可用作本地缓存批量分配，减少数据库压力。</li></ul></li><li><strong>业务实战案例</strong>：<ul><li>电商订单号：可用雪花算法+业务前缀+时间戳拼接。</li><li>日志追踪ID：分布式链路追踪需全局唯一且可溯源。</li></ul></li><li><strong>性能对比</strong>：<ul><li>雪花算法&gt;号段模式&gt;MySQL自增&gt;UUID（按写入性能排序）。</li></ul></li></ul><h3 id="8-数据脱敏与合规（进阶扩展）"><a href="#8-数据脱敏与合规（进阶扩展）" class="headerlink" title="8. 数据脱敏与合规（进阶扩展）"></a>8. 数据脱敏与合规（进阶扩展）</h3><ul><li><strong>原理详解</strong>：数据脱敏分为静态脱敏（存储前处理）和动态脱敏（查询时处理），合规需满足最小权限、可追溯、加密存储等要求。</li><li><strong>常见问题</strong>：<ul><li>脱敏不彻底：如仅做部分掩码，仍可被还原。</li><li>性能影响：动态脱敏&#x2F;加密字段查询性能下降。</li><li>合规盲区：日志、备份、缓存等环节易被忽视。</li></ul></li><li><strong>最佳实践</strong>：<ul><li>敏感字段加密存储，密钥分级管理。</li><li>通过视图&#x2F;中间件实现动态脱敏，按用户角色授权访问。</li><li>审计日志全链路记录敏感数据操作。</li></ul></li><li><strong>MySQL与分布式结合</strong>：<ul><li>分布式环境下需统一脱敏策略，防止数据在同步&#x2F;备份时泄露。</li><li>可结合数据网关、API层做统一脱敏。</li></ul></li><li><strong>业务实战案例</strong>：<ul><li>金融行业：银行卡号、身份证号存储加密，查询脱敏展示。</li><li>医疗行业：患者信息分级脱敏，医生&#x2F;管理员不同权限展示。</li></ul></li><li><strong>注意事项</strong>：<ul><li>密钥管理安全性至关重要。</li><li>定期审计和合规检查，防止数据泄漏。</li></ul></li></ul><hr><h2 id="六、高可用架构（High-Availability-Architecture）"><a href="#六、高可用架构（High-Availability-Architecture）" class="headerlink" title="六、高可用架构（High Availability Architecture）"></a>六、高可用架构（High Availability Architecture）</h2><h3 id="概念与目的"><a href="#概念与目的" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>高可用架构保障数据库服务持续可用，防止单点故障，支持自动故障切换。</li></ul><h3 id="典型方案"><a href="#典型方案" class="headerlink" title="典型方案"></a>典型方案</h3><ol><li><strong>主从复制（Master-Slave Replication）</strong><ul><li>主库写、从库读，提升读性能，支持手动&#x2F;自动切换。</li><li>配置：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 主库my.cnf</span><br><span class="hljs-attr">server-id</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">log-bin</span>=mysql-bin<br><span class="hljs-comment"># 从库my.cnf</span><br><span class="hljs-attr">server-id</span>=<span class="hljs-number">2</span><br><span class="hljs-attr">relay-log</span>=relay-bin<br><span class="hljs-comment"># 从库执行</span><br>CHANGE MASTER TO <span class="hljs-attr">MASTER_HOST</span>=<span class="hljs-string">&#x27;主库IP&#x27;</span>, MASTER_USER=<span class="hljs-string">&#x27;repl&#x27;</span>, MASTER_PASSWORD=<span class="hljs-string">&#x27;xxx&#x27;</span>, MASTER_LOG_FILE=<span class="hljs-string">&#x27;mysql-bin.000001&#x27;</span>, MASTER_LOG_POS=xxx<span class="hljs-comment">;</span><br>START SLAVE<span class="hljs-comment">;</span><br>SHOW SLAVE STATUS\G<br></code></pre></td></tr></table></figure></li><li><strong>场景</strong>：读写分离、备份、灾备。</li></ul></li><li><strong>MGR（Group Replication）&#x2F;InnoDB Cluster</strong><ul><li>多主自动选主，支持自动故障切换。</li><li>适合高可用和高一致性场景。</li></ul></li><li><strong>ProxySQL&#x2F;Keepalived+VIP</strong><ul><li>通过中间件实现读写分离、负载均衡、自动切换。</li><li><strong>场景</strong>：大规模集群、业务不中断。</li></ul></li></ol><hr><h2 id="七、分布式事务（Distributed-Transaction）"><a href="#七、分布式事务（Distributed-Transaction）" class="headerlink" title="七、分布式事务（Distributed Transaction）"></a>七、分布式事务（Distributed Transaction）</h2><h3 id="概念与目的-1"><a href="#概念与目的-1" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>分布式事务保障多库&#x2F;多服务间数据一致性。</li><li>典型场景：订单、支付、库存等跨库操作。</li></ul><h3 id="典型方案-1"><a href="#典型方案-1" class="headerlink" title="典型方案"></a>典型方案</h3><ol><li><strong>XA 两阶段提交</strong><ul><li>MySQL原生支持XA协议。</li><li>语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">XA <span class="hljs-keyword">START</span> <span class="hljs-string">&#x27;xid&#x27;</span>;<br><span class="hljs-keyword">INSERT INTO</span> ...;<br>XA <span class="hljs-keyword">END</span> <span class="hljs-string">&#x27;xid&#x27;</span>;<br>XA <span class="hljs-keyword">PREPARE</span> <span class="hljs-string">&#x27;xid&#x27;</span>;<br><span class="hljs-comment">-- 所有分支都PREPARE后</span><br>XA <span class="hljs-keyword">COMMIT</span> <span class="hljs-string">&#x27;xid&#x27;</span>;<br><span class="hljs-comment">-- 或 XA ROLLBACK &#x27;xid&#x27;;</span><br></code></pre></td></tr></table></figure></li><li><strong>场景</strong>：强一致性要求的分布式事务。</li></ul></li><li><strong>TCC（Try-Confirm-Cancel）&#x2F;消息最终一致性</strong><ul><li>通过业务分段、补偿、消息队列等实现最终一致。</li><li>适合高性能、可容忍短暂不一致的业务。</li></ul></li></ol><hr><h2 id="八、数据同步（Data-Synchronization）"><a href="#八、数据同步（Data-Synchronization）" class="headerlink" title="八、数据同步（Data Synchronization）"></a>八、数据同步（Data Synchronization）</h2><h3 id="概念与目的-2"><a href="#概念与目的-2" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>数据同步保障多库&#x2F;多系统间数据实时或准实时一致。</li><li>典型场景：多活、数据迁移、数据仓库、异构系统集成。</li></ul><h3 id="典型方案-2"><a href="#典型方案-2" class="headerlink" title="典型方案"></a>典型方案</h3><ol><li><strong>主从复制（异步&#x2F;半同步&#x2F;全同步）</strong><ul><li>通过binlog实现数据同步。</li><li>配置见高可用架构。</li></ul></li><li><strong>数据订阅与实时同步</strong><ul><li><strong>Canal</strong>：基于binlog解析，支持MySQL到ES&#x2F;Kafka等。</li><li><strong>Debezium</strong>：支持多种数据库的变更订阅。</li><li><strong>DataX</strong>：批量数据同步工具，适合离线迁移。</li><li><strong>配置示例</strong>：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;reader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mysqlreader&quot;</span><span class="hljs-punctuation">,</span> ...<span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;writer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mysqlwriter&quot;</span><span class="hljs-punctuation">,</span> ...<span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;setting&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>...<span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><strong>跨地域多活&#x2F;多中心同步</strong><ul><li>结合MGR、GTID、全局时钟等方案。</li></ul></li></ol><h3 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h3><ul><li>适用于高可用、灾备、数据集成、数据仓库等多种场景。</li></ul><hr><p>如需更深入的专题（如分布式锁、全局唯一ID、数据脱敏合规等），欢迎留言补充！ </p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常用库用法</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/Python%E5%B8%B8%E7%94%A8%E5%BA%93%E7%94%A8%E6%B3%95/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/Python%E5%B8%B8%E7%94%A8%E5%BA%93%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Python常用库用法"><a href="#Python常用库用法" class="headerlink" title="Python常用库用法"></a>Python常用库用法</h1><p>本文总结 Python 常用标准库与第三方库的典型用法，涵盖文件操作、数据处理、网络请求、科学计算、可视化等，适合查阅和进阶学习。</p><h2 id="1-os-——-操作系统接口"><a href="#1-os-——-操作系统接口" class="headerlink" title="1. os —— 操作系统接口"></a>1. os —— 操作系统接口</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-built_in">print</span>(os.getcwd())  <span class="hljs-comment"># 获取当前工作目录</span><br>os.listdir(<span class="hljs-string">&#x27;.&#x27;</span>)      <span class="hljs-comment"># 列出目录下文件</span><br>os.makedirs(<span class="hljs-string">&#x27;testdir&#x27;</span>, exist_ok=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 创建目录</span><br>os.remove(<span class="hljs-string">&#x27;test.txt&#x27;</span>)  <span class="hljs-comment"># 删除文件</span><br></code></pre></td></tr></table></figure><h2 id="2-sys-——-解释器相关"><a href="#2-sys-——-解释器相关" class="headerlink" title="2. sys —— 解释器相关"></a>2. sys —— 解释器相关</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-built_in">print</span>(sys.version)  <span class="hljs-comment"># Python 版本</span><br><span class="hljs-built_in">print</span>(sys.argv)     <span class="hljs-comment"># 命令行参数</span><br>sys.exit(<span class="hljs-number">0</span>)         <span class="hljs-comment"># 退出程序</span><br></code></pre></td></tr></table></figure><h2 id="3-math-——-数学运算"><a href="#3-math-——-数学运算" class="headerlink" title="3. math —— 数学运算"></a>3. math —— 数学运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-built_in">print</span>(math.pi)<br><span class="hljs-built_in">print</span>(math.sqrt(<span class="hljs-number">16</span>))<br><span class="hljs-built_in">print</span>(math.sin(math.radians(<span class="hljs-number">30</span>)))<br></code></pre></td></tr></table></figure><h2 id="4-random-——-随机数"><a href="#4-random-——-随机数" class="headerlink" title="4. random —— 随机数"></a>4. random —— 随机数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-built_in">print</span>(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(random.choice([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]))<br>random.shuffle([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><h2 id="5-datetime-——-日期与时间"><a href="#5-datetime-——-日期与时间" class="headerlink" title="5. datetime —— 日期与时间"></a>5. datetime —— 日期与时间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta<br>now = datetime.now()<br><span class="hljs-built_in">print</span>(now.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>))<br><span class="hljs-built_in">print</span>((now + timedelta(days=<span class="hljs-number">1</span>)).date())<br></code></pre></td></tr></table></figure><h2 id="6-json-——-JSON-处理"><a href="#6-json-——-JSON-处理" class="headerlink" title="6. json —— JSON 处理"></a>6. json —— JSON 处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>data = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>&#125;<br>s = json.dumps(data)<br><span class="hljs-built_in">print</span>(json.loads(s))<br></code></pre></td></tr></table></figure><h2 id="7-re-——-正则表达式"><a href="#7-re-——-正则表达式" class="headerlink" title="7. re —— 正则表达式"></a>7. re —— 正则表达式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>m = re.<span class="hljs-keyword">match</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>, <span class="hljs-string">&#x27;123abc&#x27;</span>)<br><span class="hljs-built_in">print</span>(m.group())<br>res = re.findall(<span class="hljs-string">r&#x27;\w+&#x27;</span>, <span class="hljs-string">&#x27;hello world!&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h2 id="8-collections-——-容器数据类型"><a href="#8-collections-——-容器数据类型" class="headerlink" title="8. collections —— 容器数据类型"></a>8. collections —— 容器数据类型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter, defaultdict, namedtuple<br>c = Counter(<span class="hljs-string">&#x27;aabbcc&#x27;</span>)<br><span class="hljs-built_in">print</span>(c)<br>d = defaultdict(<span class="hljs-built_in">int</span>)<br>d[<span class="hljs-string">&#x27;x&#x27;</span>] += <span class="hljs-number">1</span><br>Point = namedtuple(<span class="hljs-string">&#x27;Point&#x27;</span>, [<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>])<br>p = Point(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h2 id="9-itertools-——-迭代器工具"><a href="#9-itertools-——-迭代器工具" class="headerlink" title="9. itertools —— 迭代器工具"></a>9. itertools —— 迭代器工具</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> itertools.permutations([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]):<br>    <span class="hljs-built_in">print</span>(x)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> itertools.combinations([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><h2 id="10-logging-——-日志"><a href="#10-logging-——-日志" class="headerlink" title="10. logging —— 日志"></a>10. logging —— 日志</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.basicConfig(level=logging.INFO)<br>logging.info(<span class="hljs-string">&#x27;Info message&#x27;</span>)<br>logging.error(<span class="hljs-string">&#x27;Error message&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="11-requests-——-网络请求（第三方库）"><a href="#11-requests-——-网络请求（第三方库）" class="headerlink" title="11. requests —— 网络请求（第三方库）"></a>11. requests —— 网络请求（第三方库）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>r = requests.get(<span class="hljs-string">&#x27;https://httpbin.org/get&#x27;</span>)<br><span class="hljs-built_in">print</span>(r.status_code)<br><span class="hljs-built_in">print</span>(r.json())<br></code></pre></td></tr></table></figure><h2 id="12-pandas-——-数据分析（第三方库）"><a href="#12-pandas-——-数据分析（第三方库）" class="headerlink" title="12. pandas —— 数据分析（第三方库）"></a>12. pandas —— 数据分析（第三方库）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-string">&#x27;b&#x27;</span>: [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]&#125;)<br><span class="hljs-built_in">print</span>(df.head())<br><span class="hljs-built_in">print</span>(df[<span class="hljs-string">&#x27;a&#x27;</span>].mean())<br></code></pre></td></tr></table></figure><h2 id="13-numpy-——-科学计算（第三方库）"><a href="#13-numpy-——-科学计算（第三方库）" class="headerlink" title="13. numpy —— 科学计算（第三方库）"></a>13. numpy —— 科学计算（第三方库）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(a.mean())<br><span class="hljs-built_in">print</span>(np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>))<br></code></pre></td></tr></table></figure><h2 id="14-matplotlib-——-可视化（第三方库）"><a href="#14-matplotlib-——-可视化（第三方库）" class="headerlink" title="14. matplotlib —— 可视化（第三方库）"></a>14. matplotlib —— 可视化（第三方库）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.plot([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])<br>plt.title(<span class="hljs-string">&#x27;Line Chart&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><hr><p>如需更深入的库用法（如爬虫、Web开发、机器学习等），欢迎留言补充！ </p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>标准库</tag>
      
      <tag>第三方库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python语法详解</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/Python%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/Python%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Python语法详解"><a href="#Python语法详解" class="headerlink" title="Python语法详解"></a>Python语法详解</h1><p>本文系统梳理 Python 常用语法，涵盖基础语法、数据类型、流程控制、函数、面向对象、模块、文件操作、异常处理、进阶特性等，适合进阶学习与查阅。</p><h2 id="1-基础语法与数据类型"><a href="#1-基础语法与数据类型" class="headerlink" title="1. 基础语法与数据类型"></a>1. 基础语法与数据类型</h2><h3 id="输出与输入"><a href="#输出与输入" class="headerlink" title="输出与输入"></a>输出与输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入姓名：&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><ul><li>数字：<code>int</code>, <code>float</code>, <code>complex</code></li><li>字符串：<code>str</code></li><li>布尔：<code>bool</code></li><li>列表：<code>list</code></li><li>元组：<code>tuple</code></li><li>集合：<code>set</code></li><li>字典：<code>dict</code></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;123&quot;</span>)<br><span class="hljs-built_in">str</span>(<span class="hljs-number">123</span>)<br><span class="hljs-built_in">list</span>(<span class="hljs-string">&quot;abc&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h2><ul><li>算术运算：<code>+ - * / // % **</code></li><li>比较运算：<code>== != &gt; &lt; &gt;= &lt;=</code></li><li>逻辑运算：<code>and or not</code></li><li>成员运算：<code>in not in</code></li><li>身份运算：<code>is is not</code></li></ul><h2 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3. 流程控制"></a>3. 流程控制</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;成年人&quot;</span>)<br><span class="hljs-keyword">elif</span> age &gt; <span class="hljs-number">12</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;青少年&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;儿童&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><br><span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>    n -= <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><h3 id="break-continue-else"><a href="#break-continue-else" class="headerlink" title="break&#x2F;continue&#x2F;else"></a>break&#x2F;continue&#x2F;else</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;循环正常结束&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4. 函数"></a>4. 函数</h2><h3 id="定义与调用"><a href="#定义与调用" class="headerlink" title="定义与调用"></a>定义与调用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">*args, **kwargs</span>):<br>    <span class="hljs-built_in">print</span>(args, kwargs)<br></code></pre></td></tr></table></figure><h3 id="匿名函数（lambda）"><a href="#匿名函数（lambda）" class="headerlink" title="匿名函数（lambda）"></a>匿名函数（lambda）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-keyword">lambda</span> x: x * x<br><span class="hljs-built_in">print</span>(f(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> n * factorial(n-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="5-数据结构"><a href="#5-数据结构" class="headerlink" title="5. 数据结构"></a>5. 数据结构</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>lst.append(<span class="hljs-number">4</span>)<br>lst[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span><br>lst2 = lst[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tpl = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;<br>d[<span class="hljs-string">&quot;score&quot;</span>] = <span class="hljs-number">90</span><br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items():<br>    <span class="hljs-built_in">print</span>(k, v)<br></code></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>s.add(<span class="hljs-number">4</span>)<br>s.remove(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h2 id="6-字符串操作"><a href="#6-字符串操作" class="headerlink" title="6. 字符串操作"></a>6. 字符串操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;hello world&quot;</span><br><span class="hljs-built_in">print</span>(s.upper())<br><span class="hljs-built_in">print</span>(s.replace(<span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>))<br><span class="hljs-built_in">print</span>(s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span>(s.split())<br></code></pre></td></tr></table></figure><h2 id="7-文件操作"><a href="#7-文件操作" class="headerlink" title="7. 文件操作"></a>7. 文件操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&quot;Hello, file!&quot;</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    content = f.read()<br>    <span class="hljs-built_in">print</span>(content)<br></code></pre></td></tr></table></figure><h2 id="8-异常处理"><a href="#8-异常处理" class="headerlink" title="8. 异常处理"></a>8. 异常处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    x = <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;除零错误&quot;</span>, e)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;无论如何都会执行&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="9-面向对象编程"><a href="#9-面向对象编程" class="headerlink" title="9. 面向对象编程"></a>9. 面向对象编程</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello, I am <span class="hljs-subst">&#123;self.name&#125;</span>&quot;</span>)<br><br>p = Person(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-number">18</span>)<br>p.say_hello()<br></code></pre></td></tr></table></figure><h3 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Animal sound&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Woof!&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sound</span>(<span class="hljs-params">animal</span>):<br>    animal.speak()<br>make_sound(Dog())<br></code></pre></td></tr></table></figure><h3 id="类方法与静态方法"><a href="#类方法与静态方法" class="headerlink" title="类方法与静态方法"></a>类方法与静态方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>:<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cls_method</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类方法&quot;</span>)<br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">static_method</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;静态方法&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="10-模块与包"><a href="#10-模块与包" class="headerlink" title="10. 模块与包"></a>10. 模块与包</h2><h3 id="导入与自定义模块"><a href="#导入与自定义模块" class="headerlink" title="导入与自定义模块"></a>导入与自定义模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">import</span> mymodule<br></code></pre></td></tr></table></figure><h3 id="常用标准库"><a href="#常用标准库" class="headerlink" title="常用标准库"></a>常用标准库</h3><ul><li><code>os</code>、<code>sys</code>、<code>math</code>、<code>random</code>、<code>datetime</code>、<code>json</code>、<code>re</code>、<code>collections</code>、<code>itertools</code>、<code>logging</code></li></ul><h2 id="11-进阶特性"><a href="#11-进阶特性" class="headerlink" title="11. 进阶特性"></a>11. 进阶特性</h2><h3 id="列表-字典-集合推导式"><a href="#列表-字典-集合推导式" class="headerlink" title="列表&#x2F;字典&#x2F;集合推导式"></a>列表&#x2F;字典&#x2F;集合推导式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = [x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br>dct = &#123;x: x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)&#125;<br>st = &#123;x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)&#125;<br></code></pre></td></tr></table></figure><h3 id="生成器与-yield"><a href="#生成器与-yield" class="headerlink" title="生成器与 yield"></a>生成器与 yield</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-keyword">yield</span> i<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> gen():<br>    <span class="hljs-built_in">print</span>(x)<br></code></pre></td></tr></table></figure><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before&quot;</span>)<br>        result = func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>hello()<br></code></pre></td></tr></table></figure><h3 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyContext</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;enter&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;exit&quot;</span>)<br><span class="hljs-keyword">with</span> MyContext():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;doing...&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="12-常用技巧与建议"><a href="#12-常用技巧与建议" class="headerlink" title="12. 常用技巧与建议"></a>12. 常用技巧与建议</h2><ul><li>使用虚拟环境（venv、conda）管理依赖</li><li>用 pip 管理第三方包</li><li>代码风格遵循 PEP8</li><li>善用文档字符串和注释</li><li>多用列表推导、生成器提升效率</li><li>适当用 type hint 提升可读性</li></ul><hr><p>如需更深入的专题（如异步编程、数据分析、Web开发、爬虫、测试等），欢迎留言补充！ </p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>语法</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python进阶库用法——爬虫、Web开发、机器学习</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/Python%E8%BF%9B%E9%98%B6%E5%BA%93%E7%94%A8%E6%B3%95-%E7%88%AC%E8%99%AB-Web-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/Python%E8%BF%9B%E9%98%B6%E5%BA%93%E7%94%A8%E6%B3%95-%E7%88%AC%E8%99%AB-Web-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python进阶库用法——爬虫、Web开发、机器学习"><a href="#Python进阶库用法——爬虫、Web开发、机器学习" class="headerlink" title="Python进阶库用法——爬虫、Web开发、机器学习"></a>Python进阶库用法——爬虫、Web开发、机器学习</h1><p>本文深入讲解 Python 在爬虫、Web开发、机器学习领域的主流库用法，配合典型场景和代码示例，适合进阶查阅。</p><h2 id="一、爬虫相关库"><a href="#一、爬虫相关库" class="headerlink" title="一、爬虫相关库"></a>一、爬虫相关库</h2><h3 id="1-requests-——-网络请求"><a href="#1-requests-——-网络请求" class="headerlink" title="1. requests —— 网络请求"></a>1. requests —— 网络请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br>r = requests.get(<span class="hljs-string">&#x27;https://httpbin.org/get&#x27;</span>, params=&#123;<span class="hljs-string">&#x27;q&#x27;</span>: <span class="hljs-string">&#x27;python&#x27;</span>&#125;)<br><span class="hljs-built_in">print</span>(r.status_code)<br><span class="hljs-built_in">print</span>(r.text)<br></code></pre></td></tr></table></figure><h3 id="2-BeautifulSoup-——-网页解析"><a href="#2-BeautifulSoup-——-网页解析" class="headerlink" title="2. BeautifulSoup —— 网页解析"></a>2. BeautifulSoup —— 网页解析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>html = <span class="hljs-string">&#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Title&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span><br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.h1.text)<br></code></pre></td></tr></table></figure><h3 id="3-Scrapy-——-爬虫框架"><a href="#3-Scrapy-——-爬虫框架" class="headerlink" title="3. Scrapy —— 爬虫框架"></a>3. Scrapy —— 爬虫框架</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 安装：pip install scrapy</span><br><span class="hljs-comment"># 新建项目：scrapy startproject myspider</span><br><span class="hljs-comment"># 编写spider文件，示例：</span><br><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuotesSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;quotes&quot;</span><br>    start_urls = [<span class="hljs-string">&#x27;http://quotes.toscrape.com&#x27;</span>]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        <span class="hljs-keyword">for</span> quote <span class="hljs-keyword">in</span> response.css(<span class="hljs-string">&#x27;div.quote&#x27;</span>):<br>            <span class="hljs-keyword">yield</span> &#123;<br>                <span class="hljs-string">&#x27;text&#x27;</span>: quote.css(<span class="hljs-string">&#x27;span.text::text&#x27;</span>).get(),<br>                <span class="hljs-string">&#x27;author&#x27;</span>: quote.css(<span class="hljs-string">&#x27;small.author::text&#x27;</span>).get(),<br>            &#125;<br></code></pre></td></tr></table></figure><h2 id="二、Web开发相关库"><a href="#二、Web开发相关库" class="headerlink" title="二、Web开发相关库"></a>二、Web开发相关库</h2><h3 id="1-Flask-——-轻量级Web框架"><a href="#1-Flask-——-轻量级Web框架" class="headerlink" title="1. Flask —— 轻量级Web框架"></a>1. Flask —— 轻量级Web框架</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request<br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">home</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, Flask!&#x27;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/&lt;name&gt;&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;Hello, <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(debug=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="2-Django-——-全功能Web框架"><a href="#2-Django-——-全功能Web框架" class="headerlink" title="2. Django —— 全功能Web框架"></a>2. Django —— 全功能Web框架</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 安装：pip install django</span><br><span class="hljs-comment"># 新建项目：django-admin startproject mysite</span><br><span class="hljs-comment"># 新建app：python manage.py startapp blog</span><br><span class="hljs-comment"># 视图示例：</span><br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;Hello, Django!&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="3-FastAPI-——-现代异步Web框架"><a href="#3-FastAPI-——-现代异步Web框架" class="headerlink" title="3. FastAPI —— 现代异步Web框架"></a>3. FastAPI —— 现代异步Web框架</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br>app = FastAPI()<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_root</span>():<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;Hello, FastAPI!&quot;</span>&#125;<br><br><span class="hljs-comment"># 运行：uvicorn main:app --reload</span><br></code></pre></td></tr></table></figure><h2 id="三、机器学习相关库"><a href="#三、机器学习相关库" class="headerlink" title="三、机器学习相关库"></a>三、机器学习相关库</h2><h3 id="1-scikit-learn-——-经典机器学习"><a href="#1-scikit-learn-——-经典机器学习" class="headerlink" title="1. scikit-learn —— 经典机器学习"></a>1. scikit-learn —— 经典机器学习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br>X, y = load_iris(return_X_y=<span class="hljs-literal">True</span>)<br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>)<br>clf = RandomForestClassifier()<br>clf.fit(X_train, y_train)<br>y_pred = clf.predict(X_test)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;准确率:&#x27;</span>, accuracy_score(y_test, y_pred))<br></code></pre></td></tr></table></figure><h3 id="2-TensorFlow-——-深度学习"><a href="#2-TensorFlow-——-深度学习" class="headerlink" title="2. TensorFlow —— 深度学习"></a>2. TensorFlow —— 深度学习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras<br>model = keras.Sequential([<br>    keras.layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(<span class="hljs-number">4</span>,)),<br>    keras.layers.Dense(<span class="hljs-number">3</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)<br>])<br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;sparse_categorical_crossentropy&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><span class="hljs-comment"># 假设X_train, y_train已准备好</span><br>data = tf.random.normal((<span class="hljs-number">100</span>, <span class="hljs-number">4</span>))<br>labels = tf.random.uniform((<span class="hljs-number">100</span>,), maxval=<span class="hljs-number">3</span>, dtype=tf.int32)<br>model.fit(data, labels, epochs=<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="3-PyTorch-——-深度学习"><a href="#3-PyTorch-——-深度学习" class="headerlink" title="3. PyTorch —— 深度学习"></a>3. PyTorch —— 深度学习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.fc = nn.Linear(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.fc(x)<br><br>net = Net()<br>optimizer = optim.Adam(net.parameters())<br>criterion = nn.CrossEntropyLoss()<br>inputs = torch.randn(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>)<br>targets = torch.randint(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, (<span class="hljs-number">10</span>,))<br>outputs = net(inputs)<br>loss = criterion(outputs, targets)<br>loss.backward()<br>optimizer.step()<br></code></pre></td></tr></table></figure><hr><p>如需更深入的专题（如异步爬虫、RESTful API、深度学习实战等），欢迎留言补充！ </p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
      <tag>Web开发</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TensorFlow与PyTorch更深入详解</title>
    <link href="/2025/07/%E7%AC%94%E8%AE%B0/TensorFlow%E4%B8%8EPyTorch%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/07/%E7%AC%94%E8%AE%B0/TensorFlow%E4%B8%8EPyTorch%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="TensorFlow与PyTorch更深入详解"><a href="#TensorFlow与PyTorch更深入详解" class="headerlink" title="TensorFlow与PyTorch更深入详解"></a>TensorFlow与PyTorch更深入详解</h1><p>本文系统深入讲解 TensorFlow 和 PyTorch 两大主流深度学习框架的核心原理、进阶用法、实战技巧和典型案例，适合进阶学习与查阅。</p><hr><h2 id="一、张量操作（Tensor）"><a href="#一、张量操作（Tensor）" class="headerlink" title="一、张量操作（Tensor）"></a>一、张量操作（Tensor）</h2><h3 id="概念与目的"><a href="#概念与目的" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>张量是多维数组，是神经网络的基础数据结构。</li><li>支持高效的数值计算、自动广播、切片、索引、类型转换等。</li></ul><h3 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a>典型用法</h3><h4 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>x = tf.constant([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]], dtype=tf.float32)<br>y = tf.ones_like(x)<br>z = tf.concat([x, y], axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">slice</span> = x[:, <span class="hljs-number">1</span>]<br>broadcast = x + <span class="hljs-number">1</span>  <span class="hljs-comment"># 自动广播</span><br><span class="hljs-built_in">print</span>(x.shape, x.dtype, x.numpy())<br></code></pre></td></tr></table></figure><h4 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br>x = torch.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>y = torch.ones_like(x)<br>z = torch.cat([x, y], dim=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">slice</span> = x[:, <span class="hljs-number">1</span>]<br>broadcast = x + <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(x.shape, x.dtype, x.numpy())<br></code></pre></td></tr></table></figure><hr><h2 id="二、自动求导（Autograd）"><a href="#二、自动求导（Autograd）" class="headerlink" title="二、自动求导（Autograd）"></a>二、自动求导（Autograd）</h2><h3 id="概念与目的-1"><a href="#概念与目的-1" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>自动微分是深度学习训练的核心，支持动态图&#x2F;静态图的梯度计算。</li><li>支持自定义梯度、二阶导数、复杂运算链。</li></ul><h3 id="典型用法-1"><a href="#典型用法-1" class="headerlink" title="典型用法"></a>典型用法</h3><h4 id="TensorFlow-1"><a href="#TensorFlow-1" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x = tf.Variable(<span class="hljs-number">2.0</span>)<br><span class="hljs-keyword">with</span> tf.GradientTape(persistent=<span class="hljs-literal">True</span>) <span class="hljs-keyword">as</span> tape:<br>    y = x ** <span class="hljs-number">3</span> + <span class="hljs-number">2</span> * x<br>    dy_dx = tape.gradient(y, x)<br>    d2y_dx2 = tape.gradient(dy_dx, x)<br><span class="hljs-built_in">print</span>(dy_dx.numpy(), d2y_dx2.numpy())<br></code></pre></td></tr></table></figure><h4 id="PyTorch-1"><a href="#PyTorch-1" class="headerlink" title="PyTorch"></a>PyTorch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.tensor(<span class="hljs-number">2.0</span>, requires_grad=<span class="hljs-literal">True</span>)<br>y = x ** <span class="hljs-number">3</span> + <span class="hljs-number">2</span> * x<br>y.backward(create_graph=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(x.grad)  <span class="hljs-comment"># 一阶导</span><br>x.grad.zero_()<br>y.backward(retain_graph=<span class="hljs-literal">True</span>)<br>d2y_dx2 = torch.autograd.grad(y.grad_fn(x), x, create_graph=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(d2y_dx2)<br></code></pre></td></tr></table></figure><hr><h2 id="三、模型构建进阶"><a href="#三、模型构建进阶" class="headerlink" title="三、模型构建进阶"></a>三、模型构建进阶</h2><h3 id="1-函数式API（TensorFlow）"><a href="#1-函数式API（TensorFlow）" class="headerlink" title="1. 函数式API（TensorFlow）"></a>1. 函数式API（TensorFlow）</h3><ul><li>支持多输入&#x2F;输出、复杂拓扑结构。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> layers, Model, Input<br>inputs = Input(shape=(<span class="hljs-number">32</span>,))<br>x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>)(inputs)<br>outputs = layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)(x)<br>model = Model(inputs, outputs)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-自定义层与子模块"><a href="#2-自定义层与子模块" class="headerlink" title="2. 自定义层与子模块"></a>2. 自定义层与子模块</h3><h4 id="TensorFlow-2"><a href="#TensorFlow-2" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLayer</span>(tf.keras.layers.Layer):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, units</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.units = units<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">self, input_shape</span>):<br>        <span class="hljs-variable language_">self</span>.w = <span class="hljs-variable language_">self</span>.add_weight(shape=(input_shape[-<span class="hljs-number">1</span>], <span class="hljs-variable language_">self</span>.units), initializer=<span class="hljs-string">&#x27;random_normal&#x27;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">self, inputs</span>):<br>        <span class="hljs-keyword">return</span> tf.matmul(inputs, <span class="hljs-variable language_">self</span>.w)<br></code></pre></td></tr></table></figure><h4 id="PyTorch-2"><a href="#PyTorch-2" class="headerlink" title="PyTorch"></a>PyTorch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBlock</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.linear = nn.Linear(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> torch.relu(<span class="hljs-variable language_">self</span>.linear(x))<br></code></pre></td></tr></table></figure><hr><h2 id="四、训练技巧与进阶"><a href="#四、训练技巧与进阶" class="headerlink" title="四、训练技巧与进阶"></a>四、训练技巧与进阶</h2><h3 id="1-回调与监控"><a href="#1-回调与监控" class="headerlink" title="1. 回调与监控"></a>1. 回调与监控</h3><h4 id="TensorFlow-3"><a href="#TensorFlow-3" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.keras.callbacks <span class="hljs-keyword">import</span> EarlyStopping, ModelCheckpoint, ReduceLROnPlateau<br>callbacks = [EarlyStopping(patience=<span class="hljs-number">3</span>), ModelCheckpoint(<span class="hljs-string">&#x27;best.h5&#x27;</span>), ReduceLROnPlateau()]<br>model.fit(X, y, epochs=<span class="hljs-number">20</span>, callbacks=callbacks)<br></code></pre></td></tr></table></figure><h4 id="PyTorch-3"><a href="#PyTorch-3" class="headerlink" title="PyTorch"></a>PyTorch</h4><ul><li>需手动实现早停、保存、学习率调整等。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.optim.lr_scheduler <span class="hljs-keyword">import</span> ReduceLROnPlateau<br>scheduler = ReduceLROnPlateau(optimizer, <span class="hljs-string">&#x27;min&#x27;</span>)<br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>    ...<br>    scheduler.step(val_loss)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-梯度裁剪与混合精度"><a href="#2-梯度裁剪与混合精度" class="headerlink" title="2. 梯度裁剪与混合精度"></a>2. 梯度裁剪与混合精度</h3><h4 id="TensorFlow-4"><a href="#TensorFlow-4" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer = tf.keras.optimizers.Adam(clipnorm=<span class="hljs-number">1.0</span>)<br></code></pre></td></tr></table></figure><h4 id="PyTorch-4"><a href="#PyTorch-4" class="headerlink" title="PyTorch"></a>PyTorch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.cuda.amp <span class="hljs-keyword">import</span> autocast, GradScaler<br>scaler = GradScaler()<br><span class="hljs-keyword">for</span> data, target <span class="hljs-keyword">in</span> loader:<br>    optimizer.zero_grad()<br>    <span class="hljs-keyword">with</span> autocast():<br>        output = model(data)<br>        loss = criterion(output, target)<br>    scaler.scale(loss).backward()<br>    scaler.step(optimizer)<br>    scaler.update()<br></code></pre></td></tr></table></figure><hr><h2 id="五、数据加载与增强"><a href="#五、数据加载与增强" class="headerlink" title="五、数据加载与增强"></a>五、数据加载与增强</h2><h3 id="1-tf-data-与数据增强"><a href="#1-tf-data-与数据增强" class="headerlink" title="1. tf.data 与数据增强"></a>1. tf.data 与数据增强</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dataset = tf.data.Dataset.from_tensor_slices((X, y))<br>dataset = dataset.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x, y: (tf.image.random_flip_left_right(x), y))<br></code></pre></td></tr></table></figure><h3 id="2-torchvision-transforms（PyTorch）"><a href="#2-torchvision-transforms（PyTorch）" class="headerlink" title="2. torchvision.transforms（PyTorch）"></a>2. torchvision.transforms（PyTorch）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br>transform = transforms.Compose([<br>    transforms.RandomHorizontalFlip(),<br>    transforms.ToTensor()<br>])<br></code></pre></td></tr></table></figure><h3 id="3-自定义数据集"><a href="#3-自定义数据集" class="headerlink" title="3. 自定义数据集"></a>3. 自定义数据集</h3><h4 id="PyTorch-5"><a href="#PyTorch-5" class="headerlink" title="PyTorch"></a>PyTorch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data, labels</span>):<br>        <span class="hljs-variable language_">self</span>.data = data<br>        <span class="hljs-variable language_">self</span>.labels = labels<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.data)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.data[idx], <span class="hljs-variable language_">self</span>.labels[idx]<br></code></pre></td></tr></table></figure><hr><h2 id="六、分布式训练与多GPU"><a href="#六、分布式训练与多GPU" class="headerlink" title="六、分布式训练与多GPU"></a>六、分布式训练与多GPU</h2><h3 id="1-TensorFlow"><a href="#1-TensorFlow" class="headerlink" title="1. TensorFlow"></a>1. TensorFlow</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">strategy = tf.distribute.MirroredStrategy()<br><span class="hljs-keyword">with</span> strategy.scope():<br>    model = ...<br>    model.<span class="hljs-built_in">compile</span>(...)<br>    model.fit(...)<br></code></pre></td></tr></table></figure><h3 id="2-PyTorch"><a href="#2-PyTorch" class="headerlink" title="2. PyTorch"></a>2. PyTorch</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn.parallel <span class="hljs-keyword">as</span> parallel<br>model = nn.DataParallel(model)<br><span class="hljs-comment"># 或 torch.distributed.launch 启动多进程</span><br></code></pre></td></tr></table></figure><hr><h2 id="七、模型导出与跨平台部署"><a href="#七、模型导出与跨平台部署" class="headerlink" title="七、模型导出与跨平台部署"></a>七、模型导出与跨平台部署</h2><h3 id="1-TensorFlow-SavedModel-ONNX"><a href="#1-TensorFlow-SavedModel-ONNX" class="headerlink" title="1. TensorFlow SavedModel&#x2F;ONNX"></a>1. TensorFlow SavedModel&#x2F;ONNX</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">model.save(<span class="hljs-string">&#x27;saved_model&#x27;</span>)<br><span class="hljs-comment"># 导出为ONNX</span><br><span class="hljs-keyword">import</span> tf2onnx<br>spec = (tf.TensorSpec((<span class="hljs-literal">None</span>, <span class="hljs-number">32</span>), tf.float32, name=<span class="hljs-string">&quot;input&quot;</span>),)<br>model_proto, _ = tf2onnx.convert.from_keras(model, input_signature=spec)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;model.onnx&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(model_proto.SerializeToString())<br></code></pre></td></tr></table></figure><h3 id="2-PyTorch-Script-ONNX"><a href="#2-PyTorch-Script-ONNX" class="headerlink" title="2. PyTorch Script&#x2F;ONNX"></a>2. PyTorch Script&#x2F;ONNX</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># TorchScript</span><br>traced = torch.jit.trace(model, torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>))<br>traced.save(<span class="hljs-string">&#x27;model.pt&#x27;</span>)<br><span class="hljs-comment"># ONNX</span><br>torch.onnx.export(model, torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), <span class="hljs-string">&#x27;model.onnx&#x27;</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="八、典型实战案例"><a href="#八、典型实战案例" class="headerlink" title="八、典型实战案例"></a>八、典型实战案例</h2><h3 id="1-迁移学习与微调"><a href="#1-迁移学习与微调" class="headerlink" title="1. 迁移学习与微调"></a>1. 迁移学习与微调</h3><h4 id="TensorFlow-5"><a href="#TensorFlow-5" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">base_model = tf.keras.applications.ResNet50(weights=<span class="hljs-string">&#x27;imagenet&#x27;</span>, include_top=<span class="hljs-literal">False</span>)<br>base_model.trainable = <span class="hljs-literal">False</span><br>model = tf.keras.Sequential([<br>    base_model,<br>    tf.keras.layers.GlobalAveragePooling2D(),<br>    tf.keras.layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)<br>])<br></code></pre></td></tr></table></figure><h4 id="PyTorch-6"><a href="#PyTorch-6" class="headerlink" title="PyTorch"></a>PyTorch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> models<br>model = models.resnet18(pretrained=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.parameters():<br>    param.requires_grad = <span class="hljs-literal">False</span><br>model.fc = nn.Linear(model.fc.in_features, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h3 id="2-推理优化与加速"><a href="#2-推理优化与加速" class="headerlink" title="2. 推理优化与加速"></a>2. 推理优化与加速</h3><ul><li>TensorFlow Lite、TorchScript、ONNX Runtime、TensorRT等。</li></ul><hr><h2 id="九、自定义损失函数（Custom-Loss）"><a href="#九、自定义损失函数（Custom-Loss）" class="headerlink" title="九、自定义损失函数（Custom Loss）"></a>九、自定义损失函数（Custom Loss）</h2><h3 id="概念与目的-2"><a href="#概念与目的-2" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>损失函数（Loss）衡量模型预测与真实标签的差距，是训练优化的目标。</li><li>自定义损失可适应特殊任务（如类别不平衡、鲁棒性、特定业务需求等）。</li></ul><h3 id="典型用法-2"><a href="#典型用法-2" class="headerlink" title="典型用法"></a>典型用法</h3><h4 id="TensorFlow-6"><a href="#TensorFlow-6" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-comment"># 以Focal Loss为例（常用于目标检测）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">focal_loss</span>(<span class="hljs-params">gamma=<span class="hljs-number">2.</span>, alpha=<span class="hljs-number">0.25</span></span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">loss</span>(<span class="hljs-params">y_true, y_pred</span>):<br>        y_true = tf.cast(y_true, tf.float32)<br>        pt = tf.where(tf.equal(y_true, <span class="hljs-number">1</span>), y_pred, <span class="hljs-number">1</span> - y_pred)<br>        <span class="hljs-keyword">return</span> -alpha * tf.reduce_mean((<span class="hljs-number">1</span> - pt) ** gamma * tf.math.log(pt + <span class="hljs-number">1e-8</span>))<br>    <span class="hljs-keyword">return</span> loss<br>model.<span class="hljs-built_in">compile</span>(loss=focal_loss(), optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="PyTorch-7"><a href="#PyTorch-7" class="headerlink" title="PyTorch"></a>PyTorch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FocalLoss</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, gamma=<span class="hljs-number">2.</span>, alpha=<span class="hljs-number">0.25</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.gamma = gamma<br>        <span class="hljs-variable language_">self</span>.alpha = alpha<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, y_pred, y_true</span>):<br>        y_true = y_true.<span class="hljs-built_in">float</span>()<br>        pt = torch.where(y_true == <span class="hljs-number">1</span>, y_pred, <span class="hljs-number">1</span> - y_pred)<br>        loss = -<span class="hljs-variable language_">self</span>.alpha * ((<span class="hljs-number">1</span> - pt) ** <span class="hljs-variable language_">self</span>.gamma) * torch.log(pt + <span class="hljs-number">1e-8</span>)<br>        <span class="hljs-keyword">return</span> loss.mean()<br><span class="hljs-comment"># 用法</span><br>loss_fn = FocalLoss()<br>loss = loss_fn(y_pred, y_true)<br></code></pre></td></tr></table></figure><hr><h2 id="十、注意力机制（Attention-Mechanism）"><a href="#十、注意力机制（Attention-Mechanism）" class="headerlink" title="十、注意力机制（Attention Mechanism）"></a>十、注意力机制（Attention Mechanism）</h2><h3 id="概念与目的-3"><a href="#概念与目的-3" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>注意力机制让模型自动聚焦于输入的关键部分，提升长距离依赖建模能力。</li><li>广泛应用于NLP（如Transformer）、CV（如ViT、注意力卷积）等领域。</li></ul><h3 id="典型用法-3"><a href="#典型用法-3" class="headerlink" title="典型用法"></a>典型用法</h3><h4 id="TensorFlow（Self-Attention）"><a href="#TensorFlow（Self-Attention）" class="headerlink" title="TensorFlow（Self-Attention）"></a>TensorFlow（Self-Attention）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfAttention</span>(tf.keras.layers.Layer):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, units</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.Wq = tf.keras.layers.Dense(units)<br>        <span class="hljs-variable language_">self</span>.Wk = tf.keras.layers.Dense(units)<br>        <span class="hljs-variable language_">self</span>.Wv = tf.keras.layers.Dense(units)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call</span>(<span class="hljs-params">self, x</span>):<br>        Q = <span class="hljs-variable language_">self</span>.Wq(x)<br>        K = <span class="hljs-variable language_">self</span>.Wk(x)<br>        V = <span class="hljs-variable language_">self</span>.Wv(x)<br>        attn = tf.nn.softmax(tf.matmul(Q, K, transpose_b=<span class="hljs-literal">True</span>) / tf.math.sqrt(tf.cast(Q.shape[-<span class="hljs-number">1</span>], tf.float32)), axis=-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> tf.matmul(attn, V)<br></code></pre></td></tr></table></figure><h4 id="PyTorch（Self-Attention）"><a href="#PyTorch（Self-Attention）" class="headerlink" title="PyTorch（Self-Attention）"></a>PyTorch（Self-Attention）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SelfAttention</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, dim</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.q = nn.Linear(dim, dim)<br>        <span class="hljs-variable language_">self</span>.k = nn.Linear(dim, dim)<br>        <span class="hljs-variable language_">self</span>.v = nn.Linear(dim, dim)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        Q = <span class="hljs-variable language_">self</span>.q(x)<br>        K = <span class="hljs-variable language_">self</span>.k(x)<br>        V = <span class="hljs-variable language_">self</span>.v(x)<br>        attn = torch.softmax(Q @ K.transpose(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>) / (Q.size(-<span class="hljs-number">1</span>) ** <span class="hljs-number">0.5</span>), dim=-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> attn @ V<br></code></pre></td></tr></table></figure><h3 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h3><ul><li>NLP：Transformer、BERT、GPT等模型的核心。</li><li>CV：ViT、注意力卷积、图像描述生成等。</li></ul><hr><h2 id="十一、分布式训练实战"><a href="#十一、分布式训练实战" class="headerlink" title="十一、分布式训练实战"></a>十一、分布式训练实战</h2><h3 id="概念与目的-4"><a href="#概念与目的-4" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>分布式训练可利用多台机器&#x2F;多张GPU并行加速大规模模型训练。</li><li>常见策略：数据并行、模型并行、混合并行。</li></ul><h3 id="典型用法-4"><a href="#典型用法-4" class="headerlink" title="典型用法"></a>典型用法</h3><h4 id="TensorFlow（MirroredStrategy）"><a href="#TensorFlow（MirroredStrategy）" class="headerlink" title="TensorFlow（MirroredStrategy）"></a>TensorFlow（MirroredStrategy）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>strategy = tf.distribute.MirroredStrategy()<br><span class="hljs-keyword">with</span> strategy.scope():<br>    model = ...<br>    model.<span class="hljs-built_in">compile</span>(...)<br>    model.fit(...)<br></code></pre></td></tr></table></figure><ul><li>也可用 MultiWorkerMirroredStrategy、TPUStrategy 等。</li></ul><h4 id="PyTorch（DistributedDataParallel）"><a href="#PyTorch（DistributedDataParallel）" class="headerlink" title="PyTorch（DistributedDataParallel）"></a>PyTorch（DistributedDataParallel）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.distributed <span class="hljs-keyword">as</span> dist<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">from</span> torch.nn.parallel <span class="hljs-keyword">import</span> DistributedDataParallel <span class="hljs-keyword">as</span> DDP<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">rank, world_size</span>):<br>    dist.init_process_group(<span class="hljs-string">&quot;nccl&quot;</span>, rank=rank, world_size=world_size)<br>    torch.cuda.set_device(rank)<br><br><span class="hljs-comment"># 假设已用 torch.multiprocessing.spawn 启动多进程</span><br>model = nn.Linear(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>).cuda(rank)<br>model = DDP(model, device_ids=[rank])<br>optimizer = optim.Adam(model.parameters())<br><span class="hljs-comment"># 训练循环与单机类似</span><br></code></pre></td></tr></table></figure><h3 id="应用说明-1"><a href="#应用说明-1" class="headerlink" title="应用说明"></a>应用说明</h3><ul><li>适用于大数据、大模型、工业级训练。</li><li>需注意数据划分、同步、通信效率等问题。</li></ul><hr><h2 id="十二、自定义优化器（Custom-Optimizer）"><a href="#十二、自定义优化器（Custom-Optimizer）" class="headerlink" title="十二、自定义优化器（Custom Optimizer）"></a>十二、自定义优化器（Custom Optimizer）</h2><h3 id="概念与目的-5"><a href="#概念与目的-5" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>优化器（Optimizer）决定参数更新方式，是深度学习训练的核心。</li><li>自定义优化器可实现特殊的学习率策略、动量、正则化等，适应特定任务。</li></ul><h3 id="典型用法-5"><a href="#典型用法-5" class="headerlink" title="典型用法"></a>典型用法</h3><h4 id="TensorFlow-7"><a href="#TensorFlow-7" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySGD</span>(tf.keras.optimizers.Optimizer):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, learning_rate=<span class="hljs-number">0.01</span>, name=<span class="hljs-string">&quot;MySGD&quot;</span>, **kwargs</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name, **kwargs)<br>        <span class="hljs-variable language_">self</span>._set_hyper(<span class="hljs-string">&quot;learning_rate&quot;</span>, learning_rate)<br><span class="hljs-meta">    @tf.function</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_resource_apply_dense</span>(<span class="hljs-params">self, grad, var</span>):<br>        var.assign_sub(<span class="hljs-variable language_">self</span>._get_hyper(<span class="hljs-string">&quot;learning_rate&quot;</span>) * grad)<br><span class="hljs-comment"># 用法</span><br>optimizer = MySGD(learning_rate=<span class="hljs-number">0.1</span>)<br>model.<span class="hljs-built_in">compile</span>(optimizer=optimizer, loss=<span class="hljs-string">&#x27;mse&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="PyTorch-8"><a href="#PyTorch-8" class="headerlink" title="PyTorch"></a>PyTorch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.optim.optimizer <span class="hljs-keyword">import</span> Optimizer<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySGD</span>(<span class="hljs-title class_ inherited__">Optimizer</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, params, lr=<span class="hljs-number">0.01</span></span>):<br>        defaults = <span class="hljs-built_in">dict</span>(lr=lr)<br>        <span class="hljs-built_in">super</span>().__init__(params, defaults)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">self, closure=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">for</span> group <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.param_groups:<br>            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> group[<span class="hljs-string">&#x27;params&#x27;</span>]:<br>                <span class="hljs-keyword">if</span> p.grad <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    p.data -= group[<span class="hljs-string">&#x27;lr&#x27;</span>] * p.grad.data<br><span class="hljs-comment"># 用法</span><br>optimizer = MySGD(model.parameters(), lr=<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="十三、混合精度分布式训练（Mixed-Precision-Distributed-Training）"><a href="#十三、混合精度分布式训练（Mixed-Precision-Distributed-Training）" class="headerlink" title="十三、混合精度分布式训练（Mixed Precision Distributed Training）"></a>十三、混合精度分布式训练（Mixed Precision Distributed Training）</h2><h3 id="概念与目的-6"><a href="#概念与目的-6" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>混合精度训练（FP16+FP32）可大幅提升训练速度、降低显存占用。</li><li>分布式训练结合混合精度，适合大模型&#x2F;大数据高效训练。</li></ul><h3 id="典型用法-6"><a href="#典型用法-6" class="headerlink" title="典型用法"></a>典型用法</h3><h4 id="TensorFlow-8"><a href="#TensorFlow-8" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> mixed_precision<br>mixed_precision.set_global_policy(<span class="hljs-string">&#x27;mixed_float16&#x27;</span>)<br>strategy = tf.distribute.MirroredStrategy()<br><span class="hljs-keyword">with</span> strategy.scope():<br>    model = ...<br>    model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>, loss=<span class="hljs-string">&#x27;mse&#x27;</span>)<br>    model.fit(...)<br></code></pre></td></tr></table></figure><h4 id="PyTorch-9"><a href="#PyTorch-9" class="headerlink" title="PyTorch"></a>PyTorch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.cuda.amp <span class="hljs-keyword">import</span> autocast, GradScaler<br><span class="hljs-keyword">from</span> torch.nn.parallel <span class="hljs-keyword">import</span> DistributedDataParallel <span class="hljs-keyword">as</span> DDP<br>scaler = GradScaler()<br><span class="hljs-keyword">for</span> data, target <span class="hljs-keyword">in</span> loader:<br>    optimizer.zero_grad()<br>    <span class="hljs-keyword">with</span> autocast():<br>        output = model(data)<br>        loss = criterion(output, target)<br>    scaler.scale(loss).backward()<br>    scaler.step(optimizer)<br>    scaler.update()<br><span class="hljs-comment"># 配合 DDP 使用，实现分布式+混合精度</span><br></code></pre></td></tr></table></figure><hr><h2 id="十四、跨平台推理与部署（Cross-platform-Inference-Deployment）"><a href="#十四、跨平台推理与部署（Cross-platform-Inference-Deployment）" class="headerlink" title="十四、跨平台推理与部署（Cross-platform Inference &amp; Deployment）"></a>十四、跨平台推理与部署（Cross-platform Inference &amp; Deployment）</h2><h3 id="概念与目的-7"><a href="#概念与目的-7" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>跨平台推理让模型在不同硬件&#x2F;系统&#x2F;语言环境下高效运行。</li><li>常用格式：TensorFlow SavedModel、ONNX、TorchScript、TensorRT等。</li></ul><h3 id="典型用法-7"><a href="#典型用法-7" class="headerlink" title="典型用法"></a>典型用法</h3><h4 id="TensorFlow-9"><a href="#TensorFlow-9" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导出 SavedModel</span><br>model.save(<span class="hljs-string">&#x27;saved_model&#x27;</span>)<br><span class="hljs-comment"># TensorFlow Lite 转换</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>converter = tf.lite.TFLiteConverter.from_saved_model(<span class="hljs-string">&#x27;saved_model&#x27;</span>)<br>tflite_model = converter.convert()<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;model.tflite&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(tflite_model)<br></code></pre></td></tr></table></figure><h4 id="PyTorch-10"><a href="#PyTorch-10" class="headerlink" title="PyTorch"></a>PyTorch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># TorchScript 导出</span><br>traced = torch.jit.trace(model, torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>))<br>traced.save(<span class="hljs-string">&#x27;model.pt&#x27;</span>)<br><span class="hljs-comment"># ONNX 导出</span><br>torch.onnx.export(model, torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>), <span class="hljs-string">&#x27;model.onnx&#x27;</span>)<br><span class="hljs-comment"># ONNX Runtime 推理</span><br><span class="hljs-keyword">import</span> onnxruntime <span class="hljs-keyword">as</span> ort<br>ort_session = ort.InferenceSession(<span class="hljs-string">&#x27;model.onnx&#x27;</span>)<br>outputs = ort_session.run(<span class="hljs-literal">None</span>, &#123;<span class="hljs-string">&#x27;input&#x27;</span>: input_array&#125;)<br></code></pre></td></tr></table></figure><h3 id="应用说明-2"><a href="#应用说明-2" class="headerlink" title="应用说明"></a>应用说明</h3><ul><li>支持移动端（TF Lite）、Web（ONNX.js）、C++&#x2F;Java&#x2F;Go等多语言推理。</li><li>支持硬件加速（TensorRT、OpenVINO、EdgeTPU等）。</li></ul><hr><h2 id="十五、自定义正则化（Custom-Regularization）"><a href="#十五、自定义正则化（Custom-Regularization）" class="headerlink" title="十五、自定义正则化（Custom Regularization）"></a>十五、自定义正则化（Custom Regularization）</h2><h3 id="概念与目的-8"><a href="#概念与目的-8" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>正则化用于防止模型过拟合，提升泛化能力。</li><li>常见有L1、L2、稀疏、结构化等，也可自定义惩罚项。</li></ul><h3 id="典型用法-8"><a href="#典型用法-8" class="headerlink" title="典型用法"></a>典型用法</h3><h4 id="TensorFlow-10"><a href="#TensorFlow-10" class="headerlink" title="TensorFlow"></a>TensorFlow</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-comment"># 自定义L1正则化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">L1Regularizer</span>(tf.keras.regularizers.Regularizer):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, l1=<span class="hljs-number">0.01</span></span>):<br>        <span class="hljs-variable language_">self</span>.l1 = l1<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.l1 * tf.reduce_sum(tf.<span class="hljs-built_in">abs</span>(x))<br><span class="hljs-comment"># 用法</span><br>layer = tf.keras.layers.Dense(<span class="hljs-number">10</span>, kernel_regularizer=L1Regularizer(<span class="hljs-number">0.01</span>))<br></code></pre></td></tr></table></figure><h4 id="PyTorch-11"><a href="#PyTorch-11" class="headerlink" title="PyTorch"></a>PyTorch</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-comment"># 在loss中手动加正则项</span><br>l1_lambda = <span class="hljs-number">0.01</span><br>l1_norm = <span class="hljs-built_in">sum</span>(p.<span class="hljs-built_in">abs</span>().<span class="hljs-built_in">sum</span>() <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> model.parameters())<br>loss = base_loss + l1_lambda * l1_norm<br></code></pre></td></tr></table></figure><hr><h2 id="十六、模型压缩（Model-Compression）"><a href="#十六、模型压缩（Model-Compression）" class="headerlink" title="十六、模型压缩（Model Compression）"></a>十六、模型压缩（Model Compression）</h2><h3 id="概念与目的-9"><a href="#概念与目的-9" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>模型压缩提升推理速度、降低存储和部署成本。</li><li>常见方法：剪枝（Pruning）、量化（Quantization）、蒸馏（Distillation）。</li></ul><h3 id="典型用法-9"><a href="#典型用法-9" class="headerlink" title="典型用法"></a>典型用法</h3><h4 id="TensorFlow（剪枝与量化）"><a href="#TensorFlow（剪枝与量化）" class="headerlink" title="TensorFlow（剪枝与量化）"></a>TensorFlow（剪枝与量化）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow_model_optimization <span class="hljs-keyword">as</span> tfmot<br><span class="hljs-comment"># 剪枝</span><br>prune_low_magnitude = tfmot.sparsity.keras.prune_low_magnitude<br>pruned_model = prune_low_magnitude(model, pruning_schedule=tfmot.sparsity.keras.PolynomialDecay(<span class="hljs-number">0.2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>))<br><span class="hljs-comment"># 量化</span><br>converter = tf.lite.TFLiteConverter.from_keras_model(model)<br>converter.optimizations = [tf.lite.Optimize.DEFAULT]<br>tflite_quant_model = converter.convert()<br></code></pre></td></tr></table></figure><h4 id="PyTorch（剪枝与量化）"><a href="#PyTorch（剪枝与量化）" class="headerlink" title="PyTorch（剪枝与量化）"></a>PyTorch（剪枝与量化）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn.utils.prune <span class="hljs-keyword">as</span> prune<br><span class="hljs-comment"># 剪枝</span><br>prune.l1_unstructured(model.fc, name=<span class="hljs-string">&#x27;weight&#x27;</span>, amount=<span class="hljs-number">0.5</span>)<br><span class="hljs-comment"># 量化</span><br><span class="hljs-keyword">import</span> torch.quantization<br>model.qconfig = torch.quantization.get_default_qconfig(<span class="hljs-string">&#x27;fbgemm&#x27;</span>)<br>torch.quantization.prepare(model, inplace=<span class="hljs-literal">True</span>)<br>torch.quantization.convert(model, inplace=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h4 id="蒸馏（Distillation）"><a href="#蒸馏（Distillation）" class="headerlink" title="蒸馏（Distillation）"></a>蒸馏（Distillation）</h4><ul><li>用大模型（teacher）指导小模型（student）学习。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 伪代码</span><br>student_loss = alpha * CE(student_logits, labels) + (<span class="hljs-number">1</span>-alpha) * KL(student_logits, teacher_logits)<br></code></pre></td></tr></table></figure></li></ul><h3 id="应用说明-3"><a href="#应用说明-3" class="headerlink" title="应用说明"></a>应用说明</h3><ul><li>适用于移动端、嵌入式、边缘计算等资源受限场景。</li></ul><hr><h2 id="十七、自动微分底层原理（Autodiff-Internals）"><a href="#十七、自动微分底层原理（Autodiff-Internals）" class="headerlink" title="十七、自动微分底层原理（Autodiff Internals）"></a>十七、自动微分底层原理（Autodiff Internals）</h2><h3 id="概念与目的-10"><a href="#概念与目的-10" class="headerlink" title="概念与目的"></a>概念与目的</h3><ul><li>自动微分基于链式法则和计算图，自动计算复杂函数的导数。</li><li>支持前向&#x2F;反向传播，极大简化神经网络训练。</li></ul><h3 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h3><ul><li><strong>计算图</strong>：每个操作和变量都是图中的节点，边表示依赖关系。</li><li><strong>链式法则</strong>：复合函数的导数等于各层导数的乘积。</li><li><strong>反向传播</strong>：从输出到输入递归计算梯度。</li></ul><h3 id="简单实现示例（反向传播）"><a href="#简单实现示例（反向传播）" class="headerlink" title="简单实现示例（反向传播）"></a>简单实现示例（反向传播）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 仅演示标量情况</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data, grad=<span class="hljs-number">0.0</span></span>):<br>        <span class="hljs-variable language_">self</span>.data = data<br>        <span class="hljs-variable language_">self</span>.grad = grad<br>        <span class="hljs-variable language_">self</span>._backward = <span class="hljs-keyword">lambda</span>: <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        out = Value(<span class="hljs-variable language_">self</span>.data + other.data)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_backward</span>():<br>            <span class="hljs-variable language_">self</span>.grad += out.grad<br>            other.grad += out.grad<br>        out._backward = _backward<br>        <span class="hljs-keyword">return</span> out<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self, other</span>):<br>        out = Value(<span class="hljs-variable language_">self</span>.data * other.data)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_backward</span>():<br>            <span class="hljs-variable language_">self</span>.grad += other.data * out.grad<br>            other.grad += <span class="hljs-variable language_">self</span>.data * out.grad<br>        out._backward = _backward<br>        <span class="hljs-keyword">return</span> out<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.grad = <span class="hljs-number">1.0</span><br>        <span class="hljs-variable language_">self</span>._backward()<br><br><span class="hljs-comment"># 示例：y = x * x + 2 * x</span><br>x = Value(<span class="hljs-number">3.0</span>)<br>y = x * x + x + x<br>y.backward()<br><span class="hljs-built_in">print</span>(x.grad)  <span class="hljs-comment"># 输出8.0</span><br></code></pre></td></tr></table></figure><h3 id="应用说明-4"><a href="#应用说明-4" class="headerlink" title="应用说明"></a>应用说明</h3><ul><li>自动微分是现代深度学习框架的基础，极大提升了开发效率和灵活性。</li></ul><hr><p>如需更深入的专题（如自定义激活函数、神经架构搜索、可微编程等），欢迎留言补充！ </p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>深度学习</tag>
      
      <tag>TensorFlow</tag>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DFS与BFS算法详解与C++实现</title>
    <link href="/2025/07/%E7%AE%97%E6%B3%95/03_DFS%E4%B8%8EBFS%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E7%AE%97%E6%B3%95/03_DFS%E4%B8%8EBFS%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="DFS与BFS算法详解与C-实现"><a href="#DFS与BFS算法详解与C-实现" class="headerlink" title="DFS与BFS算法详解与C++实现"></a>DFS与BFS算法详解与C++实现</h1><h2 id="1-DFS与BFS原理（详细）"><a href="#1-DFS与BFS原理（详细）" class="headerlink" title="1. DFS与BFS原理（详细）"></a>1. DFS与BFS原理（详细）</h2><h3 id="1-1-深度优先搜索（DFS）"><a href="#1-1-深度优先搜索（DFS）" class="headerlink" title="1.1 深度优先搜索（DFS）"></a>1.1 深度优先搜索（DFS）</h3><ul><li><strong>核心思想</strong>：优先深入到分支的最深处再回溯，常用于递归或显式栈实现。</li><li><strong>递归实现</strong>：每次递归进入下一个状态，直到满足终止条件或无路可走。</li><li><strong>非递归实现</strong>：用栈模拟递归过程。</li><li><strong>状态空间</strong>：适合遍历所有可能路径、组合、排列、图的连通分量等。</li><li><strong>剪枝</strong>：在递归&#x2F;搜索过程中提前排除不可能解，提升效率。</li><li><strong>常见陷阱</strong>：递归栈溢出、重复访问、状态未回溯。</li></ul><h3 id="1-2-广度优先搜索（BFS）"><a href="#1-2-广度优先搜索（BFS）" class="headerlink" title="1.2 广度优先搜索（BFS）"></a>1.2 广度优先搜索（BFS）</h3><ul><li><strong>核心思想</strong>：一层一层扩展，优先访问距离起点最近的状态，常用队列实现。</li><li><strong>实现方式</strong>：每次将当前层所有状态扩展到下一层。</li><li><strong>适用场景</strong>：最短路径、层次遍历、最小步数问题。</li><li><strong>常见陷阱</strong>：队列爆炸、状态未标记、死循环。</li></ul><h2 id="2-C-实现"><a href="#2-C-实现" class="headerlink" title="2. C++实现"></a>2. C++实现</h2><h3 id="2-1-DFS递归与非递归"><a href="#2-1-DFS递归与非递归" class="headerlink" title="2.1 DFS递归与非递归"></a>2.1 DFS递归与非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 以无向图为例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, std::vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    visited[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u]) &#123;<br>        <span class="hljs-keyword">if</span> (!visited[v]) <span class="hljs-built_in">dfs</span>(v, graph, visited);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 非递归</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfsIter</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, std::vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    stk.<span class="hljs-built_in">push</span>(start);<br>    <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (visited[u]) <span class="hljs-keyword">continue</span>;<br>        visited[u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[v]) stk.<span class="hljs-built_in">push</span>(v);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-BFS实现"><a href="#2-2-BFS实现" class="headerlink" title="2.2 BFS实现"></a>2.2 BFS实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, std::vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    visited[start] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[v]) &#123;<br>                visited[v] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>时间复杂度：O(V+E)（V为顶点数，E为边数）</li><li>空间复杂度：O(V)</li></ul><h2 id="4-应用场景与典型题型"><a href="#4-应用场景与典型题型" class="headerlink" title="4. 应用场景与典型题型"></a>4. 应用场景与典型题型</h2><ul><li>图&#x2F;树遍历、连通分量、拓扑排序、最短路径、迷宫、组合&#x2F;排列生成、状态空间搜索等。</li></ul><hr><p>如需更多算法专题，欢迎留言！ </p><h2 id="5-进阶原理细节与常见陷阱"><a href="#5-进阶原理细节与常见陷阱" class="headerlink" title="5. 进阶原理细节与常见陷阱"></a>5. 进阶原理细节与常见陷阱</h2><ul><li><strong>递归爆栈</strong>：DFS递归层数过深易爆栈，工程中可用显式栈或尾递归优化。</li><li><strong>状态未回溯</strong>：DFS&#x2F;回溯未正确回溯状态，导致结果错误。</li><li><strong>BFS队列爆炸</strong>：状态空间大时BFS队列极大，需剪枝或双向BFS。</li><li><strong>重复访问</strong>：未标记visited导致死循环或超时。</li><li><strong>图&#x2F;树混淆</strong>：树DFS无需visited，图DFS必须visited。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：力扣-200-岛屿数量（BFS-DFS）"><a href="#案例1：力扣-200-岛屿数量（BFS-DFS）" class="headerlink" title="案例1：力扣 200. 岛屿数量（BFS&#x2F;DFS）"></a>案例1：力扣 200. 岛屿数量（BFS&#x2F;DFS）</h3><p><strong>题意</strong>：统计二维网格中连通块数量。<br><strong>思路</strong>：对每个未访问的陆地用DFS&#x2F;BFS遍历标记。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, std::vector&lt;std::vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= n || y &lt; <span class="hljs-number">0</span> || y &gt;= m || grid[x][y] != <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">return</span>;<br>    grid[x][y] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>    <span class="hljs-built_in">dfs</span>(x<span class="hljs-number">+1</span>, y, grid); <span class="hljs-built_in">dfs</span>(x<span class="hljs-number">-1</span>, y, grid); <span class="hljs-built_in">dfs</span>(x, y<span class="hljs-number">+1</span>, grid); <span class="hljs-built_in">dfs</span>(x, y<span class="hljs-number">-1</span>, grid);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(std::vector&lt;std::vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(), cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123; <span class="hljs-built_in">dfs</span>(i, j, grid); ++cnt; &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(nm)。<br><strong>应用说明</strong>：工程图像连通域、竞赛常考。</p><h3 id="案例2：最短路径（BFS）"><a href="#案例2：最短路径（BFS）" class="headerlink" title="案例2：最短路径（BFS）"></a>案例2：最短路径（BFS）</h3><p><strong>题意</strong>：无权图求最短路径长度。<br><strong>思路</strong>：BFS层次遍历，首次到达即最短。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPath</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q; q.<span class="hljs-built_in">push</span>(s); dist[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : graph[u]) &#123;<br>            <span class="hljs-keyword">if</span> (dist[v] == <span class="hljs-number">-1</span>) &#123; dist[v] = dist[u] + <span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(v); &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dist[t];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(V+E)。<br><strong>应用说明</strong>：工程路由、竞赛图论。</p><h3 id="案例3：全排列生成（DFS-回溯）"><a href="#案例3：全排列生成（DFS-回溯）" class="headerlink" title="案例3：全排列生成（DFS&#x2F;回溯）"></a>案例3：全排列生成（DFS&#x2F;回溯）</h3><p><strong>题意</strong>：输出n个数的全排列。<br><strong>思路</strong>：DFS递归+used数组。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">permuteHelper</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, std::vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123; res.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>        used[i] = <span class="hljs-literal">true</span>; path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">permuteHelper</span>(nums, used, path, res);<br>        path.<span class="hljs-built_in">pop_back</span>(); used[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br>std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; res; std::vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-built_in">permuteHelper</span>(nums, used, path, res); <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n!)。<br><strong>应用说明</strong>：竞赛排列生成、工程枚举。</p><h2 id="7-常见优化与工程建议"><a href="#7-常见优化与工程建议" class="headerlink" title="7. 常见优化与工程建议"></a>7. 常见优化与工程建议</h2><ul><li>BFS可用双向BFS、A*等优化。</li><li>DFS&#x2F;回溯可用剪枝、记忆化。</li><li>图遍历优先用邻接表存储。</li><li>工程中优先用STL queue&#x2F;stack&#x2F;vector等容器。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法详解与C++实现</title>
    <link href="/2025/07/%E7%AE%97%E6%B3%95/01_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E7%AE%97%E6%B3%95/01_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法详解与C-实现"><a href="#排序算法详解与C-实现" class="headerlink" title="排序算法详解与C++实现"></a>排序算法详解与C++实现</h1><h2 id="1-排序算法概述"><a href="#1-排序算法概述" class="headerlink" title="1. 排序算法概述"></a>1. 排序算法概述</h2><p>排序算法用于将一组数据按特定顺序（如从小到大）重新排列，是最基础且应用最广泛的算法之一。常见排序算法有冒泡、选择、插入、归并、快速、堆排序等。</p><h2 id="2-常见排序算法原理与C-实现"><a href="#2-常见排序算法原理与C-实现" class="headerlink" title="2. 常见排序算法原理与C++实现"></a>2. 常见排序算法原理与C++实现</h2><h3 id="2-1-冒泡排序（Bubble-Sort）"><a href="#2-1-冒泡排序（Bubble-Sort）" class="headerlink" title="2.1 冒泡排序（Bubble Sort）"></a>2.1 冒泡排序（Bubble Sort）</h3><ul><li><strong>原理</strong>：每次遍历将最大&#x2F;最小元素“冒泡”到末尾。</li><li><strong>代码示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                std::<span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-选择排序（Selection-Sort）"><a href="#2-2-选择排序（Selection-Sort）" class="headerlink" title="2.2 选择排序（Selection Sort）"></a>2.2 选择排序（Selection Sort）</h3><ul><li><strong>原理</strong>：每次选择最小元素放到已排序区末尾。</li><li><strong>代码示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> minIdx = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIdx]) minIdx = j;<br>        &#125;<br>        std::<span class="hljs-built_in">swap</span>(arr[i], arr[minIdx]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-3-插入排序（Insertion-Sort）"><a href="#2-3-插入排序（Insertion-Sort）" class="headerlink" title="2.3 插入排序（Insertion Sort）"></a>2.3 插入排序（Insertion Sort）</h3><ul><li><strong>原理</strong>：每次将一个元素插入到已排序区的合适位置。</li><li><strong>代码示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> key = arr[i];<br>        <span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            --j;<br>        &#125;<br>        arr[j + <span class="hljs-number">1</span>] = key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-归并排序（Merge-Sort）"><a href="#2-4-归并排序（Merge-Sort）" class="headerlink" title="2.4 归并排序（Merge Sort）"></a>2.4 归并排序（Merge Sort）</h3><ul><li><strong>原理</strong>：分治思想，将数组递归分成两半，分别排序后合并。</li><li><strong>代码示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(arr.begin() + l, arr.begin() + m + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(arr.begin() + m + <span class="hljs-number">1</span>, arr.begin() + r + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = l;<br>    <span class="hljs-keyword">while</span> (i &lt; left.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; right.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (left[i] &lt;= right[j]) arr[k++] = left[i++];<br>        <span class="hljs-keyword">else</span> arr[k++] = right[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt; left.<span class="hljs-built_in">size</span>()) arr[k++] = left[i++];<br>    <span class="hljs-keyword">while</span> (j &lt; right.<span class="hljs-built_in">size</span>()) arr[k++] = right[j++];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">mergeSort</span>(arr, l, m);<br>    <span class="hljs-built_in">mergeSort</span>(arr, m + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">merge</span>(arr, l, m, r);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-5-快速排序（Quick-Sort）"><a href="#2-5-快速排序（Quick-Sort）" class="headerlink" title="2.5 快速排序（Quick Sort）"></a>2.5 快速排序（Quick Sort）</h3><ul><li><strong>原理</strong>：分治思想，选定基准元素，将小于基准的放左边，大于的放右边，递归处理。</li><li><strong>代码示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = arr[r];<br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = l; j &lt; r; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &lt; pivot) std::<span class="hljs-built_in">swap</span>(arr[++i], arr[j]);<br>    &#125;<br>    std::<span class="hljs-built_in">swap</span>(arr[i + <span class="hljs-number">1</span>], arr[r]);<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> pi = <span class="hljs-built_in">partition</span>(arr, l, r);<br>        <span class="hljs-built_in">quickSort</span>(arr, l, pi - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(arr, pi + <span class="hljs-number">1</span>, r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-6-堆排序（Heap-Sort）"><a href="#2-6-堆排序（Heap-Sort）" class="headerlink" title="2.6 堆排序（Heap Sort）"></a>2.6 堆排序（Heap Sort）</h3><ul><li><strong>原理</strong>：利用堆这种数据结构，每次取出堆顶元素。</li><li><strong>代码示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> largest = i;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>, r = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) largest = l;<br>    <span class="hljs-keyword">if</span> (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) largest = r;<br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br>        std::<span class="hljs-built_in">swap</span>(arr[i], arr[largest]);<br>        <span class="hljs-built_in">heapify</span>(arr, n, largest);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) <span class="hljs-built_in">heapify</span>(arr, n, i);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        std::<span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);<br>        <span class="hljs-built_in">heapify</span>(arr, i, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-复杂度分析与对比"><a href="#3-复杂度分析与对比" class="headerlink" title="3. 复杂度分析与对比"></a>3. 复杂度分析与对比</h2><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>选择</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>插入</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>归并</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>快排</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(nlogn)</td><td>O(logn)</td><td>不稳定</td></tr><tr><td>堆排</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>不稳定</td></tr></tbody></table><h2 id="4-适用场景与总结"><a href="#4-适用场景与总结" class="headerlink" title="4. 适用场景与总结"></a>4. 适用场景与总结</h2><ul><li>小规模数据可用插入、冒泡、选择排序。</li><li>大规模数据推荐归并、快速、堆排序。</li><li>需稳定排序用归并、插入、冒泡。</li><li>需原地排序用快排、堆排、插入、冒泡、选择。</li></ul><hr><p>如需更多算法专题，欢迎留言！ </p><h2 id="5-进阶原理细节与常见陷阱"><a href="#5-进阶原理细节与常见陷阱" class="headerlink" title="5. 进阶原理细节与常见陷阱"></a>5. 进阶原理细节与常见陷阱</h2><ul><li><strong>稳定性陷阱</strong>：快排、堆排不稳定，工程中如需稳定排序应选归并或插入。</li><li><strong>递归栈溢出</strong>：快排极端情况下递归层数高，工程中应选用随机化或三路快排。</li><li><strong>原地排序陷阱</strong>：归并排序非原地，空间敏感场景需注意。</li><li><strong>大数据排序</strong>：内存无法容纳时需用外部排序（多路归并、分块等）。</li><li><strong>工程优化</strong>：STL sort底层为IntroSort（快排+堆排+插排混合），兼顾最坏复杂度和实际效率。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：区间第k大（TopK）"><a href="#案例1：区间第k大（TopK）" class="headerlink" title="案例1：区间第k大（TopK）"></a>案例1：区间第k大（TopK）</h3><p><strong>题意</strong>：给定n个数，求区间第k大的数。<br><strong>思路</strong>：用堆维护TopK，或快排分治思想。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> pi = <span class="hljs-built_in">partition</span>(arr, l, r);<br>        <span class="hljs-keyword">if</span> (pi == k) <span class="hljs-keyword">return</span> arr[pi];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pi &lt; k) l = pi + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = pi - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[l];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n)均摊。<br><strong>应用说明</strong>：大数据TopK、竞赛常考。</p><h3 id="案例2：逆序对计数"><a href="#案例2：逆序对计数" class="headerlink" title="案例2：逆序对计数"></a>案例2：逆序对计数</h3><p><strong>题意</strong>：求数组中逆序对数量。<br><strong>思路</strong>：归并排序分治统计。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">mergeSortCount</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt = <span class="hljs-built_in">mergeSortCount</span>(arr, l, m) + <span class="hljs-built_in">mergeSortCount</span>(arr, m + <span class="hljs-number">1</span>, r);<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>    <span class="hljs-type">int</span> i = l, j = m + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] &lt;= arr[j]) tmp.<span class="hljs-built_in">push_back</span>(arr[i++]);<br>        <span class="hljs-keyword">else</span> &#123; tmp.<span class="hljs-built_in">push_back</span>(arr[j++]); cnt += m - i + <span class="hljs-number">1</span>; &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (i &lt;= m) tmp.<span class="hljs-built_in">push_back</span>(arr[i++]);<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp.<span class="hljs-built_in">push_back</span>(arr[j++]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = l; k &lt;= r; ++k) arr[k] = tmp[k - l];<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(nlogn)。<br><strong>应用说明</strong>：竞赛经典题型。</p><h3 id="案例3：工程排序优化"><a href="#案例3：工程排序优化" class="headerlink" title="案例3：工程排序优化"></a>案例3：工程排序优化</h3><p><strong>题意</strong>：百万级数据排序，需高效且稳定。<br><strong>思路</strong>：优先用STL sort，若需稳定则用stable_sort（归并），大数据用多线程分块归并。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; arr = ...;<br>std::<span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 高效</span><br>std::<span class="hljs-built_in">stable_sort</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 稳定</span><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(nlogn)。<br><strong>应用说明</strong>：工程大数据排序。</p><h2 id="7-常见优化与工程建议"><a href="#7-常见优化与工程建议" class="headerlink" title="7. 常见优化与工程建议"></a>7. 常见优化与工程建议</h2><ul><li>快排随机化、三路划分防极端。</li><li>归并排序可多线程分块。</li><li>堆排序适合TopK、流式数据。</li><li>STL sort&#x2F;partial_sort&#x2F;topk等高效实用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划算法详解与C++实现</title>
    <link href="/2025/07/%E7%AE%97%E6%B3%95/04_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E7%AE%97%E6%B3%95/04_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划算法详解与C-实现"><a href="#动态规划算法详解与C-实现" class="headerlink" title="动态规划算法详解与C++实现"></a>动态规划算法详解与C++实现</h1><h2 id="1-动态规划原理（详细）"><a href="#1-动态规划原理（详细）" class="headerlink" title="1. 动态规划原理（详细）"></a>1. 动态规划原理（详细）</h2><p>动态规划（Dynamic Programming, DP）是一种将复杂问题分解为子问题，通过保存子问题结果避免重复计算的算法思想。</p><ul><li><strong>最优子结构</strong>：问题的最优解可以由子问题的最优解推导。</li><li><strong>重叠子问题</strong>：同一子问题会被多次计算。</li><li><strong>状态设计</strong>：明确每个子问题的状态（如dp[i][j]的含义）。</li><li><strong>转移方程</strong>：描述如何由子问题的解推出当前问题的解。</li><li><strong>记忆化搜索</strong>：用递归+缓存（map&#x2F;数组）保存子问题结果。</li><li><strong>递推</strong>：自底向上填表，逐步推出最终解。</li><li><strong>常见陷阱</strong>：状态设计不清、边界条件遗漏、空间未优化。</li></ul><h2 id="2-经典DP题型与C-实现"><a href="#2-经典DP题型与C-实现" class="headerlink" title="2. 经典DP题型与C++实现"></a>2. 经典DP题型与C++实现</h2><h3 id="2-1-0-1背包问题"><a href="#2-1-0-1背包问题" class="headerlink" title="2.1 0-1背包问题"></a>2.1 0-1背包问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// n个物品，容量为W，每个物品重量w[i]、价值v[i]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> W, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; w, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(W + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = W; j &gt;= w[i]; --j) &#123;<br>            dp[j] = std::<span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[W];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-最长递增子序列（LIS）"><a href="#2-2-最长递增子序列（LIS）" class="headerlink" title="2.2 最长递增子序列（LIS）"></a>2.2 最长递增子序列（LIS）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = std::<span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>        res = std::<span class="hljs-built_in">max</span>(res, dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-区间DP（如矩阵链乘）"><a href="#2-3-区间DP（如矩阵链乘）" class="headerlink" title="2.3 区间DP（如矩阵链乘）"></a>2.3 区间DP（如矩阵链乘）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 矩阵链乘最小代价</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">matrixChain</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; p)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, INT_MAX));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) dp[i][i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; ++len) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + len - <span class="hljs-number">1</span> &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; ++k) &#123;<br>                dp[i][j] = std::<span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k<span class="hljs-number">+1</span>][j] + p[i]*p[k<span class="hljs-number">+1</span>]*p[j<span class="hljs-number">+1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>时间复杂度：视具体DP问题而定，常见如O(nW)、O(n^2)、O(n^3)</li><li>空间复杂度：O(n)、O(n^2)等</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>背包问题、序列问题、区间问题、博弈、计数、最优划分等。</li></ul><hr><p>如需更多算法专题，欢迎留言！ </p><h2 id="5-进阶原理细节与常见陷阱"><a href="#5-进阶原理细节与常见陷阱" class="headerlink" title="5. 进阶原理细节与常见陷阱"></a>5. 进阶原理细节与常见陷阱</h2><ul><li><strong>状态设计陷阱</strong>：状态定义不清、遗漏维度，导致DP无解或错误。</li><li><strong>边界初始化</strong>：初值设置错误，常见如dp[0]&#x3D;0或dp[0][0]&#x3D;1。</li><li><strong>空间未优化</strong>：一维可优化为一维的DP未降维，浪费空间。</li><li><strong>记忆化与递推混淆</strong>：记忆化搜索与递推DP的适用场景不同。</li><li><strong>子问题重叠</strong>：未利用记忆化导致TLE。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：力扣-300-最长递增子序列（LIS）"><a href="#案例1：力扣-300-最长递增子序列（LIS）" class="headerlink" title="案例1：力扣 300. 最长递增子序列（LIS）"></a>案例1：力扣 300. 最长递增子序列（LIS）</h3><p><strong>题意</strong>：求数组最长递增子序列长度。<br><strong>思路</strong>：dp[i]表示以i结尾的LIS，或用贪心+二分优化。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = std::<span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>        res = std::<span class="hljs-built_in">max</span>(res, dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n^2)，二分优化O(nlogn)。<br><strong>应用说明</strong>：工程序列分析、竞赛常考。</p><h3 id="案例2：完全背包问题"><a href="#案例2：完全背包问题" class="headerlink" title="案例2：完全背包问题"></a>案例2：完全背包问题</h3><p><strong>题意</strong>：每种物品可选无限次，求最大价值。<br><strong>思路</strong>：一维DP，正序遍历容量。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">completePack</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> W, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; w, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; v)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(W + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = w[i]; j &lt;= W; ++j)<br>            dp[j] = std::<span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>    <span class="hljs-keyword">return</span> dp[W];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(nW)。<br><strong>应用说明</strong>：工程资源分配、竞赛背包。</p><h3 id="案例3：区间DP（石子合并）"><a href="#案例3：区间DP（石子合并）" class="headerlink" title="案例3：区间DP（石子合并）"></a>案例3：区间DP（石子合并）</h3><p><strong>题意</strong>：合并石子最小代价。<br><strong>思路</strong>：区间DP，dp[i][j]表示合并i~j的最小代价。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mergeStones</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = stones.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) sum[i<span class="hljs-number">+1</span>] = sum[i] + stones[i];<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">1e9</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) dp[i][i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; ++len)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + len - <span class="hljs-number">1</span> &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt; j; ++k)<br>                dp[i][j] = std::<span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k<span class="hljs-number">+1</span>][j] + sum[j<span class="hljs-number">+1</span>] - sum[i]);<br>        &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n^3)。<br><strong>应用说明</strong>：工程区间合并、竞赛区间DP。</p><h2 id="7-常见优化与工程建议"><a href="#7-常见优化与工程建议" class="headerlink" title="7. 常见优化与工程建议"></a>7. 常见优化与工程建议</h2><ul><li>状态压缩、滚动数组降空间。</li><li>记忆化搜索适合树形&#x2F;无后效性问题。</li><li>工程优先用STL vector&#x2F;map等容器。</li><li>DP调试建议打印状态转移表。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找算法详解与C++实现</title>
    <link href="/2025/07/%E7%AE%97%E6%B3%95/02_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E7%AE%97%E6%B3%95/02_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找算法详解与C-实现"><a href="#二分查找算法详解与C-实现" class="headerlink" title="二分查找算法详解与C++实现"></a>二分查找算法详解与C++实现</h1><h2 id="1-二分查找原理（详细）"><a href="#1-二分查找原理（详细）" class="headerlink" title="1. 二分查找原理（详细）"></a>1. 二分查找原理（详细）</h2><p>二分查找（Binary Search）是一种在有序数组中高效查找目标值的位置的算法。其核心思想是每次将查找区间一分为二，逐步缩小范围，直到找到目标或区间为空。</p><ul><li><strong>前提条件</strong>：数组必须有序（升序或降序）。</li><li><strong>基本流程</strong>：<ol><li>设定区间左右端点<code>l</code>和<code>r</code>。</li><li>计算中点<code>mid = l + (r - l) / 2</code>，防止溢出。</li><li>比较<code>arr[mid]</code>与目标值<code>target</code>：<ul><li>若相等，返回mid。</li><li>若小于目标，左端点右移<code>l = mid + 1</code>。</li><li>若大于目标，右端点左移<code>r = mid - 1</code>。</li></ul></li><li>重复2-3步，直到<code>l &gt; r</code>。</li></ol></li><li><strong>常见变体</strong>：<ul><li>查找左&#x2F;右边界（lower&#x2F;upper bound）：用于查找第一个&#x2F;最后一个等于或大于&#x2F;小于目标的位置。</li><li>浮点二分：用于精度问题（如开方、数值逼近）。</li></ul></li><li><strong>常见陷阱</strong>：<ul><li>死循环：区间更新不当导致<code>l</code>和<code>r</code>无法收敛。</li><li>溢出：<code>(l + r) / 2</code>可能溢出，推荐<code>l + (r - l) / 2</code>。</li><li>边界条件：返回值和循环条件需严格区分不同变体。</li></ul></li></ul><h2 id="2-C-实现"><a href="#2-C-实现" class="headerlink" title="2. C++实现"></a>2. C++实现</h2><h3 id="2-1-标准二分查找"><a href="#2-1-标准二分查找" class="headerlink" title="2.1 标准二分查找"></a>2.1 标准二分查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回目标值下标，未找到返回-1</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;T&gt;&amp; arr, T target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] == target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-查找左-右边界"><a href="#2-2-查找左-右边界" class="headerlink" title="2.2 查找左&#x2F;右边界"></a>2.2 查找左&#x2F;右边界</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 查找第一个大于等于target的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowerBound</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 查找最后一个小于等于target的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">upperBound</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &lt;= target) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-浮点二分查找"><a href="#2-3-浮点二分查找" class="headerlink" title="2.3 浮点二分查找"></a>2.3 浮点二分查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 求sqrt(x)的近似值，精度eps</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrtBinary</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>)</span> </span>&#123;<br>    <span class="hljs-type">double</span> l = <span class="hljs-number">0</span>, r = x, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid &lt; x) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>时间复杂度：O(log n)</li><li>空间复杂度：O(1)</li></ul><h2 id="4-应用场景与典型题型"><a href="#4-应用场景与典型题型" class="headerlink" title="4. 应用场景与典型题型"></a>4. 应用场景与典型题型</h2><ul><li>有序数组查找、查找边界、数值逼近、最小化最大值&#x2F;最大化最小值问题、LeetCode区间类题目等。</li></ul><hr><p>如需更多算法专题，欢迎留言！ </p><h2 id="5-进阶原理细节与常见陷阱"><a href="#5-进阶原理细节与常见陷阱" class="headerlink" title="5. 进阶原理细节与常见陷阱"></a>5. 进阶原理细节与常见陷阱</h2><ul><li><strong>边界处理陷阱</strong>：二分查找的区间[l, r]和[l, r)写法不同，循环条件、返回值需严格区分。</li><li><strong>死循环问题</strong>：区间更新不当(l &#x3D; mid, r &#x3D; mid)会导致死循环，推荐l &#x3D; mid + 1或r &#x3D; mid - 1。</li><li><strong>溢出风险</strong>：mid &#x3D; (l + r) &#x2F; 2可能溢出，推荐mid &#x3D; l + (r - l) &#x2F; 2。</li><li><strong>浮点二分</strong>：精度判断用while(r - l &gt; eps)，避免死循环。</li><li><strong>单调性判定</strong>：二分适用前提是目标函数或区间具有单调性。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：力扣-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#案例1：力扣-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="案例1：力扣 34. 在排序数组中查找元素的第一个和最后一个位置"></a>案例1：力扣 34. 在排序数组中查找元素的第一个和最后一个位置</h3><p><strong>题意</strong>：给定有序数组，找target的左右边界。<br><strong>思路</strong>：分别用二分查找lower_bound和upper_bound。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowerBound</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">upperBound</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (arr[mid] &lt;= target) l = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)。<br><strong>应用说明</strong>：工程查找区间、竞赛常考。</p><h3 id="案例2：浮点二分求开方"><a href="#案例2：浮点二分求开方" class="headerlink" title="案例2：浮点二分求开方"></a>案例2：浮点二分求开方</h3><p><strong>题意</strong>：求sqrt(x)的近似值。<br><strong>思路</strong>：用浮点二分，精度控制。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrtBinary</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>)</span> </span>&#123;<br>    <span class="hljs-type">double</span> l = <span class="hljs-number">0</span>, r = x;<br>    <span class="hljs-keyword">while</span> (r - l &gt; eps) &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid &lt; x) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log(1&#x2F;eps))。<br><strong>应用说明</strong>：工程数值逼近。</p><h3 id="案例3：最小化最大值问题（如分配工作、最小最大距离）"><a href="#案例3：最小化最大值问题（如分配工作、最小最大距离）" class="headerlink" title="案例3：最小化最大值问题（如分配工作、最小最大距离）"></a>案例3：最小化最大值问题（如分配工作、最小最大距离）</h3><p><strong>题意</strong>：给定一组任务和工人，最小化最大工作量。<br><strong>思路</strong>：二分答案+贪心判定。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; jobs, <span class="hljs-type">int</span> limit, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : jobs) &#123;<br>        <span class="hljs-keyword">if</span> (sum + x &gt; limit) &#123; ++cnt; sum = <span class="hljs-number">0</span>; &#125;<br>        sum += x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt &lt;= k;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMaxWork</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; jobs, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = *std::<span class="hljs-built_in">max_element</span>(jobs.<span class="hljs-built_in">begin</span>(), jobs.<span class="hljs-built_in">end</span>()), r = std::<span class="hljs-built_in">accumulate</span>(jobs.<span class="hljs-built_in">begin</span>(), jobs.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(jobs, mid, k)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n log(sum))。<br><strong>应用说明</strong>：竞赛分配、工程调度。</p><h2 id="7-常见优化与工程建议"><a href="#7-常见优化与工程建议" class="headerlink" title="7. 常见优化与工程建议"></a>7. 常见优化与工程建议</h2><ul><li>优先用STL lower_bound&#x2F;upper_bound。</li><li>浮点二分注意精度和死循环。</li><li>二分答案+判定常用于最优化问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法详解与C++实现</title>
    <link href="/2025/07/%E7%AE%97%E6%B3%95/05_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E7%AE%97%E6%B3%95/05_%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法详解与C-实现"><a href="#贪心算法详解与C-实现" class="headerlink" title="贪心算法详解与C++实现"></a>贪心算法详解与C++实现</h1><h2 id="1-贪心算法原理（详细）"><a href="#1-贪心算法原理（详细）" class="headerlink" title="1. 贪心算法原理（详细）"></a>1. 贪心算法原理（详细）</h2><p>贪心算法（Greedy Algorithm）是一种在每一步都做出当前最优选择，期望通过局部最优达到全局最优的算法思想。</p><ul><li><strong>贪心选择性质</strong>：每一步的局部最优选择能导致全局最优。</li><li><strong>最优子结构</strong>：问题的最优解包含子问题的最优解。</li><li><strong>局部最优与全局最优</strong>：并非所有问题都适用贪心，需证明贪心选择能得到全局最优。</li><li><strong>常见陷阱</strong>：<ul><li>贪心策略错误导致非最优解。</li><li>需与动态规划区分，DP可回溯，贪心不可。</li><li>题目未满足贪心性质时强行贪心会出错。</li></ul></li></ul><h2 id="2-经典贪心题型与C-实现"><a href="#2-经典贪心题型与C-实现" class="headerlink" title="2. 经典贪心题型与C++实现"></a>2. 经典贪心题型与C++实现</h2><h3 id="2-1-区间选点问题"><a href="#2-1-区间选点问题" class="headerlink" title="2.1 区间选点问题"></a>2.1 区间选点问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 给定若干区间，选最少点覆盖所有区间</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Interval</span> &#123; <span class="hljs-type">int</span> l, r; &#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Interval&amp; a, <span class="hljs-type">const</span> Interval&amp; b)</span> </span>&#123; <span class="hljs-keyword">return</span> a.r &lt; b.r; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPointsCover</span><span class="hljs-params">(std::vector&lt;Interval&gt;&amp; intervals)</span> </span>&#123;<br>    std::<span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, last = <span class="hljs-number">-1e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : intervals) &#123;<br>        <span class="hljs-keyword">if</span> (it.l &gt; last) &#123;<br>            ++res;<br>            last = it.r;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-活动安排问题"><a href="#2-2-活动安排问题" class="headerlink" title="2.2 活动安排问题"></a>2.2 活动安排问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 区间不重叠最大数量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxNonOverlap</span><span class="hljs-params">(std::vector&lt;Interval&gt;&amp; intervals)</span> </span>&#123;<br>    std::<span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, last = <span class="hljs-number">-1e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : intervals) &#123;<br>        <span class="hljs-keyword">if</span> (it.l &gt;= last) &#123;<br>            ++res;<br>            last = it.r;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-最小生成树（Kruskal算法）"><a href="#2-3-最小生成树（Kruskal算法）" class="headerlink" title="2.3 最小生成树（Kruskal算法）"></a>2.3 最小生成树（Kruskal算法）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123; <span class="hljs-type">int</span> u, v, w; &#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmpE</span><span class="hljs-params">(<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b)</span> </span>&#123; <span class="hljs-keyword">return</span> a.w &lt; b.w; &#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; fa;<br>    <span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">fa</span>(n) &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) fa[i] = i; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (fx == fy) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        fa[fx] = fy; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">(<span class="hljs-type">int</span> n, std::vector&lt;Edge&gt;&amp; edges)</span> </span>&#123;<br>    std::<span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), cmpE);<br>    <span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>; <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : edges) &#123;<br>        <span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">unite</span>(e.u, e.v)) &#123;<br>            res += e.w;<br>            <span class="hljs-keyword">if</span> (++cnt == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n - <span class="hljs-number">1</span> ? res : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>时间复杂度：视具体贪心问题而定，常见如O(nlogn)</li><li>空间复杂度：O(1)~O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>区间调度、最小生成树、哈夫曼编码、背包近似、零钱兑换等。</li></ul><hr><h2 id="5-进阶原理细节与常见陷阱"><a href="#5-进阶原理细节与常见陷阱" class="headerlink" title="5. 进阶原理细节与常见陷阱"></a>5. 进阶原理细节与常见陷阱</h2><ul><li><strong>贪心选择性质判定</strong>：并非所有问题都可贪心，需证明贪心选择能达最优。</li><li><strong>局部最优≠全局最优</strong>：部分问题贪心解非最优，需与DP对比。</li><li><strong>排序策略陷阱</strong>：排序关键字选错会导致错误解。</li><li><strong>贪心与DP混用</strong>：部分问题可用贪心+DP混合优化。</li><li><strong>工程应用需证明正确性</strong>：工程中贪心策略需严格论证。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：区间覆盖（最少点覆盖所有区间）"><a href="#案例1：区间覆盖（最少点覆盖所有区间）" class="headerlink" title="案例1：区间覆盖（最少点覆盖所有区间）"></a>案例1：区间覆盖（最少点覆盖所有区间）</h3><p><strong>题意</strong>：给定若干区间，选最少点覆盖所有区间。<br><strong>思路</strong>：按右端点排序，贪心选点。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Interval</span> &#123; <span class="hljs-type">int</span> l, r; &#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Interval&amp; a, <span class="hljs-type">const</span> Interval&amp; b)</span> </span>&#123; <span class="hljs-keyword">return</span> a.r &lt; b.r; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPointsCover</span><span class="hljs-params">(std::vector&lt;Interval&gt;&amp; intervals)</span> </span>&#123;<br>    std::<span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, last = <span class="hljs-number">-1e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; it : intervals) &#123;<br>        <span class="hljs-keyword">if</span> (it.l &gt; last) &#123;<br>            ++res;<br>            last = it.r;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(nlogn)。<br><strong>应用说明</strong>：工程区间调度、竞赛常考。</p><h3 id="案例2：哈夫曼编码"><a href="#案例2：哈夫曼编码" class="headerlink" title="案例2：哈夫曼编码"></a>案例2：哈夫曼编码</h3><p><strong>题意</strong>：给定n个权值，构造最优前缀码。<br><strong>思路</strong>：每次合并最小的两个权值，贪心。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">huffman</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; w)</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pq</span>(w.<span class="hljs-built_in">begin</span>(), w.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pq.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> a = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> b = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br>        res += a + b;<br>        pq.<span class="hljs-built_in">push</span>(a + b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(nlogn)。<br><strong>应用说明</strong>：工程压缩、竞赛编码。</p><h3 id="案例3：最小生成树（Kruskal）"><a href="#案例3：最小生成树（Kruskal）" class="headerlink" title="案例3：最小生成树（Kruskal）"></a>案例3：最小生成树（Kruskal）</h3><p><strong>题意</strong>：无向图最小生成树。<br><strong>思路</strong>：按边权排序，贪心选边+并查集判环。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123; <span class="hljs-type">int</span> u, v, w; &#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmpE</span><span class="hljs-params">(<span class="hljs-type">const</span> Edge&amp; a, <span class="hljs-type">const</span> Edge&amp; b)</span> </span>&#123; <span class="hljs-keyword">return</span> a.w &lt; b.w; &#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; fa;<br>    <span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">fa</span>(n) &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) fa[i] = i; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (fx == fy) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        fa[fx] = fy; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">(<span class="hljs-type">int</span> n, std::vector&lt;Edge&gt;&amp; edges)</span> </span>&#123;<br>    std::<span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), cmpE);<br>    <span class="hljs-function">DSU <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>; <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : edges) &#123;<br>        <span class="hljs-keyword">if</span> (dsu.<span class="hljs-built_in">unite</span>(e.u, e.v)) &#123;<br>            res += e.w;<br>            <span class="hljs-keyword">if</span> (++cnt == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n - <span class="hljs-number">1</span> ? res : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(mlogm)。<br><strong>应用说明</strong>：工程网络设计、竞赛图论。</p><h2 id="7-常见优化与工程建议"><a href="#7-常见优化与工程建议" class="headerlink" title="7. 常见优化与工程建议"></a>7. 常见优化与工程建议</h2><ul><li>贪心策略需严格证明。</li><li>工程中优先用STL sort&#x2F;priority_queue。</li><li>复杂问题可用贪心+DP混合。</li><li>排序关键字需多样测试。</li></ul><p>如需更多算法专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法详解与C++实现</title>
    <link href="/2025/07/%E7%AE%97%E6%B3%95/06_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E7%AE%97%E6%B3%95/06_%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯算法详解与C-实现"><a href="#回溯算法详解与C-实现" class="headerlink" title="回溯算法详解与C++实现"></a>回溯算法详解与C++实现</h1><h2 id="1-回溯算法原理（详细）"><a href="#1-回溯算法原理（详细）" class="headerlink" title="1. 回溯算法原理（详细）"></a>1. 回溯算法原理（详细）</h2><p>回溯算法（Backtracking）是一种系统地搜索所有可能解的算法，常用于组合、排列、子集等问题。</p><ul><li><strong>状态空间树</strong>：所有可能解构成一棵树，节点为状态，边为选择。</li><li><strong>递归实现</strong>：每次递归代表一次决策，递归到叶子节点即为一个解。</li><li><strong>剪枝</strong>：在递归过程中提前排除不可能的分支，提升效率。</li><li><strong>解空间</strong>：所有可能的状态集合。</li><li><strong>常见陷阱</strong>：<ul><li>状态未回溯，导致结果错误。</li><li>剪枝条件不当，漏解或多解。</li><li>递归出口遗漏，死循环或栈溢出。</li></ul></li></ul><h2 id="2-经典回溯题型与C-实现"><a href="#2-经典回溯题型与C-实现" class="headerlink" title="2. 经典回溯题型与C++实现"></a>2. 经典回溯题型与C++实现</h2><h3 id="2-1-全排列"><a href="#2-1-全排列" class="headerlink" title="2.1 全排列"></a>2.1 全排列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">permuteHelper</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start == nums.<span class="hljs-built_in">size</span>()) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(nums);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        std::<span class="hljs-built_in">swap</span>(nums[start], nums[i]);<br>        <span class="hljs-built_in">permuteHelper</span>(nums, start + <span class="hljs-number">1</span>, res);<br>        std::<span class="hljs-built_in">swap</span>(nums[start], nums[i]); <span class="hljs-comment">// 回溯</span><br>    &#125;<br>&#125;<br>std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    <span class="hljs-built_in">permuteHelper</span>(nums, <span class="hljs-number">0</span>, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-子集"><a href="#2-2-子集" class="headerlink" title="2.2 子集"></a>2.2 子集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">subsetHelper</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> idx, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;<br>    res.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = idx; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">subsetHelper</span>(nums, i + <span class="hljs-number">1</span>, path, res);<br>        path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>    &#125;<br>&#125;<br>std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-built_in">subsetHelper</span>(nums, <span class="hljs-number">0</span>, path, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-N皇后问题"><a href="#2-3-N皇后问题" class="headerlink" title="2.3 N皇后问题"></a>2.3 N皇后问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveNQueensHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; col, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; diag1, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; diag2, std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; res, std::vector&lt;std::string&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (row == n) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(board);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt; n; ++c) &#123;<br>        <span class="hljs-keyword">if</span> (col[c] || diag1[row + c] || diag2[row - c + n - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        col[c] = diag1[row + c] = diag2[row - c + n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        board[row][c] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>        <span class="hljs-built_in">solveNQueensHelper</span>(n, row + <span class="hljs-number">1</span>, col, diag1, diag2, res, board);<br>        board[row][c] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        col[c] = diag1[row + c] = diag2[row - c + n - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br>std::vector&lt;std::vector&lt;std::string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>    std::vector&lt;std::vector&lt;std::string&gt;&gt; res;<br>    <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">board</span><span class="hljs-params">(n, std::string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">col</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">diag1</span><span class="hljs-params">(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">diag2</span><span class="hljs-params">(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">solveNQueensHelper</span>(n, <span class="hljs-number">0</span>, col, diag1, diag2, res, board);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>时间复杂度：视具体问题而定，通常为O(解空间大小)</li><li>空间复杂度：递归栈+结果集</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>组合、排列、子集、数独、N皇后、图着色、路径搜索等。</li></ul><hr><p>如需更多算法专题，欢迎留言！ </p><h2 id="5-进阶原理细节与常见陷阱"><a href="#5-进阶原理细节与常见陷阱" class="headerlink" title="5. 进阶原理细节与常见陷阱"></a>5. 进阶原理细节与常见陷阱</h2><ul><li><strong>状态未回溯</strong>：递归返回后未恢复现场，导致结果错误。</li><li><strong>剪枝条件遗漏</strong>：未及时剪枝，导致超时或冗余搜索。</li><li><strong>递归出口遗漏</strong>：无出口或出口条件错误，易死循环或爆栈。</li><li><strong>重复解去重</strong>：排列&#x2F;组合类问题需去重，常用排序+used数组。</li><li><strong>工程中递归层数过深</strong>：需考虑栈空间或用显式栈模拟。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：N皇后问题"><a href="#案例1：N皇后问题" class="headerlink" title="案例1：N皇后问题"></a>案例1：N皇后问题</h3><p><strong>题意</strong>：n×n棋盘放n个皇后，任意两皇后不同行、列、斜线。<br><strong>思路</strong>：回溯+列&#x2F;对角线标记。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveNQueensHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; col, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; diag1, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; diag2, std::vector&lt;std::vector&lt;std::string&gt;&gt;&amp; res, std::vector&lt;std::string&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (row == n) &#123; res.<span class="hljs-built_in">push_back</span>(board); <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt; n; ++c) &#123;<br>        <span class="hljs-keyword">if</span> (col[c] || diag1[row + c] || diag2[row - c + n - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        col[c] = diag1[row + c] = diag2[row - c + n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        board[row][c] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>        <span class="hljs-built_in">solveNQueensHelper</span>(n, row + <span class="hljs-number">1</span>, col, diag1, diag2, res, board);<br>        board[row][c] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        col[c] = diag1[row + c] = diag2[row - c + n - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br>std::vector&lt;std::vector&lt;std::string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>    std::vector&lt;std::vector&lt;std::string&gt;&gt; res;<br>    <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">board</span><span class="hljs-params">(n, std::string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">col</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">diag1</span><span class="hljs-params">(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">diag2</span><span class="hljs-params">(<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-built_in">solveNQueensHelper</span>(n, <span class="hljs-number">0</span>, col, diag1, diag2, res, board);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n!)。<br><strong>应用说明</strong>：竞赛经典、工程排班。</p><h3 id="案例2：子集和问题"><a href="#案例2：子集和问题" class="headerlink" title="案例2：子集和问题"></a>案例2：子集和问题</h3><p><strong>题意</strong>：给定数组，判断是否存在子集和为target。<br><strong>思路</strong>：回溯枚举所有子集。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">subsetSum</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (idx == nums.<span class="hljs-built_in">size</span>() || target &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">subsetSum</span>(nums, idx + <span class="hljs-number">1</span>, target - nums[idx]) || <span class="hljs-built_in">subsetSum</span>(nums, idx + <span class="hljs-number">1</span>, target);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(2^n)。<br><strong>应用说明</strong>：工程资源分配、竞赛子集。</p><h3 id="案例3：全排列去重"><a href="#案例3：全排列去重" class="headerlink" title="案例3：全排列去重"></a>案例3：全排列去重</h3><p><strong>题意</strong>：含重复数字的全排列，去重输出。<br><strong>思路</strong>：排序+used数组+剪枝。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">permuteUniqueHelper</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, std::vector&lt;<span class="hljs-type">bool</span>&gt;&amp; used, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>()) &#123; res.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (used[i] || (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &amp;&amp; !used[i<span class="hljs-number">-1</span>])) <span class="hljs-keyword">continue</span>;<br>        used[i] = <span class="hljs-literal">true</span>; path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">permuteUniqueHelper</span>(nums, used, path, res);<br>        path.<span class="hljs-built_in">pop_back</span>(); used[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br>std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>    std::<span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; res; std::vector&lt;<span class="hljs-type">int</span>&gt; path; <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-built_in">permuteUniqueHelper</span>(nums, used, path, res); <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n!)。<br><strong>应用说明</strong>：竞赛排列、工程去重。</p><h2 id="7-常见优化与工程建议"><a href="#7-常见优化与工程建议" class="headerlink" title="7. 常见优化与工程建议"></a>7. 常见优化与工程建议</h2><ul><li>剪枝条件越早越好。</li><li>工程中优先用STL vector&#x2F;stack等容器。</li><li>递归层数深时考虑尾递归或显式栈。</li><li>回溯常与DP&#x2F;贪心结合优化。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集算法详解与C++实现</title>
    <link href="/2025/07/%E7%AE%97%E6%B3%95/07_%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E7%AE%97%E6%B3%95/07_%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集算法详解与C-实现"><a href="#并查集算法详解与C-实现" class="headerlink" title="并查集算法详解与C++实现"></a>并查集算法详解与C++实现</h1><h2 id="1-并查集原理（详细）"><a href="#1-并查集原理（详细）" class="headerlink" title="1. 并查集原理（详细）"></a>1. 并查集原理（详细）</h2><p>并查集（Union-Find&#x2F;Disjoint Set Union, DSU）是一种高效处理集合合并与查询的数据结构，常用于连通性判定、分组等问题。</p><ul><li><strong>集合合并</strong>：支持将两个集合合并为一个。</li><li><strong>路径压缩</strong>：在查找根节点时，将路径上的所有节点直接指向根，极大优化查询效率。</li><li><strong>按秩合并</strong>：合并时将小树挂到大树下，减少树高。</li><li><strong>常见陷阱</strong>：<ul><li>未做路径压缩，导致查询退化为链表，效率低下。</li><li>合并时未按秩，树高过大。</li><li>下标越界、初始化错误。</li></ul></li></ul><h2 id="2-C-实现"><a href="#2-C-实现" class="headerlink" title="2. C++实现"></a>2. C++实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span> &#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; fa, rank;<br>    <span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">fa</span>(n), <span class="hljs-built_in">rank</span>(n, <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) fa[i] = i;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (fa[x] != x) fa[x] = <span class="hljs-built_in">find</span>(fa[x]); <span class="hljs-comment">// 路径压缩</span><br>        <span class="hljs-keyword">return</span> fa[x];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (fx == fy) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (rank[fx] &lt; rank[fy]) std::<span class="hljs-built_in">swap</span>(fx, fy);<br>        fa[fy] = fx;<br>        <span class="hljs-keyword">if</span> (rank[fx] == rank[fy]) ++rank[fx];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>单次操作均摊O(α(n))，α为反阿克曼函数，极慢。</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>连通分量、网络分组、最小生成树、冗余连接检测、朋友圈、岛屿数量等。</li></ul><hr><p>如需更多算法专题，欢迎留言！ </p><h2 id="5-进阶原理细节与常见陷阱"><a href="#5-进阶原理细节与常见陷阱" class="headerlink" title="5. 进阶原理细节与常见陷阱"></a>5. 进阶原理细节与常见陷阱</h2><ul><li><strong>路径压缩与按秩合并</strong>：两者结合可将均摊复杂度降至O(α(n))。</li><li><strong>初始化陷阱</strong>：fa和rank数组需正确初始化。</li><li><strong>合并顺序</strong>：合并时应将小树挂大树，避免退化。</li><li><strong>工程应用</strong>：并查集常用于连通性、冗余连接检测、动态连通分量统计。</li><li><strong>竞赛陷阱</strong>：下标越界、未路径压缩、未判重合并。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：力扣-547-省份数量（连通分量）"><a href="#案例1：力扣-547-省份数量（连通分量）" class="headerlink" title="案例1：力扣 547. 省份数量（连通分量）"></a>案例1：力扣 547. 省份数量（连通分量）</h3><p><strong>题意</strong>：给定n个城市的连接关系，求连通块数量。<br><strong>思路</strong>：并查集合并连通城市，统计根节点数量。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = isConnected.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fa</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) fa[i] = i;<br>    <span class="hljs-keyword">auto</span> find = [&amp;](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">while</span> (fa[x] != x) x = fa[x] = fa[fa[x]]; <span class="hljs-keyword">return</span> x; &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j)<br>            <span class="hljs-keyword">if</span> (isConnected[i][j]) fa[<span class="hljs-built_in">find</span>(i)] = <span class="hljs-built_in">find</span>(j);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (fa[i] == i) ++cnt;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n^2)。<br><strong>应用说明</strong>：工程社交网络、竞赛连通性。</p><h3 id="案例2：冗余连接检测"><a href="#案例2：冗余连接检测" class="headerlink" title="案例2：冗余连接检测"></a>案例2：冗余连接检测</h3><p><strong>题意</strong>：无向图加边，判断是否成环。<br><strong>思路</strong>：每加一条边用并查集判根是否相同。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fa</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) fa[i] = i;<br>    <span class="hljs-keyword">auto</span> find = [&amp;](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">while</span> (fa[x] != x) x = fa[x] = fa[fa[x]]; <span class="hljs-keyword">return</span> x; &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : edges) &#123;<br>        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(e.first), fy = <span class="hljs-built_in">find</span>(e.second);<br>        <span class="hljs-keyword">if</span> (fx == fy) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        fa[fx] = fy;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(mα(n))。<br><strong>应用说明</strong>：工程网络冗余、竞赛判环。</p><h3 id="案例3：在线连通分量统计"><a href="#案例3：在线连通分量统计" class="headerlink" title="案例3：在线连通分量统计"></a>案例3：在线连通分量统计</h3><p><strong>题意</strong>：动态加边，实时统计连通块数量。<br><strong>思路</strong>：并查集维护根节点数。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DSU</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; fa, sz;<br>    <span class="hljs-type">int</span> cnt;<br>    <span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">fa</span>(n), <span class="hljs-built_in">sz</span>(n, <span class="hljs-number">1</span>), <span class="hljs-built_in">cnt</span>(n) &#123; <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) fa[i] = i; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (fx == fy) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        fa[fx] = fy; sz[fy] += sz[fx]; --cnt; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(α(n))。<br><strong>应用说明</strong>：工程动态网络、竞赛在线题。</p><h2 id="7-常见优化与工程建议"><a href="#7-常见优化与工程建议" class="headerlink" title="7. 常见优化与工程建议"></a>7. 常见优化与工程建议</h2><ul><li>路径压缩+按秩合并。</li><li>工程中优先用类封装。</li><li>竞赛注意下标、初始化、判重。</li><li>并查集常与图论、贪心结合。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP字符串匹配算法详解与C++实现</title>
    <link href="/2025/07/%E7%AE%97%E6%B3%95/08_KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E7%AE%97%E6%B3%95/08_KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="KMP字符串匹配算法详解与C-实现"><a href="#KMP字符串匹配算法详解与C-实现" class="headerlink" title="KMP字符串匹配算法详解与C++实现"></a>KMP字符串匹配算法详解与C++实现</h1><h2 id="1-KMP原理（详细）"><a href="#1-KMP原理（详细）" class="headerlink" title="1. KMP原理（详细）"></a>1. KMP原理（详细）</h2><p>KMP（Knuth-Morris-Pratt）算法是一种高效的字符串匹配算法，核心思想是利用已匹配的信息避免重复匹配。</p><ul><li><strong>前缀函数（next数组）</strong>：next[i]表示模式串P[0..i]的最长相等前后缀长度。</li><li><strong>失配指针</strong>：匹配失败时，主串指针不回退，模式串跳到next[j-1]。</li><li><strong>自动机思想</strong>：KMP本质上是有限状态自动机的实现。</li><li><strong>常见陷阱</strong>：<ul><li>next数组下标混淆，导致死循环或漏匹配。</li><li>边界条件处理不当。</li><li>模式串为空或主串为空时特殊处理。</li></ul></li></ul><h2 id="2-C-实现"><a href="#2-C-实现" class="headerlink" title="2. C++实现"></a>2. C++实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 构建next数组</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">buildNext</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; pat)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = pat.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; pat[i] != pat[j]) j = next[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (pat[i] == pat[j]) ++j;<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br><span class="hljs-comment">// KMP主过程</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; txt, <span class="hljs-type">const</span> std::string&amp; pat)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pat.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; next = <span class="hljs-built_in">buildNext</span>(pat);<br>    <span class="hljs-type">int</span> n = txt.<span class="hljs-built_in">size</span>(), m = pat.<span class="hljs-built_in">size</span>(), j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; txt[i] != pat[j]) j = next[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (txt[i] == pat[j]) ++j;<br>        <span class="hljs-keyword">if</span> (j == m) <span class="hljs-keyword">return</span> i - m + <span class="hljs-number">1</span>; <span class="hljs-comment">// 匹配成功</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>时间复杂度：O(n + m)</li><li>空间复杂度：O(m)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>字符串查找、文本编辑器、DNA序列分析、日志分析等。</li></ul><hr><p>如需更多算法专题，欢迎留言！ </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>KMP</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trie字典树算法详解与C++实现</title>
    <link href="/2025/07/%E7%AE%97%E6%B3%95/09_Trie%E5%AD%97%E5%85%B8%E6%A0%91%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E7%AE%97%E6%B3%95/09_Trie%E5%AD%97%E5%85%B8%E6%A0%91%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Trie字典树算法详解与C-实现"><a href="#Trie字典树算法详解与C-实现" class="headerlink" title="Trie字典树算法详解与C++实现"></a>Trie字典树算法详解与C++实现</h1><h2 id="1-Trie原理（详细）"><a href="#1-Trie原理（详细）" class="headerlink" title="1. Trie原理（详细）"></a>1. Trie原理（详细）</h2><p>Trie（字典树&#x2F;前缀树）是一种高效存储和查找字符串集合的数据结构，常用于前缀匹配、自动补全等。</p><ul><li><strong>树结构</strong>：每个节点表示一个字符，根节点为空，路径为字符串。</li><li><strong>节点设计</strong>：每个节点包含若干子节点和是否为单词结尾的标记。</li><li><strong>插入&#x2F;查找&#x2F;删除</strong>：插入沿路径新建节点，查找沿路径遍历，删除需处理节点回收。</li><li><strong>空间优化</strong>：可用数组、哈希表、压缩Trie等优化空间。</li><li><strong>常见陷阱</strong>：<ul><li>节点未正确回收，导致内存泄漏。</li><li>字符集未覆盖所有输入字符。</li><li>删除操作遗漏子树处理。</li></ul></li></ul><h2 id="2-C-实现"><a href="#2-C-实现" class="headerlink" title="2. C++实现"></a>2. C++实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>    <span class="hljs-type">bool</span> isEnd;<br>    std::unordered_map&lt;<span class="hljs-type">char</span>, TrieNode*&gt; children;<br>    <span class="hljs-built_in">TrieNode</span>() : <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>() &#123; root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; word)</span> </span>&#123;<br>        TrieNode* node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word) &#123;<br>            <span class="hljs-keyword">if</span> (!node-&gt;children.<span class="hljs-built_in">count</span>(c)) node-&gt;children[c] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>            node = node-&gt;children[c];<br>        &#125;<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; word)</span> </span>&#123;<br>        TrieNode* node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word) &#123;<br>            <span class="hljs-keyword">if</span> (!node-&gt;children.<span class="hljs-built_in">count</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            node = node-&gt;children[c];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;isEnd;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; prefix)</span> </span>&#123;<br>        TrieNode* node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : prefix) &#123;<br>            <span class="hljs-keyword">if</span> (!node-&gt;children.<span class="hljs-built_in">count</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            node = node-&gt;children[c];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 删除操作（递归）</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(TrieNode* node, <span class="hljs-type">const</span> std::string&amp; word, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (d == word.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (!node-&gt;isEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            node-&gt;isEnd = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> node-&gt;children.<span class="hljs-built_in">empty</span>();<br>        &#125;<br>        <span class="hljs-type">char</span> c = word[d];<br>        <span class="hljs-keyword">if</span> (!node-&gt;children.<span class="hljs-built_in">count</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> shouldDelete = <span class="hljs-built_in">remove</span>(node-&gt;children[c], word, d + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (shouldDelete) &#123;<br>            <span class="hljs-keyword">delete</span> node-&gt;children[c];<br>            node-&gt;children.<span class="hljs-built_in">erase</span>(c);<br>            <span class="hljs-keyword">return</span> node-&gt;children.<span class="hljs-built_in">empty</span>() &amp;&amp; !node-&gt;isEnd;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; word)</span> </span>&#123; <span class="hljs-built_in">remove</span>(root, word, <span class="hljs-number">0</span>); &#125;<br>    ~<span class="hljs-built_in">Trie</span>() &#123; <span class="hljs-comment">/* 递归释放所有节点，略 */</span> &#125;<br><span class="hljs-keyword">private</span>:<br>    TrieNode* root;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>插入&#x2F;查找&#x2F;删除：O(L)，L为字符串长度</li><li>空间复杂度：O(字符集大小 × 总字符数)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>前缀匹配、自动补全、敏感词过滤、IP路由、字符串统计等。</li></ul><hr><p>如需更多算法专题，欢迎留言！ </p><h2 id="5-进阶原理细节与常见陷阱"><a href="#5-进阶原理细节与常见陷阱" class="headerlink" title="5. 进阶原理细节与常见陷阱"></a>5. 进阶原理细节与常见陷阱</h2><ul><li><strong>节点内存管理</strong>：递归删除节点防止内存泄漏。</li><li><strong>字符集处理</strong>：Trie节点需覆盖所有可能字符，工程中常用unordered_map或定长数组。</li><li><strong>前缀冲突</strong>：插入&#x2F;删除时需正确处理前缀关系。</li><li><strong>竞赛陷阱</strong>：未初始化节点、未处理空串、递归深度过大。</li><li><strong>工程应用</strong>：Trie常用于前缀检索、敏感词过滤、自动补全、IP路由等。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：前缀统计"><a href="#案例1：前缀统计" class="headerlink" title="案例1：前缀统计"></a>案例1：前缀统计</h3><p><strong>题意</strong>：统计所有以某前缀开头的单词数量。<br><strong>思路</strong>：Trie节点维护计数。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>    <span class="hljs-type">int</span> cnt; <span class="hljs-type">bool</span> isEnd;<br>    std::unordered_map&lt;<span class="hljs-type">char</span>, TrieNode*&gt; children;<br>    <span class="hljs-built_in">TrieNode</span>() : <span class="hljs-built_in">cnt</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>() &#123; root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; word)</span> </span>&#123;<br>        TrieNode* node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word) &#123;<br>            <span class="hljs-keyword">if</span> (!node-&gt;children.<span class="hljs-built_in">count</span>(c)) node-&gt;children[c] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>            node = node-&gt;children[c];<br>            node-&gt;cnt++;<br>        &#125;<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrefix</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; prefix)</span> </span>&#123;<br>        TrieNode* node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : prefix) &#123;<br>            <span class="hljs-keyword">if</span> (!node-&gt;children.<span class="hljs-built_in">count</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            node = node-&gt;children[c];<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(L)。<br><strong>应用说明</strong>：工程搜索提示、竞赛前缀统计。</p><h3 id="案例2：敏感词过滤"><a href="#案例2：敏感词过滤" class="headerlink" title="案例2：敏感词过滤"></a>案例2：敏感词过滤</h3><p><strong>题意</strong>：判断文本中是否包含敏感词。<br><strong>思路</strong>：Trie+多模式串匹配。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsSensitive</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; text, Trie&amp; trie)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; text.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        TrieNode* node = trie.root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; text.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!node-&gt;children.<span class="hljs-built_in">count</span>(text[j])) <span class="hljs-keyword">break</span>;<br>            node = node-&gt;children[text[j]];<br>            <span class="hljs-keyword">if</span> (node-&gt;isEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(nL)。<br><strong>应用说明</strong>：工程内容安全、竞赛多模式匹配。</p><h3 id="案例3：IP路由前缀匹配"><a href="#案例3：IP路由前缀匹配" class="headerlink" title="案例3：IP路由前缀匹配"></a>案例3：IP路由前缀匹配</h3><p><strong>题意</strong>：给定IP前缀集合，查询IP最优匹配前缀。<br><strong>思路</strong>：Trie按位存储，查询最长前缀。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TrieNode2</span> &#123;<br>    <span class="hljs-type">bool</span> isEnd; TrieNode2* child[<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">TrieNode2</span>() : <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123; child[<span class="hljs-number">0</span>]=child[<span class="hljs-number">1</span>]=<span class="hljs-literal">nullptr</span>; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IPTrie</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">IPTrie</span>() &#123; root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode2</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> ip, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        TrieNode2* node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">32</span>-len; --i) &#123;<br>            <span class="hljs-type">int</span> b = (ip &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (!node-&gt;child[b]) node-&gt;child[b] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode2</span>();<br>            node = node-&gt;child[b];<br>        &#125;<br>        node-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> ip)</span> </span>&#123;<br>        TrieNode2* node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">int</span> b = (ip &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (!node-&gt;child[b]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            node = node-&gt;child[b];<br>            <span class="hljs-keyword">if</span> (node-&gt;isEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    TrieNode2* root;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(32)。<br><strong>应用说明</strong>：工程网络、竞赛路由。</p><h2 id="7-常见优化与工程建议"><a href="#7-常见优化与工程建议" class="headerlink" title="7. 常见优化与工程建议"></a>7. 常见优化与工程建议</h2><ul><li>工程优先用unordered_map或定长数组。</li><li>节点内存需递归释放。</li><li>Trie常与KMP&#x2F;AC自动机结合。</li><li>前缀统计、自动补全等高频应用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>Trie</tag>
      
      <tag>字典树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆与优先队列算法详解与C++实现</title>
    <link href="/2025/07/%E7%AE%97%E6%B3%95/10_%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E7%AE%97%E6%B3%95/10_%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="堆与优先队列算法详解与C-实现"><a href="#堆与优先队列算法详解与C-实现" class="headerlink" title="堆与优先队列算法详解与C++实现"></a>堆与优先队列算法详解与C++实现</h1><h2 id="1-堆原理（详细）"><a href="#1-堆原理（详细）" class="headerlink" title="1. 堆原理（详细）"></a>1. 堆原理（详细）</h2><p>堆（Heap）是一种完全二叉树结构，分为大根堆（最大堆）和小根堆（最小堆），常用于优先队列、TopK、堆排序等。</p><ul><li><strong>二叉堆结构</strong>：用数组实现，父子节点下标关系：左2i+1，右2i+2。</li><li><strong>上浮&#x2F;下沉</strong>：插入时上浮，删除堆顶时下沉，保持堆性质。</li><li><strong>堆化</strong>：将无序数组调整为堆结构。</li><li><strong>堆排序</strong>：利用堆结构实现O(nlogn)排序。</li><li><strong>常见陷阱</strong>：<ul><li>堆下标越界。</li><li>上浮&#x2F;下沉条件写错。</li><li>堆化时未从最后一个非叶节点开始。</li></ul></li></ul><h2 id="2-C-实现"><a href="#2-C-实现" class="headerlink" title="2. C++实现"></a>2. C++实现</h2><h3 id="2-1-手写堆"><a href="#2-1-手写堆" class="headerlink" title="2.1 手写堆"></a>2.1 手写堆</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Heap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        data.<span class="hljs-built_in">push_back</span>(x);<br>        <span class="hljs-built_in">up</span>(data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        std::<span class="hljs-built_in">swap</span>(data[<span class="hljs-number">0</span>], data.<span class="hljs-built_in">back</span>());<br>        data.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> data[<span class="hljs-number">0</span>]; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">empty</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> p = (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (data[p] &gt;= data[i]) <span class="hljs-keyword">break</span>;<br>            std::<span class="hljs-built_in">swap</span>(data[p], data[i]);<br>            i = p;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = data.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span> &lt; n) &#123;<br>            <span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; n &amp;&amp; data[j + <span class="hljs-number">1</span>] &gt; data[j]) ++j;<br>            <span class="hljs-keyword">if</span> (data[i] &gt;= data[j]) <span class="hljs-keyword">break</span>;<br>            std::<span class="hljs-built_in">swap</span>(data[i], data[j]);<br>            i = j;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-2-STL优先队列"><a href="#2-2-STL优先队列" class="headerlink" title="2.2 STL优先队列"></a>2.2 STL优先队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>std::priority_queue&lt;<span class="hljs-type">int</span>&gt; pq; <span class="hljs-comment">// 大根堆</span><br>std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; minpq; <span class="hljs-comment">// 小根堆</span><br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>插入&#x2F;删除堆顶：O(log n)</li><li>堆化：O(n)</li><li>堆排序：O(nlog n)</li><li>空间复杂度：O(n)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>优先队列、TopK、堆排序、区间合并、实时中位数、图最短路等。</li></ul><hr><p>如需更多算法专题，欢迎留言！ </p><h2 id="5-进阶原理细节与常见陷阱"><a href="#5-进阶原理细节与常见陷阱" class="headerlink" title="5. 进阶原理细节与常见陷阱"></a>5. 进阶原理细节与常见陷阱</h2><ul><li><strong>堆下标越界</strong>：堆操作时注意边界，避免越界。</li><li><strong>堆化起点</strong>：建堆时应从最后一个非叶节点开始。</li><li><strong>自定义比较器</strong>：STL优先队列自定义类型需重载operator&lt;或传入仿函数。</li><li><strong>TopK问题</strong>：大数据流TopK常用小根堆维护。</li><li><strong>工程应用</strong>：堆常用于调度、实时中位数、A*等。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：数据流中位数"><a href="#案例1：数据流中位数" class="headerlink" title="案例1：数据流中位数"></a>案例1：数据流中位数</h3><p><strong>题意</strong>：动态插入数据，实时输出中位数。<br><strong>思路</strong>：用大根堆+小根堆维护左右两部分。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>&gt; maxq;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; minq;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (maxq.<span class="hljs-built_in">empty</span>() || num &lt;= maxq.<span class="hljs-built_in">top</span>()) maxq.<span class="hljs-built_in">push</span>(num);<br>        <span class="hljs-keyword">else</span> minq.<span class="hljs-built_in">push</span>(num);<br>        <span class="hljs-keyword">if</span> (maxq.<span class="hljs-built_in">size</span>() &gt; minq.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) &#123; minq.<span class="hljs-built_in">push</span>(maxq.<span class="hljs-built_in">top</span>()); maxq.<span class="hljs-built_in">pop</span>(); &#125;<br>        <span class="hljs-keyword">if</span> (minq.<span class="hljs-built_in">size</span>() &gt; maxq.<span class="hljs-built_in">size</span>()) &#123; maxq.<span class="hljs-built_in">push</span>(minq.<span class="hljs-built_in">top</span>()); minq.<span class="hljs-built_in">pop</span>(); &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (maxq.<span class="hljs-built_in">size</span>() == minq.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> (maxq.<span class="hljs-built_in">top</span>() + minq.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">return</span> maxq.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(log n)每次插入。<br><strong>应用说明</strong>：工程实时统计、竞赛经典。</p><h3 id="案例2：TopK问题"><a href="#案例2：TopK问题" class="headerlink" title="案例2：TopK问题"></a>案例2：TopK问题</h3><p><strong>题意</strong>：动态维护前K大元素。<br><strong>思路</strong>：用小根堆维护K个最大值。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topK</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>        pq.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>() &gt; k) pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123; res.<span class="hljs-built_in">push_back</span>(pq.<span class="hljs-built_in">top</span>()); pq.<span class="hljs-built_in">pop</span>(); &#125;<br>    std::<span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(nlogk)。<br><strong>应用说明</strong>：工程大数据、竞赛TopK。</p><h3 id="案例3：A-最短路"><a href="#案例3：A-最短路" class="headerlink" title="案例3：A*最短路"></a>案例3：A*最短路</h3><p><strong>题意</strong>：带启发式的最短路搜索。<br><strong>思路</strong>：优先队列按f&#x3D;g+h排序。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123; <span class="hljs-type">int</span> id, f, g, h; <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Node&amp; o) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> f &gt; o.f; &#125; &#125;;<br>std::priority_queue&lt;Node&gt; pq;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(ElogV)。<br><strong>应用说明</strong>：工程路径规划、竞赛图论。</p><h2 id="7-常见优化与工程建议"><a href="#7-常见优化与工程建议" class="headerlink" title="7. 常见优化与工程建议"></a>7. 常见优化与工程建议</h2><ul><li>优先用STL priority_queue。</li><li>TopK&#x2F;中位数等用堆高效实现。</li><li>自定义类型需重载operator&lt;。</li><li>堆常与贪心、图论结合。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图最短路算法详解与C++实现</title>
    <link href="/2025/07/%E7%AE%97%E6%B3%95/11_%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/%E7%AE%97%E6%B3%95/11_%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%B8%8EC++%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="图最短路算法详解与C-实现"><a href="#图最短路算法详解与C-实现" class="headerlink" title="图最短路算法详解与C++实现"></a>图最短路算法详解与C++实现</h1><h2 id="1-最短路原理（详细）"><a href="#1-最短路原理（详细）" class="headerlink" title="1. 最短路原理（详细）"></a>1. 最短路原理（详细）</h2><p>图的最短路问题是指在加权图中，寻找从起点到各点的最短路径。常见算法有Dijkstra、SPFA、Floyd、Bellman-Ford等。</p><ul><li><strong>Dijkstra算法</strong>：适用于非负权图，利用贪心思想，每次扩展当前最短路径点，常用堆优化。</li><li><strong>SPFA算法</strong>：Bellman-Ford的队列优化，适合稀疏图和有负权边。</li><li><strong>Floyd算法</strong>：多源最短路，适合点数较少的全局最短路。</li><li><strong>Bellman-Ford算法</strong>：可处理负权边，能检测负环。</li><li><strong>常见陷阱</strong>：<ul><li>Dijkstra不能处理负权边。</li><li>SPFA可能被卡成O(nm)（极端数据）。</li><li>Floyd空间O(n^2)，大图慎用。</li><li>边界初始化、松弛条件易错。</li></ul></li></ul><h2 id="2-C-实现"><a href="#2-C-实现" class="headerlink" title="2. C++实现"></a>2. C++实现</h2><h3 id="2-1-Dijkstra堆优化"><a href="#2-1-Dijkstra堆优化" class="headerlink" title="2.1 Dijkstra堆优化"></a>2.1 Dijkstra堆优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123; <span class="hljs-type">int</span> to, w; &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> s, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;Edge&gt;&gt;&amp; g, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dist)</span> </span>&#123;<br>    dist.<span class="hljs-built_in">assign</span>(n, INT_MAX); dist[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">using</span> P = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;; <span class="hljs-comment">// (dist, node)</span><br>    std::priority_queue&lt;P, std::vector&lt;P&gt;, std::greater&lt;P&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [d, u] = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (d &gt; dist[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : g[u]) &#123;<br>            <span class="hljs-keyword">if</span> (dist[e.to] &gt; dist[u] + e.w) &#123;<br>                dist[e.to] = dist[u] + e.w;<br>                pq.<span class="hljs-built_in">push</span>(&#123;dist[e.to], e.to&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-Floyd算法"><a href="#2-2-Floyd算法" class="headerlink" title="2.2 Floyd算法"></a>2.2 Floyd算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">(<span class="hljs-type">int</span> n, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dist)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (dist[i][k] &lt; INT_MAX &amp;&amp; dist[k][j] &lt; INT_MAX)<br>                    dist[i][j] = std::<span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-Bellman-Ford算法"><a href="#2-3-Bellman-Ford算法" class="headerlink" title="2.3 Bellman-Ford算法"></a>2.3 Bellman-Ford算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge2</span> &#123; <span class="hljs-type">int</span> u, v, w; &#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bellmanFord</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> s, <span class="hljs-type">const</span> std::vector&lt;Edge2&gt;&amp; edges, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dist)</span> </span>&#123;<br>    dist.<span class="hljs-built_in">assign</span>(n, INT_MAX); dist[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : edges) &#123;<br>            <span class="hljs-keyword">if</span> (dist[e.u] &lt; INT_MAX &amp;&amp; dist[e.v] &gt; dist[e.u] + e.w)<br>                dist[e.v] = dist[e.u] + e.w;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检测负环</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : edges) &#123;<br>        <span class="hljs-keyword">if</span> (dist[e.u] &lt; INT_MAX &amp;&amp; dist[e.v] &gt; dist[e.u] + e.w)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 存在负环</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3. 复杂度分析"></a>3. 复杂度分析</h2><ul><li>Dijkstra堆优化：O((n+m)log n)</li><li>Floyd：O(n^3)</li><li>Bellman-Ford：O(nm)</li><li>空间复杂度：O(n^2)或O(n+m)</li></ul><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h2><ul><li>单源&#x2F;多源最短路、路径规划、网络路由、交通调度、负环检测等。</li></ul><hr><p>如需更多算法专题，欢迎留言！ </p><h2 id="5-进阶原理细节与常见陷阱"><a href="#5-进阶原理细节与常见陷阱" class="headerlink" title="5. 进阶原理细节与常见陷阱"></a>5. 进阶原理细节与常见陷阱</h2><ul><li><strong>Dijkstra不支持负权边</strong>：有负权边需用Bellman-Ford或SPFA。</li><li><strong>Floyd空间消耗大</strong>：点数大时慎用，适合稠密小图。</li><li><strong>SPFA极端卡常</strong>：部分数据可退化为O(nm)，竞赛需判负环。</li><li><strong>松弛条件易错</strong>：dist[v] &gt; dist[u] + w，注意初值和溢出。</li><li><strong>工程应用</strong>：最短路常用于路由、调度、地图导航、网络流等。</li></ul><h2 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h2><h3 id="案例1：单源最短路路径还原"><a href="#案例1：单源最短路路径还原" class="headerlink" title="案例1：单源最短路路径还原"></a>案例1：单源最短路路径还原</h3><p><strong>题意</strong>：输出从源点到终点的最短路径。<br><strong>思路</strong>：Dijkstra&#x2F;Bellman-Ford记录前驱数组，回溯路径。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstraPath</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> s, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;Edge&gt;&gt;&amp; g, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dist, std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre)</span> </span>&#123;<br>    dist.<span class="hljs-built_in">assign</span>(n, INT_MAX); pre.<span class="hljs-built_in">assign</span>(n, <span class="hljs-number">-1</span>); dist[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">using</span> P = std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br>    std::priority_queue&lt;P, std::vector&lt;P&gt;, std::greater&lt;P&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, s&#125;);<br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [d, u] = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (d &gt; dist[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : g[u]) &#123;<br>            <span class="hljs-keyword">if</span> (dist[e.to] &gt; dist[u] + e.w) &#123;<br>                dist[e.to] = dist[u] + e.w;<br>                pre[e.to] = u;<br>                pq.<span class="hljs-built_in">push</span>(&#123;dist[e.to], e.to&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getPath</span><span class="hljs-params">(<span class="hljs-type">int</span> t, <span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; pre)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-keyword">for</span> (; t != <span class="hljs-number">-1</span>; t = pre[t]) path.<span class="hljs-built_in">push_back</span>(t);<br>    std::<span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> path;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O((n+m)logn)。<br><strong>应用说明</strong>：工程路径规划、竞赛路径输出。</p><h3 id="案例2：负环检测（Bellman-Ford）"><a href="#案例2：负环检测（Bellman-Ford）" class="headerlink" title="案例2：负环检测（Bellman-Ford）"></a>案例2：负环检测（Bellman-Ford）</h3><p><strong>题意</strong>：判断图中是否存在负权环。<br><strong>思路</strong>：Bellman-Ford松弛n-1次后再松弛一次，若有更新则有负环。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasNegativeCycle</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">const</span> std::vector&lt;Edge2&gt;&amp; edges)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : edges)<br>            <span class="hljs-keyword">if</span> (dist[e.v] &gt; dist[e.u] + e.w)<br>                dist[e.v] = dist[e.u] + e.w;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; e : edges)<br>        <span class="hljs-keyword">if</span> (dist[e.v] &gt; dist[e.u] + e.w)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(nm)。<br><strong>应用说明</strong>：工程金融风控、竞赛负环判定。</p><h3 id="案例3：多源最短路（Floyd）"><a href="#案例3：多源最短路（Floyd）" class="headerlink" title="案例3：多源最短路（Floyd）"></a>案例3：多源最短路（Floyd）</h3><p><strong>题意</strong>：任意两点间最短路。<br><strong>思路</strong>：Floyd三重循环。<br><strong>C++代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">(<span class="hljs-type">int</span> n, std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dist)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (dist[i][k] &lt; INT_MAX &amp;&amp; dist[k][j] &lt; INT_MAX)<br>                    dist[i][j] = std::<span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度</strong>：O(n^3)。<br><strong>应用说明</strong>：工程全局路由、竞赛多源最短路。</p><h2 id="7-常见优化与工程建议"><a href="#7-常见优化与工程建议" class="headerlink" title="7. 常见优化与工程建议"></a>7. 常见优化与工程建议</h2><ul><li>Dijkstra堆优化，稀疏图用邻接表。</li><li>Bellman-Ford适合负权边，SPFA判负环。</li><li>工程优先用STL vector&#x2F;priority_queue。</li><li>路径还原常用pre数组。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>最短路</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MysqlConnectionPool —— C++高并发数据库连接池项目</title>
    <link href="/2025/06/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/MysqlConnectionPool/"/>
    <url>/2025/06/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/MysqlConnectionPool/</url>
    
    <content type="html"><![CDATA[<h1 id="MysqlConnectionPool-——-C-高并发数据库连接池项目"><a href="#MysqlConnectionPool-——-C-高并发数据库连接池项目" class="headerlink" title="MysqlConnectionPool —— C++高并发数据库连接池项目"></a>MysqlConnectionPool —— C++高并发数据库连接池项目</h1><p><a href="https://github.com/hwl111/MysqlConnectionPool">项目GitHub地址</a></p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>MysqlConnectionPool 是一个用 C++ 实现的高效 MySQL 数据库连接池，适用于高并发场景下的数据库访问优化。项目支持线程安全的连接管理、最大连接数限制、空闲连接复用、自动初始化与资源释放等特性。</p><h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ul><li><strong>自定义连接池实现</strong>：支持最大连接数、空闲连接重用、自动初始化与资源释放</li><li><strong>线程安全</strong>：多线程环境下安全复用数据库连接，提升并发性能</li><li><strong>空闲连接维护机制</strong>：定期清理长期未使用的连接，提升资源利用率</li><li><strong>配置文件驱动</strong>：通过 <code>mysql.ini</code> 灵活配置数据库参数和连接池规模</li><li><strong>高可拓展性</strong>：结构清晰，便于扩展异步连接、超时重试等高级功能</li></ul><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">MysqlConnectionPool/<br>├── Connection.cpp / <span class="hljs-string">.h</span>           <span class="hljs-comment"># 封装 MySQL 连接的类</span><br>├── MysqlConnectionPool.cpp / <span class="hljs-string">.h</span> <span class="hljs-comment"># 连接池的核心实现</span><br>├── main.cpp                      <span class="hljs-comment"># 测试或演示程序入口</span><br>├── mysql.ini                     <span class="hljs-comment"># 数据库配置文件</span><br>├── libmysql.dll                  <span class="hljs-comment"># MySQL 客户端动态链接库（Windows）</span><br>├── public.h                      <span class="hljs-comment"># 公共头文件</span><br>└── *<span class="hljs-string">.vcxproj</span> / <span class="hljs-string">.sln</span>              <span class="hljs-comment"># Visual Studio 工程文件</span><br></code></pre></td></tr></table></figure><h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><p><code>mysql.ini</code> 示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">host</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">port</span> = <span class="hljs-number">3306</span><br><span class="hljs-attr">user</span> = root<br><span class="hljs-attr">password</span> = yourpassword<br><span class="hljs-attr">database</span> = testdb<br><span class="hljs-attr">max_connections</span> = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>请根据实际环境修改数据库配置。</p><h2 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h2><ol><li>使用 Visual Studio 2019 或更高版本打开 <code>MysqlConnectionPool.sln</code></li><li>编译 Release 或 Debug 版本</li><li>将 <code>mysql.ini</code> 放在可执行文件同目录</li><li>运行程序，体验高并发下的数据库连接池性能</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>高并发 Web 服务后台</li><li>多线程数据采集&#x2F;分析系统</li><li>需要频繁访问数据库的 C++ 应用</li><li>任何对数据库连接性能有较高要求的场景</li></ul><h2 id="性能亮点"><a href="#性能亮点" class="headerlink" title="性能亮点"></a>性能亮点</h2><ul><li>连接池显著降低数据库访问延迟，提升多线程环境下的吞吐量</li><li>线程安全机制保证高并发下的稳定性</li></ul><hr><p>如需源码与详细说明，请访问 <a href="https://github.com/hwl111/MysqlConnectionPool">项目GitHub主页</a> </p>]]></content>
    
    
    <categories>
      
      <category>个人项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据库</tag>
      
      <tag>线程池</tag>
      
      <tag>连接池</tag>
      
      <tag>项目实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11/14/17/20新特性详解</title>
    <link href="/2025/06/%E7%AC%94%E8%AE%B0/C++11-14-17-20%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/06/%E7%AC%94%E8%AE%B0/C++11-14-17-20%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="C-11-14-17-20新特性详解"><a href="#C-11-14-17-20新特性详解" class="headerlink" title="C++11&#x2F;14&#x2F;17&#x2F;20新特性详解"></a>C++11&#x2F;14&#x2F;17&#x2F;20新特性详解</h1><p>本文系统梳理C++11&#x2F;14&#x2F;17&#x2F;20的主要新特性，涵盖【概念】、【使用场景】、代码示例、语法增强、标准库扩展和实际应用建议。</p><h2 id="1-C-11-主要新特性"><a href="#1-C-11-主要新特性" class="headerlink" title="1. C++11 主要新特性"></a>1. C++11 主要新特性</h2><h3 id="auto-类型推断"><a href="#auto-类型推断" class="headerlink" title="auto 类型推断"></a>auto 类型推断</h3><p><strong>【概念】</strong><br>自动根据初始化表达式推断变量类型。<br><strong>【使用场景】</strong><br>简化泛型代码、减少冗余类型声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br></code></pre></td></tr></table></figure><h3 id="range-based-for-循环"><a href="#range-based-for-循环" class="headerlink" title="range-based for 循环"></a>range-based for 循环</h3><p><strong>【概念】</strong><br>基于范围的for循环，简化容器遍历。<br><strong>【使用场景】</strong><br>遍历STL容器、数组等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : v) cout &lt;&lt; x &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><p><strong>【概念】</strong><br>匿名函数对象，支持捕获外部变量。<br><strong>【使用场景】</strong><br>回调、算法、并发任务、事件处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * x; &#125;;<br>cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="智能指针（unique-ptr-shared-ptr-weak-ptr）"><a href="#智能指针（unique-ptr-shared-ptr-weak-ptr）" class="headerlink" title="智能指针（unique_ptr, shared_ptr, weak_ptr）"></a>智能指针（unique_ptr, shared_ptr, weak_ptr）</h3><p><strong>【概念】</strong><br>自动管理动态内存，防止内存泄漏。<br><strong>【使用场景】</strong><br>资源管理、对象生命周期控制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">auto</span> p1 = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">auto</span> p2 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h3 id="右值引用与移动语义"><a href="#右值引用与移动语义" class="headerlink" title="右值引用与移动语义"></a>右值引用与移动语义</h3><p><strong>【概念】</strong><br>支持资源的高效转移，避免不必要的拷贝。<br><strong>【使用场景】</strong><br>容器扩容、临时对象优化、大对象传递。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// 移动语义</span><br>string s = <span class="hljs-string">&quot;world&quot;</span>;<br>v.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(s));<br></code></pre></td></tr></table></figure><h3 id="nullptr、enum-class、static-assert"><a href="#nullptr、enum-class、static-assert" class="headerlink" title="nullptr、enum class、static_assert"></a>nullptr、enum class、static_assert</h3><p><strong>【概念】</strong><br>nullptr：类型安全的空指针；enum class：强类型枚举；static_assert：编译期断言。<br><strong>【使用场景】</strong><br>类型安全、编译期检查、枚举类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123; Red, Green, Blue &#125;;<br><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) == <span class="hljs-number">4</span>, <span class="hljs-string">&quot;int必须4字节&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="constexpr、委托构造函数、继承构造函数"><a href="#constexpr、委托构造函数、继承构造函数" class="headerlink" title="constexpr、委托构造函数、继承构造函数"></a>constexpr、委托构造函数、继承构造函数</h3><p><strong>【概念】</strong><br>constexpr：编译期常量；委托&#x2F;继承构造函数：简化构造逻辑。<br><strong>【使用场景】</strong><br>常量表达式、构造函数重用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">sq</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) &#123;&#125;<br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">A</span>(<span class="hljs-number">0</span>) &#123;&#125; <span class="hljs-comment">// 委托构造</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="std-thread、std-mutex-等并发库"><a href="#std-thread、std-mutex-等并发库" class="headerlink" title="std::thread、std::mutex 等并发库"></a>std::thread、std::mutex 等并发库</h3><p><strong>【概念】</strong><br>标准库原生支持多线程与同步。<br><strong>【使用场景】</strong><br>并发编程、异步任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/*...*/</span> &#125;<br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(func)</span></span>;<br>t.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><h3 id="初始化列表（initializer-list）"><a href="#初始化列表（initializer-list）" class="headerlink" title="初始化列表（initializer_list）"></a>初始化列表（initializer_list）</h3><p><strong>【概念】</strong><br>统一的初始化语法。<br><strong>【使用场景】</strong><br>容器初始化、构造函数参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; l) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="2-C-14-主要新特性"><a href="#2-C-14-主要新特性" class="headerlink" title="2. C++14 主要新特性"></a>2. C++14 主要新特性</h2><h3 id="泛型lambda（auto参数）"><a href="#泛型lambda（auto参数）" class="headerlink" title="泛型lambda（auto参数）"></a>泛型lambda（auto参数）</h3><p><strong>【概念】</strong><br>lambda参数可用auto声明，支持任意类型。<br><strong>【使用场景】</strong><br>泛型算法、回调。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> add = [](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="return-type-deduction（函数返回类型自动推断）"><a href="#return-type-deduction（函数返回类型自动推断）" class="headerlink" title="return type deduction（函数返回类型自动推断）"></a>return type deduction（函数返回类型自动推断）</h3><p><strong>【概念】</strong><br>函数返回类型可省略，由编译器推断。<br><strong>【使用场景】</strong><br>简化模板和泛型代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="make-unique"><a href="#make-unique" class="headerlink" title="make_unique"></a>make_unique</h3><p><strong>【概念】</strong><br>安全创建unique_ptr的辅助函数。<br><strong>【使用场景】</strong><br>资源管理、避免裸new。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><h3 id="二进制字面量（0b1010）"><a href="#二进制字面量（0b1010）" class="headerlink" title="二进制字面量（0b1010）"></a>二进制字面量（0b1010）</h3><p><strong>【概念】</strong><br>支持二进制常量。<br><strong>【使用场景】</strong><br>位运算、底层开发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0b1010</span>;<br></code></pre></td></tr></table></figure><h3 id="std-shared-timed-mutex"><a href="#std-shared-timed-mutex" class="headerlink" title="std::shared_timed_mutex"></a>std::shared_timed_mutex</h3><p><strong>【概念】</strong><br>支持读写锁和定时锁。<br><strong>【使用场景】</strong><br>高并发读多写少场景。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br>std::shared_timed_mutex mtx;<br></code></pre></td></tr></table></figure><hr><h2 id="3-C-17-主要新特性"><a href="#3-C-17-主要新特性" class="headerlink" title="3. C++17 主要新特性"></a>3. C++17 主要新特性</h2><h3 id="结构化绑定（structured-bindings）"><a href="#结构化绑定（structured-bindings）" class="headerlink" title="结构化绑定（structured bindings）"></a>结构化绑定（structured bindings）</h3><p><strong>【概念】</strong><br>可将结构&#x2F;元组解包为多个变量。<br><strong>【使用场景】</strong><br>遍历map、解构pair&#x2F;tuple。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> [a, b] = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>map&lt;string, <span class="hljs-type">int</span>&gt; m = &#123;&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>&#125;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [k, v] : m) cout &lt;&lt; k &lt;&lt; v;<br></code></pre></td></tr></table></figure><h3 id="if-constexpr"><a href="#if-constexpr" class="headerlink" title="if constexpr"></a>if constexpr</h3><p><strong>【概念】</strong><br>编译期条件分支。<br><strong>【使用场景】</strong><br>模板元编程、类型特化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_integral&lt;T&gt;::value)</span></span><br><span class="hljs-function">        cout &lt;&lt; &quot;<span class="hljs-type">int</span>: <span class="hljs-string">&quot; &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="hljs-string"><span class="hljs-function">    else</span></span><br><span class="hljs-string"><span class="hljs-function">        cout &lt;&lt; &quot;</span>other: <span class="hljs-string">&quot; &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="hljs-string"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><h3 id="内联变量（inline-variable）"><a href="#内联变量（inline-variable）" class="headerlink" title="内联变量（inline variable）"></a>内联变量（inline variable）</h3><p><strong>【概念】</strong><br>支持头文件中定义全局变量。<br><strong>【使用场景】</strong><br>常量、单例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="std-optional-std-variant-std-any"><a href="#std-optional-std-variant-std-any" class="headerlink" title="std::optional, std::variant, std::any"></a>std::optional, std::variant, std::any</h3><p><strong>【概念】</strong><br>可选值、类型安全的联合体、任意类型容器。<br><strong>【使用场景】</strong><br>函数返回值、配置、类型擦除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br>optional&lt;<span class="hljs-type">int</span>&gt; o = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (o) cout &lt;&lt; *o;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><br>variant&lt;<span class="hljs-type">int</span>, string&gt; v = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;any&gt;</span></span><br>any a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h3><p><strong>【概念】</strong><br>轻量级字符串视图，避免拷贝。<br><strong>【使用场景】</strong><br>高性能字符串处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><br>string_view sv = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="并行STL算法（std-for-each-par-…-）"><a href="#并行STL算法（std-for-each-par-…-）" class="headerlink" title="并行STL算法（std::for_each(par, … )）"></a>并行STL算法（std::for_each(par, … )）</h3><p><strong>【概念】</strong><br>STL算法支持并行执行。<br><strong>【使用场景】</strong><br>大数据量并行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>std::for_each(std::execution::par, v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span>&amp; x)&#123; x *= <span class="hljs-number">2</span>; &#125;);<br></code></pre></td></tr></table></figure><h3 id="文件系统库（）"><a href="#文件系统库（）" class="headerlink" title="文件系统库（）"></a>文件系统库（<filesystem>）</h3><p><strong>【概念】</strong><br>标准化文件和路径操作。<br><strong>【使用场景】</strong><br>跨平台文件管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><br>std::filesystem::path p = <span class="hljs-string">&quot;/tmp/test.txt&quot;</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="4-C-20-主要新特性"><a href="#4-C-20-主要新特性" class="headerlink" title="4. C++20 主要新特性"></a>4. C++20 主要新特性</h2><h3 id="协程（coroutine）"><a href="#协程（coroutine）" class="headerlink" title="协程（coroutine）"></a>协程（coroutine）</h3><p><strong>【概念】</strong><br>支持函数挂起与恢复，简化异步编程。<br><strong>【使用场景】</strong><br>异步IO、生成器、状态机。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需编译器支持</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-comment">// 示例略</span><br></code></pre></td></tr></table></figure><h3 id="概念（concepts）与约束（requires）"><a href="#概念（concepts）与约束（requires）" class="headerlink" title="概念（concepts）与约束（requires）"></a>概念（concepts）与约束（requires）</h3><p><strong>【概念】</strong><br>模板参数约束，提升泛型安全性。<br><strong>【使用场景】</strong><br>泛型库、模板接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">concept</span> Addable = <span class="hljs-built_in">requires</span>(T a, T b) &#123; a + b; &#125;;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Addable T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br></code></pre></td></tr></table></figure><h3 id="范围for增强（ranges）"><a href="#范围for增强（ranges）" class="headerlink" title="范围for增强（ranges）"></a>范围for增强（ranges）</h3><p><strong>【概念】</strong><br>基于范围的算法和管道操作。<br><strong>【使用场景】</strong><br>链式数据处理、过滤、变换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : v | std::views::<span class="hljs-built_in">filter</span>([](<span class="hljs-type">int</span> x)&#123;<span class="hljs-keyword">return</span> x%<span class="hljs-number">2</span>;&#125;)) cout &lt;&lt; x;<br></code></pre></td></tr></table></figure><h3 id="三路比较（，spaceship-operator）"><a href="#三路比较（，spaceship-operator）" class="headerlink" title="三路比较（&lt;&#x3D;&gt;，spaceship operator）"></a>三路比较（&lt;&#x3D;&gt;，spaceship operator）</h3><p><strong>【概念】</strong><br>自动生成全序比较操作符。<br><strong>【使用场景】</strong><br>排序、查找、容器比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;compare&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-type">int</span> x, y;<br>  <span class="hljs-keyword">auto</span> <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Point&amp;) <span class="hljs-type">const</span> = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="模块化（modules）"><a href="#模块化（modules）" class="headerlink" title="模块化（modules）"></a>模块化（modules）</h3><p><strong>【概念】</strong><br>替代头文件的模块系统，提升编译速度。<br><strong>【使用场景】</strong><br>大型项目、库开发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需编译器支持</span><br><span class="hljs-comment">// module; import; export 语法</span><br></code></pre></td></tr></table></figure><h3 id="consteval-constinit"><a href="#consteval-constinit" class="headerlink" title="consteval&#x2F;constinit"></a>consteval&#x2F;constinit</h3><p><strong>【概念】</strong><br>consteval：强制编译期求值；constinit：防止静态初始化顺序问题。<br><strong>【使用场景】</strong><br>编译期常量、全局变量初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">sq</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;<br><span class="hljs-keyword">constinit</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="calendar-timezone库"><a href="#calendar-timezone库" class="headerlink" title="calendar&#x2F;timezone库"></a>calendar&#x2F;timezone库</h3><p><strong>【概念】</strong><br>标准化日期和时区处理。<br><strong>【使用场景】</strong><br>跨时区应用、日志。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;<br><span class="hljs-keyword">auto</span> now = system_clock::<span class="hljs-built_in">now</span>();<br></code></pre></td></tr></table></figure><hr><p>现代C++新特性极大提升了代码表达力与性能，建议结合实际项目逐步迁移和应用。 </p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>新特性</tag>
      
      <tag>现代C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++并发与多线程编程</title>
    <link href="/2025/06/%E7%AC%94%E8%AE%B0/C++%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2025/06/%E7%AC%94%E8%AE%B0/C++%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="C-并发与多线程编程"><a href="#C-并发与多线程编程" class="headerlink" title="C++并发与多线程编程"></a>C++并发与多线程编程</h1><p>C++11起标准库原生支持多线程与并发。本文系统梳理C++并发编程核心知识，配合【概念】、【使用场景】、常用工具和实战技巧。</p><h2 id="1-线程的创建与管理"><a href="#1-线程的创建与管理" class="headerlink" title="1. 线程的创建与管理"></a>1. 线程的创建与管理</h2><p><strong>【概念】</strong><br>线程是操作系统调度的最小单位，C++11通过std::thread支持多线程编程。</p><p><strong>【使用场景】</strong><br>CPU密集型&#x2F;IO密集型任务并行、后台任务、网络服务、异步处理等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; ... &#125;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func, <span class="hljs-number">10</span>)</span></span>;<br>t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br><br><span class="hljs-comment">// lambda线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([]&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span>; &#125;)</span></span>;<br>t<span class="hljs-number">2.</span><span class="hljs-built_in">detach</span>();<br></code></pre></td></tr></table></figure><h2 id="2-互斥锁与锁管理"><a href="#2-互斥锁与锁管理" class="headerlink" title="2. 互斥锁与锁管理"></a>2. 互斥锁与锁管理</h2><p><strong>【概念】</strong><br>互斥锁（mutex）用于保护临界区，防止多线程同时访问共享资源导致数据竞争。</p><p><strong>【使用场景】</strong><br>多线程写共享数据、日志、计数器、缓存等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br>std::mutex mtx;<br>mtx.<span class="hljs-built_in">lock</span>();<br><span class="hljs-comment">// 临界区</span><br>mtx.<span class="hljs-built_in">unlock</span>();<br><br><span class="hljs-comment">// 推荐用lock_guard自动管理</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3. 条件变量"></a>3. 条件变量</h2><p><strong>【概念】</strong><br>条件变量（condition_variable）用于线程间同步，等待某个条件成立时唤醒线程。</p><p><strong>【使用场景】</strong><br>生产者-消费者、任务队列、线程间事件通知等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br>std::condition_variable cv;<br>std::mutex mtx;<br><span class="hljs-type">bool</span> ready = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 等待线程</span><br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx)</span></span>;<br>cv.<span class="hljs-built_in">wait</span>(lk, []&#123;<span class="hljs-keyword">return</span> ready;&#125;);<br><br><span class="hljs-comment">// 通知线程</span><br>ready = <span class="hljs-literal">true</span>;<br>cv.<span class="hljs-built_in">notify_one</span>();<br></code></pre></td></tr></table></figure><h2 id="4-原子操作与内存模型"><a href="#4-原子操作与内存模型" class="headerlink" title="4. 原子操作与内存模型"></a>4. 原子操作与内存模型</h2><p><strong>【概念】</strong><br>原子操作（atomic）保证操作不可中断，避免加锁带来的性能损耗。</p><p><strong>【使用场景】</strong><br>计数器、自增ID、无锁队列、并发标志位等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cnt.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="5-线程池与并发容器"><a href="#5-线程池与并发容器" class="headerlink" title="5. 线程池与并发容器"></a>5. 线程池与并发容器</h2><p><strong>【概念】</strong><br>线程池通过复用线程资源批量处理任务，提高并发效率。并发容器支持多线程安全操作。</p><p><strong>【使用场景】</strong><br>高并发服务器、任务调度、批量数据处理、异步任务。</p><ul><li>标准库暂未内置线程池，可用第三方如 ThreadPool、boost::asio。</li><li>并发容器：C++17起有 std::shared_mutex，C++20有并发数据结构支持。</li></ul><h2 id="6-常见并发问题"><a href="#6-常见并发问题" class="headerlink" title="6. 常见并发问题"></a>6. 常见并发问题</h2><p><strong>【概念】</strong><br>并发编程常见问题包括死锁、竞态条件、活锁、ABA问题等。</p><p><strong>【使用场景】</strong><br>多线程共享资源、复杂同步场景、并发数据结构设计等。</p><ul><li>死锁、竞态条件、活锁、ABA问题</li><li>线程安全与无锁编程</li></ul><h2 id="7-最佳实践"><a href="#7-最佳实践" class="headerlink" title="7. 最佳实践"></a>7. 最佳实践</h2><ul><li>尽量用RAII管理锁</li><li>避免数据竞争，优先用原子类型</li><li>合理拆分任务，避免线程过多</li><li>用future&#x2F;promise进行线程间通信</li></ul><p><strong>示例：future&#x2F;promise</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br>std::promise&lt;<span class="hljs-type">int</span>&gt; p;<br>std::future&lt;<span class="hljs-type">int</span>&gt; f = p.<span class="hljs-built_in">get_future</span>();<br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;p]&#123; p.set_value(<span class="hljs-number">42</span>); &#125;)</span></span>;<br><span class="hljs-type">int</span> result = f.<span class="hljs-built_in">get</span>();<br>t.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><hr><p>并发编程需谨慎，建议多用标准库工具，避免手动管理低层细节。 </p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>并发</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用设计模式精讲</title>
    <link href="/2025/06/%E7%AC%94%E8%AE%B0/C++%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%AE%B2/"/>
    <url>/2025/06/%E7%AC%94%E8%AE%B0/C++%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="C-常用设计模式精讲"><a href="#C-常用设计模式精讲" class="headerlink" title="C++常用设计模式精讲"></a>C++常用设计模式精讲</h1><p>设计模式是高质量软件开发的核心。本文精选C++常用设计模式，配合【概念】、【使用场景】、代码示例和实际应用建议。</p><h2 id="1-单例模式（Singleton-Pattern）"><a href="#1-单例模式（Singleton-Pattern）" class="headerlink" title="1. 单例模式（Singleton Pattern）"></a>1. 单例模式（Singleton Pattern）</h2><p><strong>【概念】</strong><br>保证一个类只有一个实例，并提供全局访问点。</p><p><strong>【使用场景】</strong><br>配置管理器、日志系统、线程池、数据库连接池等全局唯一对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-工厂模式（Factory-Pattern）"><a href="#2-工厂模式（Factory-Pattern）" class="headerlink" title="2. 工厂模式（Factory Pattern）"></a>2. 工厂模式（Factory Pattern）</h2><p><strong>【概念】</strong><br>定义一个用于创建对象的接口，让子类决定实例化哪一个类。</p><p><strong>【使用场景】</strong><br>框架&#x2F;库需要对外屏蔽具体实现细节，常用于日志库、数据库驱动、UI组件等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct</span> : <span class="hljs-keyword">public</span> Product &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; ... &#125; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Product* <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProduct</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-观察者模式（Observer-Pattern）"><a href="#3-观察者模式（Observer-Pattern）" class="headerlink" title="3. 观察者模式（Observer Pattern）"></a>3. 观察者模式（Observer Pattern）</h2><p><strong>【概念】</strong><br>定义对象间一对多依赖关系，当一个对象状态变化时，所有依赖者都会收到通知。</p><p><strong>【使用场景】</strong><br>事件系统、GUI事件、订阅-发布、MVC架构中的视图更新等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    vector&lt;Observer*&gt; obs;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Observer* o)</span> </span>&#123; obs.<span class="hljs-built_in">push_back</span>(o); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> o : obs) o-&gt;<span class="hljs-built_in">update</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-策略模式（Strategy-Pattern）"><a href="#4-策略模式（Strategy-Pattern）" class="headerlink" title="4. 策略模式（Strategy Pattern）"></a>4. 策略模式（Strategy Pattern）</h2><p><strong>【概念】</strong><br>定义一系列算法，将每个算法封装起来，使它们可以互换。</p><p><strong>【使用场景】</strong><br>算法族切换（如排序、压缩）、行为可配置的业务逻辑、AI决策等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteA</span> : <span class="hljs-keyword">public</span> Strategy &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; ... &#125; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    Strategy* s;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Strategy* s_)</span> </span>&#123; s = s_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; s-&gt;<span class="hljs-built_in">execute</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-装饰器模式（Decorator-Pattern）"><a href="#5-装饰器模式（Decorator-Pattern）" class="headerlink" title="5. 装饰器模式（Decorator Pattern）"></a>5. 装饰器模式（Decorator Pattern）</h2><p><strong>【概念】</strong><br>动态地给对象添加额外功能，且不影响其他对象。</p><p><strong>【使用场景】</strong><br>IO流处理、日志增强、权限校验、功能扩展等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> : <span class="hljs-keyword">public</span> Component &#123;<br>    Component* comp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Decorator</span>(Component* c) : <span class="hljs-built_in">comp</span>(c) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; comp-&gt;<span class="hljs-built_in">op</span>(); <span class="hljs-comment">/*扩展*/</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="6-适配器模式（Adapter-Pattern）"><a href="#6-适配器模式（Adapter-Pattern）" class="headerlink" title="6. 适配器模式（Adapter Pattern）"></a>6. 适配器模式（Adapter Pattern）</h2><p><strong>【概念】</strong><br>将一个类的接口转换成客户端期望的另一个接口，实现类之间的兼容。</p><p><strong>【使用场景】</strong><br>旧系统兼容新接口、第三方库集成、不同协议&#x2F;格式转换等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">specificRequest</span><span class="hljs-params">()</span> </span>&#123; ... &#125; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> : <span class="hljs-keyword">public</span> Target &#123;<br>    Adaptee* adaptee;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Adapter</span>(Adaptee* a) : <span class="hljs-built_in">adaptee</span>(a) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; adaptee-&gt;<span class="hljs-built_in">specificRequest</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="7-模板方法模式（Template-Method-Pattern）"><a href="#7-模板方法模式（Template-Method-Pattern）" class="headerlink" title="7. 模板方法模式（Template Method Pattern）"></a>7. 模板方法模式（Template Method Pattern）</h2><p><strong>【概念】</strong><br>定义算法骨架，将部分步骤延迟到子类实现。</p><p><strong>【使用场景】</strong><br>框架扩展、流程控制、通用算法模板（如排序、数据处理等）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">step1</span>(); <span class="hljs-built_in">step2</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="8-代理模式（Proxy-Pattern）"><a href="#8-代理模式（Proxy-Pattern）" class="headerlink" title="8. 代理模式（Proxy Pattern）"></a>8. 代理模式（Proxy Pattern）</h2><p><strong>【概念】</strong><br>为其他对象提供一种代理以控制对其的访问。</p><p><strong>【使用场景】</strong><br>远程代理、虚拟代理、安全代理、缓存代理、智能指针等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> : <span class="hljs-keyword">public</span> Subject &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; ... &#125; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> : <span class="hljs-keyword">public</span> Subject &#123;<br>    RealSubject* real;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Proxy</span>(RealSubject* r) : <span class="hljs-built_in">real</span>(r) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/*权限/缓存等*/</span> real-&gt;<span class="hljs-built_in">op</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><p>设计模式提升代码复用性、可维护性和扩展性，建议结合实际项目灵活应用。 </p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>设计模式</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++模板元编程基础与进阶</title>
    <link href="/2025/06/%E7%AC%94%E8%AE%B0/C++%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
    <url>/2025/06/%E7%AC%94%E8%AE%B0/C++%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="C-模板元编程基础与进阶"><a href="#C-模板元编程基础与进阶" class="headerlink" title="C++模板元编程基础与进阶"></a>C++模板元编程基础与进阶</h1><p>模板元编程（Template Metaprogramming）是C++强大泛型能力的体现。本文系统梳理模板基础、递归、SFINAE、type traits、constexpr、变参模板等核心内容，配合【概念】、【使用场景】说明。</p><h2 id="1-模板基础"><a href="#1-模板基础" class="headerlink" title="1. 模板基础"></a>1. 模板基础</h2><p><strong>【概念】</strong><br>模板是C++泛型编程的基础，支持类型参数化，实现代码复用。</p><p><strong>【使用场景】</strong><br>容器库（如STL）、算法泛型化、类型无关的工具类和函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-comment">// 类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123; T value; &#125;;<br></code></pre></td></tr></table></figure><h2 id="2-递归模板与编译期计算"><a href="#2-递归模板与编译期计算" class="headerlink" title="2. 递归模板与编译期计算"></a>2. 递归模板与编译期计算</h2><p><strong>【概念】</strong><br>递归模板通过模板实例化实现编译期递归计算。</p><p><strong>【使用场景】</strong><br>编译期常量计算、类型列表处理、静态断言等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = N * Factorial&lt;N<span class="hljs-number">-1</span>&gt;::value;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-comment">// Factorial&lt;5&gt;::value == 120</span><br></code></pre></td></tr></table></figure><h2 id="3-SFINAE与enable-if"><a href="#3-SFINAE与enable-if" class="headerlink" title="3. SFINAE与enable_if"></a>3. SFINAE与enable_if</h2><p><strong>【概念】</strong><br>SFINAE（Substitution Failure Is Not An Error）是一种模板特化机制，enable_if用于条件编译和类型选择。</p><p><strong>【使用场景】</strong><br>类型萃取、函数重载选择、泛型约束、静态断言。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::<span class="hljs-function">type</span><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">(T t)</span> </span>&#123; <span class="hljs-keyword">return</span> t + <span class="hljs-number">1</span>; &#125;<br></code></pre></td></tr></table></figure><h2 id="4-type-traits与类型萃取"><a href="#4-type-traits与类型萃取" class="headerlink" title="4. type traits与类型萃取"></a>4. type traits与类型萃取</h2><p><strong>【概念】</strong><br>type traits是标准库提供的类型特性萃取工具。</p><p><strong>【使用场景】</strong><br>类型判断、模板特化、泛型算法优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br>std::is_same&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::value <span class="hljs-comment">// true</span><br>std::is_pointer&lt;<span class="hljs-type">int</span>*&gt;::value <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="5-constexpr与编译期函数"><a href="#5-constexpr与编译期函数" class="headerlink" title="5. constexpr与编译期函数"></a>5. constexpr与编译期函数</h2><p><strong>【概念】</strong><br>constexpr函数在编译期求值，提升性能和类型安全。</p><p><strong>【使用场景】</strong><br>编译期常量、静态断言、元编程优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">1</span> ? n : <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>);<br>&#125;<br><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">fib</span>(<span class="hljs-number">10</span>) == <span class="hljs-number">55</span>, <span class="hljs-string">&quot;error&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="6-变参模板与折叠表达式（C-11-17）"><a href="#6-变参模板与折叠表达式（C-11-17）" class="headerlink" title="6. 变参模板与折叠表达式（C++11&#x2F;17）"></a>6. 变参模板与折叠表达式（C++11&#x2F;17）</h2><p><strong>【概念】</strong><br>变参模板支持任意数量参数，折叠表达式简化参数包操作。</p><p><strong>【使用场景】</strong><br>通用打印、日志、元组处理、泛型容器等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; <span class="hljs-comment">// C++17折叠表达式</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-常见元编程技巧与应用"><a href="#7-常见元编程技巧与应用" class="headerlink" title="7. 常见元编程技巧与应用"></a>7. 常见元编程技巧与应用</h2><ul><li>条件编译：<code>std::conditional</code></li><li>类型选择：<code>std::enable_if</code>、<code>std::is_same</code></li><li>静态断言：<code>static_assert</code></li><li>编译期常量：<code>integral_constant</code></li></ul><h2 id="8-应用案例：类型安全的最小值函数"><a href="#8-应用案例：类型安全的最小值函数" class="headerlink" title="8. 应用案例：类型安全的最小值函数"></a>8. 应用案例：类型安全的最小值函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">mymin</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &lt; b ? a : b; &#125;<br></code></pre></td></tr></table></figure><hr><p>模板元编程可提升代码泛化与性能，但需注意可读性和编译时间。 </p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>模板元编程</tag>
      
      <tag>进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2025/03/%E7%AC%94%E8%AE%B0/Git/"/>
    <url>/2025/03/%E7%AC%94%E8%AE%B0/Git/</url>
    
    <content type="html"><![CDATA[<h3 id="git快速入门"><a href="#git快速入门" class="headerlink" title="git快速入门"></a>git快速入门</h3><p>Git 完整命令手册地址：<a href="http://git-scm.com/docs">Git 官方文档</a></p><p>PDF 版命令手册：<a href="https://www.runoob.com/manual/github-git-cheat-sheet.pdf">github-git-cheat-sheet.pdf</a></p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a><strong>基础操作</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化新仓库</td></tr><tr><td align="left"><code>git clone &lt;url&gt;</code></td><td align="left">克隆远程仓库</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看工作区状态</td></tr><tr><td align="left"><code>git add &lt;file&gt; </code></td><td align="left">添加文件到暂存区</td></tr><tr><td align="left"><code>git add .</code></td><td align="left">添加所有修改到暂存区</td></tr><tr><td align="left"><code>git commit -m &quot;message&quot;</code></td><td align="left">提交更改到本地仓库</td></tr><tr><td align="left"><code>git commit --amend</code></td><td align="left">修改最后一次提交</td></tr></tbody></table><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a><strong>分支管理</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git branch</code></td><td align="left">查看本地分支</td></tr><tr><td align="left"><code>git branch </code></td><td align="left">创建新分支</td></tr><tr><td align="left"><code>git checkout </code></td><td align="left">切换分支</td></tr><tr><td align="left"><code>git checkout -b </code></td><td align="left">创建并切换分支</td></tr><tr><td align="left"><code>git merge &lt;branch&gt; </code></td><td align="left">合并分支到当前分支</td></tr><tr><td align="left"><code>git branch -d </code></td><td align="left">删除本地分支</td></tr><tr><td align="left"><code>git push origin --delete &lt;branch&gt; </code></td><td align="left">删除远程分支</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a><strong>远程操作</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote -v</code></td><td align="left">查看远程仓库地址</td></tr><tr><td align="left"><code>git pull origin &lt;branch&gt; </code></td><td align="left">拉取远程分支并合并</td></tr><tr><td align="left"><code>git push origin &lt;branch&gt;</code></td><td align="left">推送本地分支到远程</td></tr><tr><td align="left"><code>git fetch --all</code></td><td align="left">获取所有远程更新（不自动合并）</td></tr></tbody></table><h3 id="撤销与回退"><a href="#撤销与回退" class="headerlink" title="撤销与回退"></a><strong>撤销与回退</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git restore &lt;file&gt;</code></td><td align="left">撤销工作区修改</td></tr><tr><td align="left"><code>git restore --staged &lt;file&gt; </code></td><td align="left">撤销暂存区修改</td></tr><tr><td align="left"><code>git reset --hard HEAD^</code></td><td align="left">回退到上一个提交（彻底删除更改）</td></tr><tr><td align="left"><code>git reset --soft HEAD^</code></td><td align="left">回退提交但保留更改到暂存区</td></tr><tr><td align="left"><code>git revert &lt;commit-id&gt; </code></td><td align="left">撤销指定提交（生成新提交）</td></tr></tbody></table><h3 id="日志与对比"><a href="#日志与对比" class="headerlink" title="日志与对比"></a><strong>日志与对比</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看提交历史</td></tr><tr><td align="left"><code>git log --oneline --graph</code></td><td align="left">简洁版提交历史（带分支图）</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">查看工作区与暂存区的差异</td></tr><tr><td align="left"><code>git diff --cached</code></td><td align="left">查看暂存区与仓库的差异</td></tr></tbody></table><h3 id="临时修改用户名和邮箱"><a href="#临时修改用户名和邮箱" class="headerlink" title="临时修改用户名和邮箱"></a><strong>临时修改用户名和邮箱</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git config user.name &quot;新用户名&quot;</code></td><td align="left">修改用户名</td></tr><tr><td align="left"><code>git config user.email &quot;新邮箱地址&quot;</code></td><td align="left">修改邮箱</td></tr><tr><td align="left"><code>git config user.name</code></td><td align="left">查看用户名</td></tr><tr><td align="left"><code>git config user.email</code></td><td align="left">查看邮箱</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++内存池</title>
    <link href="/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%86%85%E5%AD%98%E6%B1%A0%E9%A1%B9%E7%9B%AE/"/>
    <url>/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%86%85%E5%AD%98%E6%B1%A0%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="内存池介绍"><a href="#内存池介绍" class="headerlink" title="内存池介绍"></a>内存池介绍</h3><h4 id="什么是内存池"><a href="#什么是内存池" class="headerlink" title="什么是内存池"></a>什么是内存池</h4><p><strong>内存池是一种预分配内存并且进行重复利用的技术</strong>，通过减少频繁的动态内存分配与释放操作，从而提高程序的运行效率。内存池通常预先分配一块大的区域，将其划分为多个小块，每次需要分配内存时直接从这块区域分配，而不是调用系统的动态分配函数（如new或者malloc）。简单来说就是申请一块较大的内存块（不够就继续申请），之后将这块内存的管理放在应用层执行，减少系统调用带来的开销。</p><h4 id="为什么要做内存池"><a href="#为什么要做内存池" class="headerlink" title="为什么要做内存池"></a>为什么要做内存池</h4><h5 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h5><ul><li><p><strong>减少动态内存分配的开销</strong>：系统调用malloc&#x2F;new和free&#x2F;delete涉及复杂的内存管理操作（如内存查找、碎片整理），导致性能较低，而内存池通过预分配和简单的管理逻辑显著提高了分配和释放的效率。</p></li><li><p><strong>避免内存碎片</strong>：动态分配内存会产生内存碎片，尤其在大量小对象频繁分配和释放的场景中，导致的后果就是：当程序长时间运行时，由于所申请的内存块的大小不定，频繁使用时会造成大量的内存碎片从而降低程序和操作系统的性能。内存池通过管理固定大小的内存块，可以有效避免碎片化。</p></li><li><p><strong>降低系统调用频率</strong>：系统级内存分配（如malloc）需要进入内核态，频繁调用会有较高的性能开销。内存池通过减少系统调用频率提高程序效率。</p></li></ul><h5 id="确定性（实时性）："><a href="#确定性（实时性）：" class="headerlink" title="确定性（实时性）："></a>确定性（实时性）：</h5><ul><li><strong>稳定的分配时间</strong>：使用内存池可以使分配和释放操作的耗时更加可控和稳定，适合实时性有严格要求的系统。</li></ul><h4 id="内存池的应用场景："><a href="#内存池的应用场景：" class="headerlink" title="内存池的应用场景："></a>内存池的应用场景：</h4><h5 id="高频小对象分配："><a href="#高频小对象分配：" class="headerlink" title="高频小对象分配："></a>高频小对象分配：</h5><ul><li><p><strong>游戏开发</strong>：游戏中大量小对象（如粒子、子弹、NPC）的动态分配和释放非常频繁，使用内存池可以显著优化性能。</p></li><li><p><strong>网络编程</strong>：网络编程中，大量请求和响应对象（如消息报文）和频繁创建和销毁非常适合使用内存池。</p></li><li><p><strong>内存管理库</strong>：一些容器或数据结构（如std::vector或std::deque）在内部可能使用内存池来优化分配性能。</p></li></ul><h5 id="实时系统："><a href="#实时系统：" class="headerlink" title="实时系统："></a>实时系统：</h5><ul><li>嵌入式设备或实时控制系统中，动态内存分配的延迟可能影响实时性，内存池提供确定性的分配性能。</li></ul><h5 id="高性能计算："><a href="#高性能计算：" class="headerlink" title="高性能计算："></a>高性能计算：</h5><ul><li>在高性能计算程序中，频繁地内存分配和释放会拖累整个程序的性能，内存池可以优化内存管理</li></ul><h5 id="服务器开发："><a href="#服务器开发：" class="headerlink" title="服务器开发："></a>服务器开发：</h5><ul><li>数据库服务器、web服务器等需要管理大量连接和请求，这些连接涉及大量内存分配，内存池能有效提升服务器性能。</li></ul><h4 id="内存池在代码中的应用"><a href="#内存池在代码中的应用" class="headerlink" title="内存池在代码中的应用"></a>内存池在代码中的应用</h4><ul><li><p>对new&#x2F;malloc&#x2F;delete&#x2F;free等动态开辟内存的系统调用进行替换</p></li><li><p>对STL众多容器中的空间配置器std::allocator进行替换</p></li></ul><h4 id="内存池的缺点"><a href="#内存池的缺点" class="headerlink" title="内存池的缺点"></a>内存池的缺点</h4><ul><li><p><strong>初始内存占用</strong>：内存池需要预先分配较大的内存区域，可能浪费一些内存。</p></li><li><p><strong>复杂性</strong>：实现和调试内存池代码比直接使用 malloc &#x2F; new 更复杂。</p></li><li><p><strong>不适合大型对象</strong>：对于大对象的分配可能并不划算。</p></li></ul><h3 id="项目框架"><a href="#项目框架" class="headerlink" title="项目框架"></a>项目框架</h3><p>内存池本质：预先向系统申请一大片内存，并交由应用层管理，在程序运行时，内存的分配和回收都由应用层的内存池处理，从而减少系统调用。</p><p>该项目实现的是基于<strong>哈希映射的多种定长内存分配器（内存池中的一种）</strong>：</p><img src="../img/1.jpg" alt="内存池示意图" style="width: 50%;"><p>主要框架如上图所示，主要是维护一个哈希桶 MemoryPools，里面每项对应一个内存池 MemoryPool，哈希桶中每个内存池的块大小 BlockSize 是相同的（4096字节，可以设置为不同），但是每个内存池里每个块分割的大小（槽大小）SlotSize是不同的，依次为8,16,32,…,512字节（<strong>需要的内存超过512字节就用new&#x2F;malloc</strong>），用户申请不同大小的内存就通过哈希桶的映射找到相应（槽大小）  SlotSize 的内存池向其申请，比如用户分别申请8字节和12字节的内存，则经过哈希函数的计算找到槽大小为8字节的内存池和槽大小为16字节（哈希函数向上取整，因为分配给用户的内存块只能大不能小）的内存池分别分配内存给用户，这样设置的好处是<strong>可以保证内存碎片在可控范围内</strong>。</p><p><strong>为什么用户申请超过512字节的内存就直接调用 new&#x2F;malloc 等系统调用？</strong></p><p><strong>因为内存池主要解决的是 小内存带来的内存碎片问题 和 小内存频繁申请释放带来的性能问题。</strong>（频繁申请小内存带来的问题可参考：<a href="https://blog.csdn.net/LF_2016/article/details/53511648">https://blog.csdn.net/LF_2016/article/details/53511648</a>）</p><p>每个内存池的内部结构图：</p><img src="../img/2.jpg" alt="内存池示意图" style="width: 50%;"><ul><li><strong>Slot currentBlock</strong>：内存池实际上是一个一个的 Block 以链表的形式连接起来，每一个 Block 是一块大的内存，当内存池的内存不足的时候，就会向操作系统申请新的 block 加入链表。</li><li><strong>Slot freeSlot</strong>：链表里面的每一项都是对象被释放后归还给内存池的空间，内存池刚创建时 freeSlot 是空的。用户创建对象，将对象释放时，把内存归还给内存池，此时内存池不会将内存归还给系统（delete&#x2F;free），而是把指向这个对象的内存的指针加到 freeSlot 链表的前面（前插），之后用户每次申请内存时，memoryPool就先在这个 freeSlot 链表里面找。</li><li><strong>Slot curretSlot</strong>：用户在创建对象的时候，先检查 freeSlot 是否为空，不为空的时候直接取出一项作为分配出的空间。否则就在当前 Block 将 currentSlot 所指的内存分配出去，如果 Block 里面的内存已经使用完，就向操作系统申请一个新的 Block。</li></ul><p><strong>整体流程图</strong></p><img src="../img/3.jpg" alt="内存池示意图" style="width: 50%;"><p>该项目对外提供了两个重要的接口newElement和deleteElement，分别是向内存池申请内存和将申请的内存进行回收操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">T* <span class="hljs-title">newElement</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p>用户在构造对象T的时候通过调用newElement<T>()方法申请内存，newElement<T>()方法计算出元素T的大小后传入哈希桶中，哈希桶中根据哈希映射选择相应槽大小的内存池去分配内存返回（分配内存时优先使用FreeList_里的空闲内存槽，其次再找curSlot_，如果curSlot_大于等于lastSot_，则重新申请一块内存块来分配内存槽），newElement函数获得内存之后，在该内存上构造对象T后将地址返回给用户。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteElement</span><span class="hljs-params">(T* p)</span></span>;<br></code></pre></td></tr></table></figure><p>当用户想要释放对象时可调用deleteElement函数，该方法首先调用对象T的析构函数，其次同样经过哈希映射找到相应的内存池去把内存槽加入到FreeList_中。</p>]]></content>
    
    
    <categories>
      
      <category>个人项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>内存池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用C++实现终端版俄罗斯方块：从零开始的游戏开发指南</title>
    <link href="/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/"/>
    <url>/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h3 id="用C-实现终端版俄罗斯方块：从零开始的游戏开发指南"><a href="#用C-实现终端版俄罗斯方块：从零开始的游戏开发指南" class="headerlink" title="用C++实现终端版俄罗斯方块：从零开始的游戏开发指南"></a>用C++实现终端版俄罗斯方块：从零开始的游戏开发指南</h3><h4 id="引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C-控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。"><a href="#引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C-控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。" class="headerlink" title="引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C++控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。"></a>引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C++控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。</h4><p>观看视频讲解：<a href="https://www.bilibili.com/video/BV1a94y1Y7Jw">C++俄罗斯方块实现教程</a></p><h4 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h4><h5 id="1-方块表示与旋转"><a href="#1-方块表示与旋转" class="headerlink" title="1. 方块表示与旋转"></a>1. 方块表示与旋转</h5><ul><li>采用4x4字符矩阵表示方块，通过旋转算法实现多角度变换：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模拟俄罗斯方块的旋转</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> px, <span class="hljs-type">int</span> py, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">switch</span> (r % <span class="hljs-number">4</span>)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> py * <span class="hljs-number">4</span> + px;         <span class="hljs-comment">//0 degress</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">12</span> + py - (px * <span class="hljs-number">4</span>);<span class="hljs-comment">//90 degress</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">15</span> - (py * <span class="hljs-number">4</span>) - px;<span class="hljs-comment">//180 degress</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">3</span> - py + (px * <span class="hljs-number">4</span>);     <span class="hljs-comment">//270 degress</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-碰撞检测"><a href="#2-碰撞检测" class="headerlink" title="2. 碰撞检测"></a>2. 碰撞检测</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DoesPieceFit</span><span class="hljs-params">(<span class="hljs-type">int</span> nTetromino, <span class="hljs-type">int</span> nRotation, <span class="hljs-type">int</span> nPosX, <span class="hljs-type">int</span> nPosY)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// All Field cells &gt;0 are occupied</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">0</span>; px &lt; <span class="hljs-number">4</span>; px++)<span class="hljs-comment">// 循环遍历方块的水平位置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<span class="hljs-comment">// 循环遍历方块的垂直位置</span><br>&#123;<br><span class="hljs-comment">// Get index into piece</span><br><span class="hljs-comment">// 获取方块内部位置的索引</span><br><span class="hljs-type">int</span> pi = <span class="hljs-built_in">Rotate</span>(px, py, nRotation);<br><br><span class="hljs-comment">// Get index into field</span><br><span class="hljs-comment">// 获取方块在游戏区域中的索引</span><br><span class="hljs-type">int</span> fi = (nPosY + py) * nFieldWidth + (nPosX + px);<br><br><span class="hljs-comment">// Check that test is in bounds. Note out of bounds does</span><br><span class="hljs-comment">// not necessarily mean a fail, as the long vertical piece</span><br><span class="hljs-comment">// can have cells that lie outside the boundary, so we&#x27;ll</span><br><span class="hljs-comment">// just ignore them</span><br><span class="hljs-keyword">if</span> (nPosX + px &gt;= <span class="hljs-number">0</span> &amp;&amp; nPosX + px &lt; nFieldWidth)<span class="hljs-comment">// 检查方块是否在横向范围内</span><br>&#123;<br><span class="hljs-keyword">if</span> (nPosY + py &gt;= <span class="hljs-number">0</span> &amp;&amp; nPosY + py &lt; nFieldHeight)<span class="hljs-comment">// 检查方块是否在纵向范围内</span><br>&#123;<br><span class="hljs-comment">// In Bounds so do collision check</span><br><span class="hljs-keyword">if</span> (tetromino[nTetromino][pi] != <span class="hljs-string">L&#x27;.&#x27;</span> &amp;&amp; pField[fi] != <span class="hljs-number">0</span>)<span class="hljs-comment">// 检查方块和游戏区域是否有重叠</span><br><span class="hljs-comment">// 第一个碰撞就返回失败</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// fail on first hit</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 方块适合放置在指定位置</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-方块定义"><a href="#3-方块定义" class="headerlink" title="3. 方块定义"></a>3. 方块定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++">tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br><br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br><br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="4-游戏主循环"><a href="#4-游戏主循环" class="headerlink" title="4. 游戏主循环"></a>4. 游戏主循环</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (!bGameOver)<br>&#123;<br><span class="hljs-comment">//GAME TIMING =======================================</span><br>this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">50</span>ms);<br>nSpeedCounter++;<br>bForceDown = (nSpeedCounter == nSpeed);<br><br><span class="hljs-comment">//INPUT =============================================</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++)<span class="hljs-comment">// R   L   D Z</span><br><span class="hljs-comment">// 判断了指定键码对应的按键是否处于按下状态。如果按键被按下，则结果为真，否则为假。</span><br>bKey[k] = (<span class="hljs-number">0x8000</span> &amp; <span class="hljs-built_in">GetAsyncKeyState</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(<span class="hljs-string">&quot;\x27\x25\x28Z&quot;</span>[k]))) != <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//GAME LOGIC ========================================</span><br><span class="hljs-comment">// Handle player movement</span><br><span class="hljs-comment">// 处理玩家的移动</span><br><span class="hljs-comment">// 按下右键 right</span><br>nCurrentX += (bKey[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX + <span class="hljs-number">1</span>, nCurrentY)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 按下左键 left</span><br>nCurrentX -= (bKey[<span class="hljs-number">1</span>] &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX - <span class="hljs-number">1</span>, nCurrentY)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 按下下键 down</span><br>nCurrentY += (bKey[<span class="hljs-number">2</span>] &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX, nCurrentY + <span class="hljs-number">1</span>)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 按下Z键，旋转</span><br><span class="hljs-keyword">if</span> (bKey[<span class="hljs-number">3</span>])<span class="hljs-comment">// 按下Z键</span><br>&#123;<br>nCurrentRotation += (bRotateHold &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation + <span class="hljs-number">1</span>, nCurrentX, nCurrentY)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>bRotateHold = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>bRotateHold = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 无法连续旋转</span><br><br><span class="hljs-keyword">if</span> (bForceDown)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX, nCurrentY + <span class="hljs-number">1</span>))<br>nCurrentY++;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// Lock the current in the field</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">0</span>; px &lt; <span class="hljs-number">4</span>; px++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<br><span class="hljs-keyword">if</span> (tetromino[nCurrentPiece][<span class="hljs-built_in">Rotate</span>(px, py, nCurrentRotation)] == <span class="hljs-string">L&#x27;X&#x27;</span>)<br>pField[(nCurrentY + py) * nFieldWidth + (nCurrentX + px)] = nCurrentPiece + <span class="hljs-number">1</span>;<br><br>nPieceCount++;<br><span class="hljs-keyword">if</span> (nPieceCount % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> (nSpeed &gt;= <span class="hljs-number">10</span>) nSpeed--;<br><br><br><span class="hljs-comment">// Check have we got any lines</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<br><span class="hljs-keyword">if</span> (nCurrentY + py &lt; nFieldHeight - <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-type">bool</span> bLine = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">1</span>; px &lt; nFieldWidth - <span class="hljs-number">1</span>; px++)<br>bLine &amp;= (pField[(nCurrentY + py) * nFieldWidth + px]) != <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (bLine)<br>&#123;<br><span class="hljs-comment">// Remove Line, set to = </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">1</span>; px &lt; nFieldWidth - <span class="hljs-number">1</span>; px++)<br>pField[(nCurrentY + py) * nFieldWidth + px] = <span class="hljs-number">8</span>; <br><br>vLines.<span class="hljs-built_in">push_back</span>(nCurrentY + py);<br>&#125;<br>&#125;<br>nScore += <span class="hljs-number">50</span>;<br><span class="hljs-keyword">if</span> (!vLines.<span class="hljs-built_in">empty</span>()) nScore += (<span class="hljs-number">1</span> &lt;&lt; vLines.<span class="hljs-built_in">size</span>()) * <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// Choose next piece</span><br>nCurrentX = nFieldWidth / <span class="hljs-number">2</span>;<br>nCurrentY = <span class="hljs-number">0</span>;<br>nCurrentRotation = <span class="hljs-number">0</span>;<br>nCurrentPiece = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">7</span>;<br><br>bGameOver = !<span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX, nCurrentY);<br>&#125;<br>nSpeedCounter = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//RENDER OUTPUT =====================================</span><br><br><br><br><span class="hljs-comment">// Draw Field</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; nFieldWidth; x++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; nFieldHeight; y++)<br>screen[(y + <span class="hljs-number">2</span>) * nScreenWidth + (x + <span class="hljs-number">2</span>)] = <span class="hljs-string">L&quot; ABCDEFG=#&quot;</span>[pField[y * nFieldWidth + x]];<br><br><span class="hljs-comment">// Draw Current piece</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">0</span>; px &lt; <span class="hljs-number">4</span>; px++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<br><span class="hljs-keyword">if</span> (tetromino[nCurrentPiece][<span class="hljs-built_in">Rotate</span>(px, py, nCurrentRotation)] == <span class="hljs-string">L&#x27;X&#x27;</span>)<br>screen[(nCurrentY + py + <span class="hljs-number">2</span>) * nScreenWidth + (nCurrentX + px + <span class="hljs-number">2</span>)] = nCurrentPiece + <span class="hljs-number">65</span>;<br><br><span class="hljs-comment">// Draw Score</span><br><span class="hljs-built_in">swprintf_s</span>(&amp;screen[<span class="hljs-number">2</span> * nScreenWidth + nFieldWidth + <span class="hljs-number">6</span>], <span class="hljs-number">16</span>, <span class="hljs-string">L&quot;SCORE: %8d&quot;</span>, nScore);<br><br><span class="hljs-keyword">if</span> (!vLines.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// Display Frame (cheekily to dray lines</span><br><span class="hljs-built_in">WriteConsoleOutputCharacter</span>(hConsole, screen, nScreenWidth * nScreenHeight, &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;, &amp;dwBytesWritten);<br>this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">400</span>ms);  <span class="hljs-comment">//Delay a bit</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; v : vLines)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">1</span>; px &lt; nFieldWidth - <span class="hljs-number">1</span>; px++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = v; py &gt; <span class="hljs-number">0</span>; py--)<br>pField[py * nFieldWidth + px] = pField[(py - <span class="hljs-number">1</span>) * nFieldWidth + px];<br>pField[px] = <span class="hljs-number">0</span>;<br>&#125;<br>vLines.<span class="hljs-built_in">clear</span>();<br>&#125;<br><br><span class="hljs-comment">//Display Frame</span><br><span class="hljs-built_in">WriteConsoleOutputCharacter</span>(hConsole, screen, nScreenWidth * nScreenHeight, &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;, &amp;dwBytesWritten);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a href="https://github.com/hwl111/hwl111.github.io/blob/main/code/tetris.cpp">在线查看代码</a></li><li><a href="https://github.com/hwl111/hwl111.github.io/raw/main/code/tetris.cpp">直接下载代码</a></li></ul><p>通过这个项目，我们不仅实现了经典游戏，还掌握了：</p><ul><li>二维游戏逻辑开发</li><li>控制台图形渲染</li><li>实时输入处理</li><li>状态管理技巧</li></ul>]]></content>
    
    
    <categories>
      
      <category>个人项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>游戏开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法时间复杂度与空间复杂度详解</title>
    <link href="/2025/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2025/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="算法时间复杂度与空间复杂度"><a href="#算法时间复杂度与空间复杂度" class="headerlink" title="算法时间复杂度与空间复杂度"></a>算法时间复杂度与空间复杂度</h3><h4 id="什么是算法复杂度"><a href="#什么是算法复杂度" class="headerlink" title="什么是算法复杂度"></a>什么是算法复杂度</h4><p>算法复杂度是衡量算法效率的重要指标，主要包括：</p><ul><li><strong>时间复杂度</strong>：算法执行所需的时间量级</li><li><strong>空间复杂度</strong>：算法执行所需的内存空间量级</li></ul><p>复杂度作用：</p><ol><li>比较不同算法的效率</li><li>预测算法在不同规模数据下的表现</li><li>优化程序性能</li></ol><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><h5 id="1-大O表示法"><a href="#1-大O表示法" class="headerlink" title="1. 大O表示法"></a>1. 大O表示法</h5><p>大O表示法（Big-O Notation）描述了算法在最坏情况下的增长趋势：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        std::cout&lt;&lt;i;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子的时间复杂度就是O(n)</p><h5 id="2-常见时间复杂度对比"><a href="#2-常见时间复杂度对比" class="headerlink" title="2. 常见时间复杂度对比"></a>2. 常见时间复杂度对比</h5><table><thead><tr><th align="left">复杂度</th><th align="left">名称</th><th align="left">示例</th><th align="left">n&#x3D;100时的操作次数</th></tr></thead><tbody><tr><td align="left">O(1)</td><td align="left">常数时间</td><td align="left">哈希表查找</td><td align="left">1</td></tr><tr><td align="left">O(log n)</td><td align="left">对数时间</td><td align="left">二分查找</td><td align="left">~7</td></tr><tr><td align="left">O(n)</td><td align="left">线性时间</td><td align="left">遍历数组</td><td align="left">100</td></tr><tr><td align="left">O(n log n)</td><td align="left">线性对数时间</td><td align="left">快速排序</td><td align="left">~664</td></tr><tr><td align="left">O(n²)</td><td align="left">平方时间</td><td align="left">冒泡排序</td><td align="left">10,000</td></tr><tr><td align="left">O(2ⁿ)</td><td align="left">指数时间</td><td align="left">穷举算法</td><td align="left">1.26e+30</td></tr></tbody></table><h5 id="3-计算规则"><a href="#3-计算规则" class="headerlink" title="3. 计算规则"></a>3. 计算规则</h5><ul><li><strong>加法规则</strong>：T(n) &#x3D; T1(n) + T2(n) → O(max(f(n), g(n)))</li><li><strong>乘法规则</strong>：T(n) &#x3D; T1(n) * T2(n) → O(f(n) * g(n))</li></ul><h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><h5 id="1-计算方法"><a href="#1-计算方法" class="headerlink" title="1. 计算方法"></a>1. 计算方法</h5><p>计算算法运行过程中<strong>额外</strong>占用的存储空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># O(n)空间复杂度示例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_array</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>] * n  <span class="hljs-comment"># 需要分配n个元素的存储空间</span><br></code></pre></td></tr></table></figure><h5 id="2-常见空间复杂度"><a href="#2-常见空间复杂度" class="headerlink" title="2. 常见空间复杂度"></a>2. 常见空间复杂度</h5><table><thead><tr><th align="left">复杂度</th><th align="left">说明</th><th align="left">典型算法</th></tr></thead><tbody><tr><td align="left">O(1)</td><td align="left">固定大小的额外空间</td><td align="left">迭代算法</td></tr><tr><td align="left">O(n)</td><td align="left">与输入规模线性相关</td><td align="left">归并排序</td></tr><tr><td align="left">O(n²)</td><td align="left">二维数据结构</td><td align="left">邻接矩阵存储图</td></tr></tbody></table><h4 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 递归实现（时间复杂度O(2ⁿ)，空间复杂度O(n)）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_recursive</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">return</span> fib_recursive(n-<span class="hljs-number">1</span>) + fib_recursive(n-<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 迭代实现（时间复杂度O(n)，空间复杂度O(1)）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_iterative</span>(<span class="hljs-params">n</span>):<br>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        a, b = b, a + b<br>    <span class="hljs-keyword">return</span> a<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时间复杂度</tag>
      
      <tag>空间复杂度</tag>
      
      <tag>算法基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树与图的进阶算法与工程实践</title>
    <link href="/2024/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="树与图的进阶算法与工程实践"><a href="#树与图的进阶算法与工程实践" class="headerlink" title="树与图的进阶算法与工程实践"></a>树与图的进阶算法与工程实践</h1><p>树和图是非线性数据结构的核心，广泛应用于算法竞赛、工程开发和系统设计。本文将深入探讨树与图的高阶算法与实际工程中的应用。</p><h2 id="1-树的高阶遍历与应用"><a href="#1-树的高阶遍历与应用" class="headerlink" title="1. 树的高阶遍历与应用"></a>1. 树的高阶遍历与应用</h2><h3 id="1-1-Morris-遍历"><a href="#1-1-Morris-遍历" class="headerlink" title="1.1 Morris 遍历"></a>1.1 Morris 遍历</h3><ul><li>利用线索化思想实现 O(1) 空间的中序遍历。</li><li>适合内存受限场景。</li></ul><h3 id="1-2-线段树与树状数组"><a href="#1-2-线段树与树状数组" class="headerlink" title="1.2 线段树与树状数组"></a>1.2 线段树与树状数组</h3><ul><li>支持区间查询与修改，常用于竞赛和数据库索引。</li><li>线段树适合动态区间，树状数组适合前缀和。</li></ul><h3 id="1-3-平衡树（AVL、红黑树、Treap）"><a href="#1-3-平衡树（AVL、红黑树、Treap）" class="headerlink" title="1.3 平衡树（AVL、红黑树、Treap）"></a>1.3 平衡树（AVL、红黑树、Treap）</h3><ul><li>保证插入、删除、查找 O(log n) 时间复杂度。</li><li>应用：STL map&#x2F;set、数据库索引、操作系统调度。</li></ul><h2 id="2-图的高阶搜索与工程实践"><a href="#2-图的高阶搜索与工程实践" class="headerlink" title="2. 图的高阶搜索与工程实践"></a>2. 图的高阶搜索与工程实践</h2><h3 id="2-1-拓扑排序"><a href="#2-1-拓扑排序" class="headerlink" title="2.1 拓扑排序"></a>2.1 拓扑排序</h3><ul><li>DAG 上的线性排序，常用于任务调度、编译依赖。</li></ul><h3 id="2-2-最短路算法"><a href="#2-2-最短路算法" class="headerlink" title="2.2 最短路算法"></a>2.2 最短路算法</h3><ul><li>Dijkstra、SPFA、A*，工程中常用于地图导航、网络路由。</li></ul><h3 id="2-3-最小生成树"><a href="#2-3-最小生成树" class="headerlink" title="2.3 最小生成树"></a>2.3 最小生成树</h3><ul><li>Kruskal、Prim 算法，应用于网络设计、聚类分析。</li></ul><h3 id="2-4-强连通分量与割点"><a href="#2-4-强连通分量与割点" class="headerlink" title="2.4 强连通分量与割点"></a>2.4 强连通分量与割点</h3><ul><li>Tarjan 算法，适合社交网络、依赖分析。</li></ul><h2 id="3-工程中的树与图优化"><a href="#3-工程中的树与图优化" class="headerlink" title="3. 工程中的树与图优化"></a>3. 工程中的树与图优化</h2><h3 id="3-1-压缩存储"><a href="#3-1-压缩存储" class="headerlink" title="3.1 压缩存储"></a>3.1 压缩存储</h3><ul><li>邻接表、邻接矩阵、稀疏图压缩，节省内存。</li></ul><h3 id="3-2-并查集与路径压缩"><a href="#3-2-并查集与路径压缩" class="headerlink" title="3.2 并查集与路径压缩"></a>3.2 并查集与路径压缩</h3><ul><li>动态连通性判定，常用于社交网络、网络连通。</li></ul><h3 id="3-3-并行与分布式图计算"><a href="#3-3-并行与分布式图计算" class="headerlink" title="3.3 并行与分布式图计算"></a>3.3 并行与分布式图计算</h3><ul><li>大规模图处理采用分布式框架（如 Pregel、GraphX）。</li></ul><h2 id="4-代码示例：Tarjan-算法求强连通分量（Python）"><a href="#4-代码示例：Tarjan-算法求强连通分量（Python）" class="headerlink" title="4. 代码示例：Tarjan 算法求强连通分量（Python）"></a>4. 代码示例：Tarjan 算法求强连通分量（Python）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tarjan</span>(<span class="hljs-params">graph</span>):<br>    n = <span class="hljs-built_in">len</span>(graph)<br>    index = <span class="hljs-number">0</span><br>    indices = [-<span class="hljs-number">1</span>] * n<br>    lowlink = [-<span class="hljs-number">1</span>] * n<br>    stack = []<br>    onStack = [<span class="hljs-literal">False</span>] * n<br>    sccs = []<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strongconnect</span>(<span class="hljs-params">v</span>):<br>        <span class="hljs-keyword">nonlocal</span> index<br>        indices[v] = lowlink[v] = index<br>        index += <span class="hljs-number">1</span><br>        stack.append(v)<br>        onStack[v] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> graph[v]:<br>            <span class="hljs-keyword">if</span> indices[w] == -<span class="hljs-number">1</span>:<br>                strongconnect(w)<br>                lowlink[v] = <span class="hljs-built_in">min</span>(lowlink[v], lowlink[w])<br>            <span class="hljs-keyword">elif</span> onStack[w]:<br>                lowlink[v] = <span class="hljs-built_in">min</span>(lowlink[v], indices[w])<br>        <span class="hljs-keyword">if</span> lowlink[v] == indices[v]:<br>            scc = []<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                w = stack.pop()<br>                onStack[w] = <span class="hljs-literal">False</span><br>                scc.append(w)<br>                <span class="hljs-keyword">if</span> w == v:<br>                    <span class="hljs-keyword">break</span><br>            sccs.append(scc)<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> indices[v] == -<span class="hljs-number">1</span>:<br>            strongconnect(v)<br>    <span class="hljs-keyword">return</span> sccs<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>树与图的进阶算法是算法工程师和系统架构师的必备技能。建议结合实际项目和算法题深入理解其原理与优化手段。  </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>树</tag>
      
      <tag>图</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表的高阶应用与优化</title>
    <link href="/2024/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E9%AB%98%E9%98%B6%E5%BA%94%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <url>/2024/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E9%AB%98%E9%98%B6%E5%BA%94%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="链表的高阶应用与优化"><a href="#链表的高阶应用与优化" class="headerlink" title="链表的高阶应用与优化"></a>链表的高阶应用与优化</h1><p>链表作为基础数据结构，在实际工程和算法面试中有着丰富的变种和高阶用法。本文将深入探讨链表的进阶应用、常见优化手段以及面试中的高频考点。</p><h2 id="1-链表的变种"><a href="#1-链表的变种" class="headerlink" title="1. 链表的变种"></a>1. 链表的变种</h2><h3 id="1-1-双向链表"><a href="#1-1-双向链表" class="headerlink" title="1.1 双向链表"></a>1.1 双向链表</h3><ul><li>每个节点有 prev 和 next 指针，支持 O(1) 时间复杂度的前后遍历和删除。</li><li>应用：LRU 缓存淘汰、操作系统任务调度。</li></ul><h3 id="1-2-循环链表"><a href="#1-2-循环链表" class="headerlink" title="1.2 循环链表"></a>1.2 循环链表</h3><ul><li>尾节点指向头节点，适合需要循环遍历的场景。</li><li>应用：约瑟夫环问题、循环队列。</li></ul><h3 id="1-3-跳表（Skip-List）"><a href="#1-3-跳表（Skip-List）" class="headerlink" title="1.3 跳表（Skip List）"></a>1.3 跳表（Skip List）</h3><ul><li>多级链表结构，提升查找效率，接近 O(log n)。</li><li>应用：Redis 有序集合、内存数据库索引。</li></ul><h2 id="2-工程中的链表优化"><a href="#2-工程中的链表优化" class="headerlink" title="2. 工程中的链表优化"></a>2. 工程中的链表优化</h2><h3 id="2-1-内存池与对象复用"><a href="#2-1-内存池与对象复用" class="headerlink" title="2.1 内存池与对象复用"></a>2.1 内存池与对象复用</h3><ul><li>频繁创建&#x2F;销毁节点时，采用内存池减少 GC 压力。</li><li>C++ STL 的 list、Java 的 LinkedBlockingQueue 都有对象池优化。</li></ul><h3 id="2-2-节点缓存与预分配"><a href="#2-2-节点缓存与预分配" class="headerlink" title="2.2 节点缓存与预分配"></a>2.2 节点缓存与预分配</h3><ul><li>批量分配节点，减少内存碎片。</li><li>适合高性能场景，如网络包缓冲区。</li></ul><h3 id="2-3-空间局部性优化"><a href="#2-3-空间局部性优化" class="headerlink" title="2.3 空间局部性优化"></a>2.3 空间局部性优化</h3><ul><li>数组模拟链表（如 LeetCode 707），提升缓存命中率。</li></ul><h2 id="3-复杂操作与面试技巧"><a href="#3-复杂操作与面试技巧" class="headerlink" title="3. 复杂操作与面试技巧"></a>3. 复杂操作与面试技巧</h2><h3 id="3-1-链表反转"><a href="#3-1-链表反转" class="headerlink" title="3.1 链表反转"></a>3.1 链表反转</h3><ul><li>递归与迭代两种写法，考察指针操作能力。</li></ul><h3 id="3-2-K-个一组反转链表"><a href="#3-2-K-个一组反转链表" class="headerlink" title="3.2 K 个一组反转链表"></a>3.2 K 个一组反转链表</h3><ul><li>典型分段处理，需掌握 dummy 节点和分组指针移动。</li></ul><h3 id="3-3-链表环检测"><a href="#3-3-链表环检测" class="headerlink" title="3.3 链表环检测"></a>3.3 链表环检测</h3><ul><li>快慢指针法（Floyd 判圈算法），空间 O(1)。</li></ul><h3 id="3-4-链表排序"><a href="#3-4-链表排序" class="headerlink" title="3.4 链表排序"></a>3.4 链表排序</h3><ul><li>归并排序适合链表，时间 O(n log n)，空间 O(1)。</li></ul><h3 id="3-5-LRU-缓存设计"><a href="#3-5-LRU-缓存设计" class="headerlink" title="3.5 LRU 缓存设计"></a>3.5 LRU 缓存设计</h3><ul><li>双向链表 + 哈希表，O(1) 插入、删除、查找。</li></ul><h2 id="4-代码示例：K-个一组反转链表（Python）"><a href="#4-代码示例：K-个一组反转链表（Python）" class="headerlink" title="4. 代码示例：K 个一组反转链表（Python）"></a>4. 代码示例：K 个一组反转链表（Python）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">head, k</span>):<br>    dummy = ListNode(<span class="hljs-number">0</span>)<br>    dummy.<span class="hljs-built_in">next</span> = head<br>    pre = dummy<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        tail = pre<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            tail = tail.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tail:<br>                <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br>        nex = tail.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 反转 k 个节点</span><br>        prev, curr = tail.<span class="hljs-built_in">next</span>, pre.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            tmp = curr.<span class="hljs-built_in">next</span><br>            curr.<span class="hljs-built_in">next</span> = prev<br>            prev = curr<br>            curr = tmp<br>        tmp = pre.<span class="hljs-built_in">next</span><br>        pre.<span class="hljs-built_in">next</span> = tail<br>        pre = tmp<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>链表的高阶应用不仅考察基础，更考察对工程优化和复杂场景的理解。建议多刷题、多总结，提升链表相关的代码能力和思维深度。 </p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>链表</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++语法详解</title>
    <link href="/2024/06/%E7%AC%94%E8%AE%B0/C++%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/%E7%AC%94%E8%AE%B0/C++%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="C-语法详解"><a href="#C-语法详解" class="headerlink" title="C++语法详解"></a>C++语法详解</h1><p>本文系统梳理 C++ 常用语法，涵盖基础语法、面向对象、模板、STL、内存管理等，适合进阶学习与查阅。</p><h2 id="1-基础语法与数据类型"><a href="#1-基础语法与数据类型" class="headerlink" title="1. 基础语法与数据类型"></a>1. 基础语法与数据类型</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><ul><li>整型：<code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code>, <code>unsigned</code></li><li>浮点型：<code>float</code>, <code>double</code>, <code>long double</code></li><li>字符型：<code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code></li><li>布尔型：<code>bool</code></li><li>字符串：<code>string</code>（需 <code>#include &lt;string&gt;</code>）</li></ul><h3 id="常量与宏"><a href="#常量与宏" class="headerlink" title="常量与宏"></a>常量与宏</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159</span><br></code></pre></td></tr></table></figure><h2 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2. 流程控制"></a>2. 流程控制</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == b) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;&#125;<br><span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;&#125;<br><span class="hljs-keyword">do</span> &#123; ... &#125; <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span> (op) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: ...; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: ...; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: ...;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h2><h3 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="默认参数与函数重载"><a href="#默认参数与函数重载" class="headerlink" title="默认参数与函数重载"></a>默认参数与函数重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="内联函数与递归"><a href="#内联函数与递归" class="headerlink" title="内联函数与递归"></a>内联函数与递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;<br></code></pre></td></tr></table></figure><h2 id="4-指针与引用"><a href="#4-指针与引用" class="headerlink" title="4. 指针与引用"></a>4. 指针与引用</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* p = &amp;a;<br>*p = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> b = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span>&amp; ref = b;<br>ref = <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span>* p = arr;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) cout &lt;&lt; *(p + i);<br></code></pre></td></tr></table></figure><h2 id="5-类与对象"><a href="#5-类与对象" class="headerlink" title="5. 类与对象"></a>5. 类与对象</h2><h3 id="类定义与成员"><a href="#类定义与成员" class="headerlink" title="类定义与成员"></a>类定义与成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Hello, I am &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;构造&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;析构&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="this-指针与静态成员"><a href="#this-指针与静态成员" class="headerlink" title="this 指针与静态成员"></a>this 指针与静态成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-built_in">Counter</span>() &#123; ++count; &#125;<br>&#125;;<br><span class="hljs-type">int</span> Counter::count = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="6-继承与多态"><a href="#6-继承与多态" class="headerlink" title="6. 继承与多态"></a>6. 继承与多态</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Animal&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Dog&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="多态与虚函数"><a href="#多态与虚函数" class="headerlink" title="多态与虚函数"></a>多态与虚函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Animal* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>();<br>p-&gt;<span class="hljs-built_in">speak</span>(); <span class="hljs-comment">// 输出 Dog</span><br></code></pre></td></tr></table></figure><h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="7-模板"><a href="#7-模板" class="headerlink" title="7. 模板"></a>7. 模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br></code></pre></td></tr></table></figure><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123;<br>    T value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Box</span>(T v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="8-STL（标准模板库）"><a href="#8-STL（标准模板库）" class="headerlink" title="8. STL（标准模板库）"></a>8. STL（标准模板库）</h2><h3 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>map&lt;string, <span class="hljs-type">int</span>&gt; m;<br>set&lt;<span class="hljs-type">int</span>&gt; s;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>stack&lt;<span class="hljs-type">int</span>&gt; st;<br></code></pre></td></tr></table></figure><h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="9-内存管理"><a href="#9-内存管理" class="headerlink" title="9. 内存管理"></a>9. 内存管理</h2><h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new&#x2F;delete"></a>new&#x2F;delete</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">delete</span>[] arr;<br></code></pre></td></tr></table></figure><h3 id="智能指针（C-11）"><a href="#智能指针（C-11）" class="headerlink" title="智能指针（C++11）"></a>智能指针（C++11）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">5</span>))</span></span>;<br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="10-异常处理"><a href="#10-异常处理" class="headerlink" title="10. 异常处理"></a>10. 异常处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125; <span class="hljs-built_in">catch</span> (exception&amp; e) &#123;<br>    cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-其他常用语法与技巧"><a href="#11-其他常用语法与技巧" class="headerlink" title="11. 其他常用语法与技巧"></a>11. 其他常用语法与技巧</h2><ul><li>命名空间：<code>namespace myns &#123; ... &#125;</code></li><li>auto 关键字（类型自动推断，C++11）：<code>auto x = 10;</code></li><li>range-based for（C++11）：<code>for (auto x : v) &#123; ... &#125;</code></li><li>lambda 表达式（C++11）：<code>auto f = [](int x)&#123; return x*x; &#125;;</code></li><li>constexpr 常量表达式（C++11）：<code>constexpr int sq(int x) &#123; return x*x; &#125;</code></li><li>枚举类型：<code>enum Color &#123; RED, GREEN, BLUE &#125;;</code></li></ul><hr><p>如需更深入的专题（如C++11&#x2F;14&#x2F;17新特性、并发、模板元编程等），欢迎留言补充！ </p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>编程</tag>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务与隔离级别详解</title>
    <link href="/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL事务与隔离级别详解"><a href="#MySQL事务与隔离级别详解" class="headerlink" title="MySQL事务与隔离级别详解"></a>MySQL事务与隔离级别详解</h1><p>事务是数据库可靠性的基础。本文详细解析 MySQL 事务的 ACID 特性、隔离级别、并发问题与 InnoDB 实现原理。</p><h2 id="1-事务的-ACID-特性"><a href="#1-事务的-ACID-特性" class="headerlink" title="1. 事务的 ACID 特性"></a>1. 事务的 ACID 特性</h2><ul><li><strong>原子性（Atomicity）</strong>：事务不可分割，要么全部成功要么全部失败。</li><li><strong>一致性（Consistency）</strong>：事务前后数据完整性不被破坏。</li><li><strong>隔离性（Isolation）</strong>：并发事务互不干扰。</li><li><strong>持久性（Durability）</strong>：事务提交后数据永久保存。</li></ul><h2 id="2-四大隔离级别"><a href="#2-四大隔离级别" class="headerlink" title="2. 四大隔离级别"></a>2. 四大隔离级别</h2><ul><li><strong>Read Uncommitted（读未提交）</strong>：最低，可能脏读。</li><li><strong>Read Committed（读已提交）</strong>：Oracle 默认，防止脏读，可能不可重复读。</li><li><strong>Repeatable Read（可重复读）</strong>：MySQL 默认，防止脏读和不可重复读，可能幻读。</li><li><strong>Serializable（可串行化）</strong>：最高，完全串行，性能最低。</li></ul><h2 id="3-并发问题"><a href="#3-并发问题" class="headerlink" title="3. 并发问题"></a>3. 并发问题</h2><ul><li><strong>脏读</strong>：读到未提交事务的数据。</li><li><strong>不可重复读</strong>：同一事务两次读取同一数据结果不同。</li><li><strong>幻读</strong>：同一事务两次查询，第二次多了&#x2F;少了行。</li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read Committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="4-InnoDB-实现原理"><a href="#4-InnoDB-实现原理" class="headerlink" title="4. InnoDB 实现原理"></a>4. InnoDB 实现原理</h2><ul><li><strong>MVCC（多版本并发控制）</strong>：通过隐藏字段和 undo log 实现快照读，提升并发性能。</li><li><strong>行锁与间隙锁</strong>：防止幻读，保证隔离性。</li><li><strong>意向锁</strong>：加速表级锁与行级锁兼容判断。</li></ul><h2 id="5-事务相关SQL"><a href="#5-事务相关SQL" class="headerlink" title="5. 事务相关SQL"></a>5. 事务相关SQL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br><br><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br></code></pre></td></tr></table></figure><h2 id="6-常见面试题"><a href="#6-常见面试题" class="headerlink" title="6. 常见面试题"></a>6. 常见面试题</h2><ul><li>MySQL 默认隔离级别？如何防止幻读？</li><li>MVCC 的原理？快照读和当前读的区别？</li><li>行锁、间隙锁、意向锁的区别？</li><li>事务的四大特性？</li></ul><hr><p>理解事务与隔离级别是保障数据一致性和高并发性能的关键。 </p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>事务</tag>
      
      <tag>隔离级别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL查询优化与执行计划分析</title>
    <link href="/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90/"/>
    <url>/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL查询优化与执行计划分析"><a href="#MySQL查询优化与执行计划分析" class="headerlink" title="MySQL查询优化与执行计划分析"></a>MySQL查询优化与执行计划分析</h1><p>高效的 SQL 查询是数据库性能的保障。本文系统梳理 MySQL 查询优化方法、EXPLAIN 执行计划分析、慢查询定位与常见反模式。</p><h2 id="1-SQL-优化思路"><a href="#1-SQL-优化思路" class="headerlink" title="1. SQL 优化思路"></a>1. SQL 优化思路</h2><ul><li>只查需要的字段，避免 SELECT *</li><li>WHERE 条件优先用索引列</li><li>合理使用 LIMIT，避免大 OFFSET</li><li>拆分大 SQL，减少锁表</li><li>预估数据量，选择合适的分页方式</li></ul><h2 id="2-EXPLAIN-执行计划分析"><a href="#2-EXPLAIN-执行计划分析" class="headerlink" title="2. EXPLAIN 执行计划分析"></a>2. EXPLAIN 执行计划分析</h2><ul><li><code>EXPLAIN SELECT ...</code> 查看 SQL 执行路径</li><li>关注 type、key、rows、Extra 字段</li><li>type 越靠近 const 性能越好（const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL）</li><li>Extra 字段出现 Using filesort、Using temporary 需警惕</li></ul><h2 id="3-慢查询分析"><a href="#3-慢查询分析" class="headerlink" title="3. 慢查询分析"></a>3. 慢查询分析</h2><ul><li>开启慢查询日志：<code>SET GLOBAL slow_query_log = 1;</code></li><li>查看慢查询日志文件位置：<code>SHOW VARIABLES LIKE &#39;slow_query_log%&#39;;</code></li><li>使用 mysqldumpslow、pt-query-digest 工具分析</li></ul><h2 id="4-常见-SQL-反模式"><a href="#4-常见-SQL-反模式" class="headerlink" title="4. 常见 SQL 反模式"></a>4. 常见 SQL 反模式</h2><ul><li>在 WHERE 中对索引列做函数&#x2F;运算</li><li>隐式类型转换</li><li>过多 JOIN 或子查询</li><li>过度依赖临时表、filesort</li><li>大表分页 OFFSET N 性能差</li></ul><h2 id="5-分页优化"><a href="#5-分页优化" class="headerlink" title="5. 分页优化"></a>5. 分页优化</h2><ul><li>大数据量分页推荐主键游标法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> ? <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id LIMIT <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ul><li>避免 <code>LIMIT 10000, 20</code> 这种大偏移量</li></ul><h2 id="6-索引选择与优化"><a href="#6-索引选择与优化" class="headerlink" title="6. 索引选择与优化"></a>6. 索引选择与优化</h2><ul><li>使用覆盖索引减少回表</li><li>联合索引遵循最左前缀原则</li><li>定期用 <code>SHOW INDEX</code> 检查冗余索引</li></ul><h2 id="7-实际案例分析"><a href="#7-实际案例分析" class="headerlink" title="7. 实际案例分析"></a>7. 实际案例分析</h2><h3 id="案例1：索引未命中"><a href="#案例1：索引未命中" class="headerlink" title="案例1：索引未命中"></a>案例1：索引未命中</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">YEAR</span>(created_at) <span class="hljs-operator">=</span> <span class="hljs-number">2024</span>;<br><span class="hljs-comment">-- 索引失效，建议改为：</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> created_at <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2024-01-01&#x27;</span> <span class="hljs-keyword">AND</span> created_at <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2025-01-01&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="案例2：大表分页优化"><a href="#案例2：大表分页优化" class="headerlink" title="案例2：大表分页优化"></a>案例2：大表分页优化</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100000</span> LIMIT <span class="hljs-number">20</span>;<br><span class="hljs-comment">-- 替代 OFFSET 100000, 20</span><br></code></pre></td></tr></table></figure><hr><p>SQL 优化是持续过程，建议结合 EXPLAIN、慢查询日志和实际业务场景不断调优。 </p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>查询优化</tag>
      
      <tag>执行计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引原理与优化实战</title>
    <link href="/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/"/>
    <url>/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引原理与优化实战"><a href="#MySQL索引原理与优化实战" class="headerlink" title="MySQL索引原理与优化实战"></a>MySQL索引原理与优化实战</h1><p>MySQL 索引是高性能查询的核心。本文深入剖析索引底层原理、常见类型、优化技巧及面试高频考点。</p><h2 id="1-索引类型"><a href="#1-索引类型" class="headerlink" title="1. 索引类型"></a>1. 索引类型</h2><ul><li><strong>主键索引（Primary Key）</strong>：唯一且不能为空，InnoDB表默认聚簇索引。</li><li><strong>唯一索引（Unique）</strong>：唯一但可为空。</li><li><strong>普通索引（Index）</strong>：无唯一性约束。</li><li><strong>全文索引（Fulltext）</strong>：适合大文本字段全文检索。</li><li><strong>联合索引（Composite Index）</strong>：多个字段组成的索引。</li></ul><h2 id="2-B-树索引结构"><a href="#2-B-树索引结构" class="headerlink" title="2. B+树索引结构"></a>2. B+树索引结构</h2><ul><li>InnoDB 默认采用 B+树索引。</li><li>聚簇索引：数据和主键索引存储在一起。</li><li>二级索引：叶子节点存储主键值，需回表查询数据。</li></ul><h2 id="3-索引失效场景"><a href="#3-索引失效场景" class="headerlink" title="3. 索引失效场景"></a>3. 索引失效场景</h2><ul><li>WHERE 条件中对索引列进行函数&#x2F;运算（如 <code>WHERE YEAR(date_col)=2024</code>）。</li><li>隐式类型转换（如字符串和数字比较）。</li><li>LIKE 以 <code>%</code> 开头（如 <code>LIKE &#39;%abc&#39;</code>）。</li><li>OR 连接未全部用到索引。</li><li>索引列未出现在最左前缀。</li></ul><h2 id="4-联合索引与最左前缀原则"><a href="#4-联合索引与最左前缀原则" class="headerlink" title="4. 联合索引与最左前缀原则"></a>4. 联合索引与最左前缀原则</h2><ul><li>联合索引如 (a, b, c)，可用于 (a)、(a, b)、(a, b, c) 的查询。</li><li>WHERE b&#x3D;… 无法单独用到 (a, b, c) 联合索引。</li><li>建议将区分度高的字段放在前面。</li></ul><h2 id="5-覆盖索引（索引覆盖查询）"><a href="#5-覆盖索引（索引覆盖查询）" class="headerlink" title="5. 覆盖索引（索引覆盖查询）"></a>5. 覆盖索引（索引覆盖查询）</h2><ul><li>查询字段全部在索引中，无需回表，提升性能。</li><li>例：<code>SELECT id, name FROM users WHERE id &gt; 10;</code> 若 (id, name) 有联合索引。</li></ul><h2 id="6-索引优化建议"><a href="#6-索引优化建议" class="headerlink" title="6. 索引优化建议"></a>6. 索引优化建议</h2><ul><li>只为高频查询和过滤字段建索引，避免过多索引拖慢写入。</li><li>使用 EXPLAIN 分析 SQL 是否走索引。</li><li>定期清理冗余和低效索引。</li><li>避免在小表、低基数字段上建索引。</li></ul><h2 id="7-常见面试题"><a href="#7-常见面试题" class="headerlink" title="7. 常见面试题"></a>7. 常见面试题</h2><ul><li>聚簇索引与非聚簇索引区别？</li><li>覆盖索引的原理和优势？</li><li>联合索引的最左前缀原则？</li><li>为什么索引用 B+树而不是哈希&#x2F;二叉树？</li></ul><h2 id="8-EXPLAIN-关键字段简析"><a href="#8-EXPLAIN-关键字段简析" class="headerlink" title="8. EXPLAIN 关键字段简析"></a>8. EXPLAIN 关键字段简析</h2><ul><li>type: 查询类型（ALL、index、range、ref、eq_ref、const、system）</li><li>key: 实际使用的索引</li><li>rows: 预估扫描行数</li><li>Extra: 是否使用了 Using index、Using where、Using filesort</li></ul><hr><p>索引优化是 MySQL 性能调优的核心，建议结合实际业务场景和 SQL 语句灵活设计。 </p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>索引</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL语法详解</title>
    <link href="/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL语法详解"><a href="#MySQL语法详解" class="headerlink" title="MySQL语法详解"></a>MySQL语法详解</h1><p>本文系统梳理 MySQL 常用语法，涵盖表结构、数据操作、查询优化、事务控制、索引、常用函数等，适合进阶学习与查阅。</p><h2 id="1-数据定义语言（DDL）"><a href="#1-数据定义语言（DDL）" class="headerlink" title="1. 数据定义语言（DDL）"></a>1. 数据定义语言（DDL）</h2><h3 id="创建数据库和表"><a href="#创建数据库和表" class="headerlink" title="创建数据库和表"></a>创建数据库和表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE dbname <span class="hljs-keyword">CHARACTER SET</span> utf8mb4;<br>USE dbname;<br><br><span class="hljs-keyword">CREATE TABLE</span> users (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  age <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">18</span>,<br>  email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">UNIQUE</span>,<br>  created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span><br>);<br></code></pre></td></tr></table></figure><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> users <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;M&#x27;</span>;<br><span class="hljs-keyword">ALTER TABLE</span> users <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> gender;<br><span class="hljs-keyword">ALTER TABLE</span> users MODIFY <span class="hljs-keyword">COLUMN</span> age <span class="hljs-type">SMALLINT</span>;<br><span class="hljs-keyword">ALTER TABLE</span> users CHANGE name username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h3 id="删除表-数据库"><a href="#删除表-数据库" class="headerlink" title="删除表&#x2F;数据库"></a>删除表&#x2F;数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> users;<br><span class="hljs-keyword">DROP</span> DATABASE IF <span class="hljs-keyword">EXISTS</span> dbname;<br></code></pre></td></tr></table></figure><h2 id="2-数据操作语言（DML）"><a href="#2-数据操作语言（DML）" class="headerlink" title="2. 数据操作语言（DML）"></a>2. 数据操作语言（DML）</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> users (name, age, email) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;alice@example.com&#x27;</span>);<br><span class="hljs-keyword">INSERT INTO</span> users <span class="hljs-keyword">SET</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Bob&#x27;</span>, age<span class="hljs-operator">=</span><span class="hljs-number">22</span>, email<span class="hljs-operator">=</span><span class="hljs-string">&#x27;bob@example.com&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">SET</span> age<span class="hljs-operator">=</span><span class="hljs-number">21</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Alice&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">18</span>;<br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> users; <span class="hljs-comment">-- 清空表并重置自增</span><br></code></pre></td></tr></table></figure><h2 id="3-数据查询语言（DQL）"><a href="#3-数据查询语言（DQL）" class="headerlink" title="3. 数据查询语言（DQL）"></a>3. 数据查询语言（DQL）</h2><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users;<br><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">18</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="聚合与分组"><a href="#聚合与分组" class="headerlink" title="聚合与分组"></a>聚合与分组</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> total, <span class="hljs-built_in">AVG</span>(age) <span class="hljs-keyword">FROM</span> users;<br><span class="hljs-keyword">SELECT</span> age, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> u.name, o.amount<br><span class="hljs-keyword">FROM</span> users u<br><span class="hljs-keyword">JOIN</span> orders o <span class="hljs-keyword">ON</span> u.id <span class="hljs-operator">=</span> o.user_id<br><span class="hljs-keyword">WHERE</span> o.amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">-- 左连接</span><br><span class="hljs-keyword">SELECT</span> u.name, o.amount<br><span class="hljs-keyword">FROM</span> users u<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> orders o <span class="hljs-keyword">ON</span> u.id <span class="hljs-operator">=</span> o.user_id;<br></code></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> adult_users <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">18</span>;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> IF <span class="hljs-keyword">EXISTS</span> adult_users;<br></code></pre></td></tr></table></figure><h2 id="4-索引与约束"><a href="#4-索引与约束" class="headerlink" title="4. 索引与约束"></a>4. 索引与约束</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_age <span class="hljs-keyword">ON</span> users(age);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_email <span class="hljs-keyword">ON</span> users(email);<br><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> users;<br><span class="hljs-keyword">DROP</span> INDEX idx_age <span class="hljs-keyword">ON</span> users;<br></code></pre></td></tr></table></figure><h3 id="主键与外键"><a href="#主键与外键" class="headerlink" title="主键与外键"></a>主键与外键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> orders <span class="hljs-keyword">ADD CONSTRAINT</span> fk_user <span class="hljs-keyword">FOREIGN KEY</span> (user_id) <span class="hljs-keyword">REFERENCES</span> users(id);<br></code></pre></td></tr></table></figure><h2 id="5-事务与锁"><a href="#5-事务与锁" class="headerlink" title="5. 事务与锁"></a>5. 事务与锁</h2><h3 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> age <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br></code></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><h2 id="6-常用函数"><a href="#6-常用函数" class="headerlink" title="6. 常用函数"></a>6. 常用函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">CONCAT(name, <span class="hljs-string">&#x27;-&#x27;</span>, email)<br><span class="hljs-built_in">UPPER</span>(name)<br><span class="hljs-built_in">LOWER</span>(email)<br><span class="hljs-built_in">SUBSTRING</span>(name, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>REPLACE(email, <span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;#&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">NOW()<br>CURDATE()<br>DATE_FORMAT(created_at, <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)<br>TIMESTAMPDIFF(<span class="hljs-keyword">YEAR</span>, created_at, NOW())<br></code></pre></td></tr></table></figure><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">ROUND(<span class="hljs-number">3.1415</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">FLOOR</span>(age<span class="hljs-operator">/</span><span class="hljs-number">10</span>)<br>RAND()<br></code></pre></td></tr></table></figure><h2 id="7-性能优化建议"><a href="#7-性能优化建议" class="headerlink" title="7. 性能优化建议"></a>7. 性能优化建议</h2><ul><li>合理建索引，避免全表扫描</li><li>使用 EXPLAIN 分析 SQL 执行计划</li><li>避免 SELECT *，只查需要的字段</li><li>WHERE 条件优先用索引列</li><li>分页查询时避免大 OFFSET，可用主键游标</li><li>定期优化表（OPTIMIZE TABLE）</li></ul><h2 id="8-其他常用语法"><a href="#8-其他常用语法" class="headerlink" title="8. 其他常用语法"></a>8. 其他常用语法</h2><h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 导出</span><br>mysqldump <span class="hljs-operator">-</span>u <span class="hljs-keyword">user</span> <span class="hljs-operator">-</span>p dbname <span class="hljs-operator">&gt;</span> backup.sql<br><span class="hljs-comment">-- 导入</span><br>mysql <span class="hljs-operator">-</span>u <span class="hljs-keyword">user</span> <span class="hljs-operator">-</span>p dbname <span class="hljs-operator">&lt;</span> backup.sql<br></code></pre></td></tr></table></figure><h3 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;test&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> dbname.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;test&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><hr><p>如需更详细的语法或特定场景示例，可在评论区留言或查阅官方文档。 </p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
