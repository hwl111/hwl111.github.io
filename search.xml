<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++11/14/17/20新特性详解</title>
      <link href="/2025/06/%E7%AC%94%E8%AE%B0/C++11-14-17-20%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/06/%E7%AC%94%E8%AE%B0/C++11-14-17-20%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="C-11-14-17-20新特性详解"><a href="#C-11-14-17-20新特性详解" class="headerlink" title="C++11&#x2F;14&#x2F;17&#x2F;20新特性详解"></a>C++11&#x2F;14&#x2F;17&#x2F;20新特性详解</h1><p>本文系统梳理C++11&#x2F;14&#x2F;17&#x2F;20的主要新特性，涵盖【概念】、【使用场景】、代码示例、语法增强、标准库扩展和实际应用建议。</p><h2 id="1-C-11-主要新特性"><a href="#1-C-11-主要新特性" class="headerlink" title="1. C++11 主要新特性"></a>1. C++11 主要新特性</h2><h3 id="auto-类型推断"><a href="#auto-类型推断" class="headerlink" title="auto 类型推断"></a>auto 类型推断</h3><p><strong>【概念】</strong><br>自动根据初始化表达式推断变量类型。<br><strong>【使用场景】</strong><br>简化泛型代码、减少冗余类型声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br></code></pre></td></tr></table></figure><h3 id="range-based-for-循环"><a href="#range-based-for-循环" class="headerlink" title="range-based for 循环"></a>range-based for 循环</h3><p><strong>【概念】</strong><br>基于范围的for循环，简化容器遍历。<br><strong>【使用场景】</strong><br>遍历STL容器、数组等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : v) cout &lt;&lt; x &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><p><strong>【概念】</strong><br>匿名函数对象，支持捕获外部变量。<br><strong>【使用场景】</strong><br>回调、算法、并发任务、事件处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * x; &#125;;<br>cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">5</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="智能指针（unique-ptr-shared-ptr-weak-ptr）"><a href="#智能指针（unique-ptr-shared-ptr-weak-ptr）" class="headerlink" title="智能指针（unique_ptr, shared_ptr, weak_ptr）"></a>智能指针（unique_ptr, shared_ptr, weak_ptr）</h3><p><strong>【概念】</strong><br>自动管理动态内存，防止内存泄漏。<br><strong>【使用场景】</strong><br>资源管理、对象生命周期控制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">auto</span> p1 = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">auto</span> p2 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h3 id="右值引用与移动语义"><a href="#右值引用与移动语义" class="headerlink" title="右值引用与移动语义"></a>右值引用与移动语义</h3><p><strong>【概念】</strong><br>支持资源的高效转移，避免不必要的拷贝。<br><strong>【使用场景】</strong><br>容器扩容、临时对象优化、大对象传递。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// 移动语义</span><br>string s = <span class="hljs-string">&quot;world&quot;</span>;<br>v.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(s));<br></code></pre></td></tr></table></figure><h3 id="nullptr、enum-class、static-assert"><a href="#nullptr、enum-class、static-assert" class="headerlink" title="nullptr、enum class、static_assert"></a>nullptr、enum class、static_assert</h3><p><strong>【概念】</strong><br>nullptr：类型安全的空指针；enum class：强类型枚举；static_assert：编译期断言。<br><strong>【使用场景】</strong><br>类型安全、编译期检查、枚举类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123; Red, Green, Blue &#125;;<br><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) == <span class="hljs-number">4</span>, <span class="hljs-string">&quot;int必须4字节&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="constexpr、委托构造函数、继承构造函数"><a href="#constexpr、委托构造函数、继承构造函数" class="headerlink" title="constexpr、委托构造函数、继承构造函数"></a>constexpr、委托构造函数、继承构造函数</h3><p><strong>【概念】</strong><br>constexpr：编译期常量；委托&#x2F;继承构造函数：简化构造逻辑。<br><strong>【使用场景】</strong><br>常量表达式、构造函数重用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">sq</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) &#123;&#125;<br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">A</span>(<span class="hljs-number">0</span>) &#123;&#125; <span class="hljs-comment">// 委托构造</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="std-thread、std-mutex-等并发库"><a href="#std-thread、std-mutex-等并发库" class="headerlink" title="std::thread、std::mutex 等并发库"></a>std::thread、std::mutex 等并发库</h3><p><strong>【概念】</strong><br>标准库原生支持多线程与同步。<br><strong>【使用场景】</strong><br>并发编程、异步任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/*...*/</span> &#125;<br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(func)</span></span>;<br>t.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><h3 id="初始化列表（initializer-list）"><a href="#初始化列表（initializer-list）" class="headerlink" title="初始化列表（initializer_list）"></a>初始化列表（initializer_list）</h3><p><strong>【概念】</strong><br>统一的初始化语法。<br><strong>【使用场景】</strong><br>容器初始化、构造函数参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(std::initializer_list&lt;<span class="hljs-type">int</span>&gt; l) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="2-C-14-主要新特性"><a href="#2-C-14-主要新特性" class="headerlink" title="2. C++14 主要新特性"></a>2. C++14 主要新特性</h2><h3 id="泛型lambda（auto参数）"><a href="#泛型lambda（auto参数）" class="headerlink" title="泛型lambda（auto参数）"></a>泛型lambda（auto参数）</h3><p><strong>【概念】</strong><br>lambda参数可用auto声明，支持任意类型。<br><strong>【使用场景】</strong><br>泛型算法、回调。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> add = [](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h3 id="return-type-deduction（函数返回类型自动推断）"><a href="#return-type-deduction（函数返回类型自动推断）" class="headerlink" title="return type deduction（函数返回类型自动推断）"></a>return type deduction（函数返回类型自动推断）</h3><p><strong>【概念】</strong><br>函数返回类型可省略，由编译器推断。<br><strong>【使用场景】</strong><br>简化模板和泛型代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="make-unique"><a href="#make-unique" class="headerlink" title="make_unique"></a>make_unique</h3><p><strong>【概念】</strong><br>安全创建unique_ptr的辅助函数。<br><strong>【使用场景】</strong><br>资源管理、避免裸new。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><h3 id="二进制字面量（0b1010）"><a href="#二进制字面量（0b1010）" class="headerlink" title="二进制字面量（0b1010）"></a>二进制字面量（0b1010）</h3><p><strong>【概念】</strong><br>支持二进制常量。<br><strong>【使用场景】</strong><br>位运算、底层开发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0b1010</span>;<br></code></pre></td></tr></table></figure><h3 id="std-shared-timed-mutex"><a href="#std-shared-timed-mutex" class="headerlink" title="std::shared_timed_mutex"></a>std::shared_timed_mutex</h3><p><strong>【概念】</strong><br>支持读写锁和定时锁。<br><strong>【使用场景】</strong><br>高并发读多写少场景。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br>std::shared_timed_mutex mtx;<br></code></pre></td></tr></table></figure><hr><h2 id="3-C-17-主要新特性"><a href="#3-C-17-主要新特性" class="headerlink" title="3. C++17 主要新特性"></a>3. C++17 主要新特性</h2><h3 id="结构化绑定（structured-bindings）"><a href="#结构化绑定（structured-bindings）" class="headerlink" title="结构化绑定（structured bindings）"></a>结构化绑定（structured bindings）</h3><p><strong>【概念】</strong><br>可将结构&#x2F;元组解包为多个变量。<br><strong>【使用场景】</strong><br>遍历map、解构pair&#x2F;tuple。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> [a, b] = std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>map&lt;string, <span class="hljs-type">int</span>&gt; m = &#123;&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>&#125;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [k, v] : m) cout &lt;&lt; k &lt;&lt; v;<br></code></pre></td></tr></table></figure><h3 id="if-constexpr"><a href="#if-constexpr" class="headerlink" title="if constexpr"></a>if constexpr</h3><p><strong>【概念】</strong><br>编译期条件分支。<br><strong>【使用场景】</strong><br>模板元编程、类型特化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T t)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_integral&lt;T&gt;::value)</span></span><br><span class="hljs-function">        cout &lt;&lt; &quot;<span class="hljs-type">int</span>: <span class="hljs-string">&quot; &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="hljs-string"><span class="hljs-function">    else</span></span><br><span class="hljs-string"><span class="hljs-function">        cout &lt;&lt; &quot;</span>other: <span class="hljs-string">&quot; &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="hljs-string"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><h3 id="内联变量（inline-variable）"><a href="#内联变量（inline-variable）" class="headerlink" title="内联变量（inline variable）"></a>内联变量（inline variable）</h3><p><strong>【概念】</strong><br>支持头文件中定义全局变量。<br><strong>【使用场景】</strong><br>常量、单例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="std-optional-std-variant-std-any"><a href="#std-optional-std-variant-std-any" class="headerlink" title="std::optional, std::variant, std::any"></a>std::optional, std::variant, std::any</h3><p><strong>【概念】</strong><br>可选值、类型安全的联合体、任意类型容器。<br><strong>【使用场景】</strong><br>函数返回值、配置、类型擦除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br>optional&lt;<span class="hljs-type">int</span>&gt; o = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (o) cout &lt;&lt; *o;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><br>variant&lt;<span class="hljs-type">int</span>, string&gt; v = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;any&gt;</span></span><br>any a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h3><p><strong>【概念】</strong><br>轻量级字符串视图，避免拷贝。<br><strong>【使用场景】</strong><br>高性能字符串处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><br>string_view sv = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="并行STL算法（std-for-each-par-…-）"><a href="#并行STL算法（std-for-each-par-…-）" class="headerlink" title="并行STL算法（std::for_each(par, … )）"></a>并行STL算法（std::for_each(par, … )）</h3><p><strong>【概念】</strong><br>STL算法支持并行执行。<br><strong>【使用场景】</strong><br>大数据量并行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execution&gt;</span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>std::for_each(std::execution::par, v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span>&amp; x)&#123; x *= <span class="hljs-number">2</span>; &#125;);<br></code></pre></td></tr></table></figure><h3 id="文件系统库（）"><a href="#文件系统库（）" class="headerlink" title="文件系统库（）"></a>文件系统库（<filesystem>）</h3><p><strong>【概念】</strong><br>标准化文件和路径操作。<br><strong>【使用场景】</strong><br>跨平台文件管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;filesystem&gt;</span></span><br>std::filesystem::path p = <span class="hljs-string">&quot;/tmp/test.txt&quot;</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="4-C-20-主要新特性"><a href="#4-C-20-主要新特性" class="headerlink" title="4. C++20 主要新特性"></a>4. C++20 主要新特性</h2><h3 id="协程（coroutine）"><a href="#协程（coroutine）" class="headerlink" title="协程（coroutine）"></a>协程（coroutine）</h3><p><strong>【概念】</strong><br>支持函数挂起与恢复，简化异步编程。<br><strong>【使用场景】</strong><br>异步IO、生成器、状态机。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需编译器支持</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-comment">// 示例略</span><br></code></pre></td></tr></table></figure><h3 id="概念（concepts）与约束（requires）"><a href="#概念（concepts）与约束（requires）" class="headerlink" title="概念（concepts）与约束（requires）"></a>概念（concepts）与约束（requires）</h3><p><strong>【概念】</strong><br>模板参数约束，提升泛型安全性。<br><strong>【使用场景】</strong><br>泛型库、模板接口。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">concept</span> Addable = <span class="hljs-built_in">requires</span>(T a, T b) &#123; a + b; &#125;;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Addable T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br></code></pre></td></tr></table></figure><h3 id="范围for增强（ranges）"><a href="#范围for增强（ranges）" class="headerlink" title="范围for增强（ranges）"></a>范围for增强（ranges）</h3><p><strong>【概念】</strong><br>基于范围的算法和管道操作。<br><strong>【使用场景】</strong><br>链式数据处理、过滤、变换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : v | std::views::<span class="hljs-built_in">filter</span>([](<span class="hljs-type">int</span> x)&#123;<span class="hljs-keyword">return</span> x%<span class="hljs-number">2</span>;&#125;)) cout &lt;&lt; x;<br></code></pre></td></tr></table></figure><h3 id="三路比较（，spaceship-operator）"><a href="#三路比较（，spaceship-operator）" class="headerlink" title="三路比较（&lt;&#x3D;&gt;，spaceship operator）"></a>三路比较（&lt;&#x3D;&gt;，spaceship operator）</h3><p><strong>【概念】</strong><br>自动生成全序比较操作符。<br><strong>【使用场景】</strong><br>排序、查找、容器比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;compare&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-type">int</span> x, y;<br>  <span class="hljs-keyword">auto</span> <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> Point&amp;) <span class="hljs-type">const</span> = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="模块化（modules）"><a href="#模块化（modules）" class="headerlink" title="模块化（modules）"></a>模块化（modules）</h3><p><strong>【概念】</strong><br>替代头文件的模块系统，提升编译速度。<br><strong>【使用场景】</strong><br>大型项目、库开发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需编译器支持</span><br><span class="hljs-comment">// module; import; export 语法</span><br></code></pre></td></tr></table></figure><h3 id="consteval-constinit"><a href="#consteval-constinit" class="headerlink" title="consteval&#x2F;constinit"></a>consteval&#x2F;constinit</h3><p><strong>【概念】</strong><br>consteval：强制编译期求值；constinit：防止静态初始化顺序问题。<br><strong>【使用场景】</strong><br>编译期常量、全局变量初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">sq</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;<br><span class="hljs-keyword">constinit</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="calendar-timezone库"><a href="#calendar-timezone库" class="headerlink" title="calendar&#x2F;timezone库"></a>calendar&#x2F;timezone库</h3><p><strong>【概念】</strong><br>标准化日期和时区处理。<br><strong>【使用场景】</strong><br>跨时区应用、日志。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;<br><span class="hljs-keyword">auto</span> now = system_clock::<span class="hljs-built_in">now</span>();<br></code></pre></td></tr></table></figure><hr><p>现代C++新特性极大提升了代码表达力与性能，建议结合实际项目逐步迁移和应用。 </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 新特性 </tag>
            
            <tag> 现代C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++并发与多线程编程</title>
      <link href="/2025/06/%E7%AC%94%E8%AE%B0/C++%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2025/06/%E7%AC%94%E8%AE%B0/C++%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C-并发与多线程编程"><a href="#C-并发与多线程编程" class="headerlink" title="C++并发与多线程编程"></a>C++并发与多线程编程</h1><p>C++11起标准库原生支持多线程与并发。本文系统梳理C++并发编程核心知识，配合【概念】、【使用场景】、常用工具和实战技巧。</p><h2 id="1-线程的创建与管理"><a href="#1-线程的创建与管理" class="headerlink" title="1. 线程的创建与管理"></a>1. 线程的创建与管理</h2><p><strong>【概念】</strong><br>线程是操作系统调度的最小单位，C++11通过std::thread支持多线程编程。</p><p><strong>【使用场景】</strong><br>CPU密集型&#x2F;IO密集型任务并行、后台任务、网络服务、异步处理等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; ... &#125;<br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func, <span class="hljs-number">10</span>)</span></span>;<br>t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br><br><span class="hljs-comment">// lambda线程</span><br><span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([]&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span>; &#125;)</span></span>;<br>t<span class="hljs-number">2.</span><span class="hljs-built_in">detach</span>();<br></code></pre></td></tr></table></figure><h2 id="2-互斥锁与锁管理"><a href="#2-互斥锁与锁管理" class="headerlink" title="2. 互斥锁与锁管理"></a>2. 互斥锁与锁管理</h2><p><strong>【概念】</strong><br>互斥锁（mutex）用于保护临界区，防止多线程同时访问共享资源导致数据竞争。</p><p><strong>【使用场景】</strong><br>多线程写共享数据、日志、计数器、缓存等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br>std::mutex mtx;<br>mtx.<span class="hljs-built_in">lock</span>();<br><span class="hljs-comment">// 临界区</span><br>mtx.<span class="hljs-built_in">unlock</span>();<br><br><span class="hljs-comment">// 推荐用lock_guard自动管理</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3. 条件变量"></a>3. 条件变量</h2><p><strong>【概念】</strong><br>条件变量（condition_variable）用于线程间同步，等待某个条件成立时唤醒线程。</p><p><strong>【使用场景】</strong><br>生产者-消费者、任务队列、线程间事件通知等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br>std::condition_variable cv;<br>std::mutex mtx;<br><span class="hljs-type">bool</span> ready = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 等待线程</span><br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx)</span></span>;<br>cv.<span class="hljs-built_in">wait</span>(lk, []&#123;<span class="hljs-keyword">return</span> ready;&#125;);<br><br><span class="hljs-comment">// 通知线程</span><br>ready = <span class="hljs-literal">true</span>;<br>cv.<span class="hljs-built_in">notify_one</span>();<br></code></pre></td></tr></table></figure><h2 id="4-原子操作与内存模型"><a href="#4-原子操作与内存模型" class="headerlink" title="4. 原子操作与内存模型"></a>4. 原子操作与内存模型</h2><p><strong>【概念】</strong><br>原子操作（atomic）保证操作不可中断，避免加锁带来的性能损耗。</p><p><strong>【使用场景】</strong><br>计数器、自增ID、无锁队列、并发标志位等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cnt.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="5-线程池与并发容器"><a href="#5-线程池与并发容器" class="headerlink" title="5. 线程池与并发容器"></a>5. 线程池与并发容器</h2><p><strong>【概念】</strong><br>线程池通过复用线程资源批量处理任务，提高并发效率。并发容器支持多线程安全操作。</p><p><strong>【使用场景】</strong><br>高并发服务器、任务调度、批量数据处理、异步任务。</p><ul><li>标准库暂未内置线程池，可用第三方如 ThreadPool、boost::asio。</li><li>并发容器：C++17起有 std::shared_mutex，C++20有并发数据结构支持。</li></ul><h2 id="6-常见并发问题"><a href="#6-常见并发问题" class="headerlink" title="6. 常见并发问题"></a>6. 常见并发问题</h2><p><strong>【概念】</strong><br>并发编程常见问题包括死锁、竞态条件、活锁、ABA问题等。</p><p><strong>【使用场景】</strong><br>多线程共享资源、复杂同步场景、并发数据结构设计等。</p><ul><li>死锁、竞态条件、活锁、ABA问题</li><li>线程安全与无锁编程</li></ul><h2 id="7-最佳实践"><a href="#7-最佳实践" class="headerlink" title="7. 最佳实践"></a>7. 最佳实践</h2><ul><li>尽量用RAII管理锁</li><li>避免数据竞争，优先用原子类型</li><li>合理拆分任务，避免线程过多</li><li>用future&#x2F;promise进行线程间通信</li></ul><p><strong>示例：future&#x2F;promise</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br>std::promise&lt;<span class="hljs-type">int</span>&gt; p;<br>std::future&lt;<span class="hljs-type">int</span>&gt; f = p.<span class="hljs-built_in">get_future</span>();<br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;p]&#123; p.set_value(<span class="hljs-number">42</span>); &#125;)</span></span>;<br><span class="hljs-type">int</span> result = f.<span class="hljs-built_in">get</span>();<br>t.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><hr><p>并发编程需谨慎，建议多用标准库工具，避免手动管理低层细节。 </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常用设计模式精讲</title>
      <link href="/2025/06/%E7%AC%94%E8%AE%B0/C++%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%AE%B2/"/>
      <url>/2025/06/%E7%AC%94%E8%AE%B0/C++%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="C-常用设计模式精讲"><a href="#C-常用设计模式精讲" class="headerlink" title="C++常用设计模式精讲"></a>C++常用设计模式精讲</h1><p>设计模式是高质量软件开发的核心。本文精选C++常用设计模式，配合【概念】、【使用场景】、代码示例和实际应用建议。</p><h2 id="1-单例模式（Singleton-Pattern）"><a href="#1-单例模式（Singleton-Pattern）" class="headerlink" title="1. 单例模式（Singleton Pattern）"></a>1. 单例模式（Singleton Pattern）</h2><p><strong>【概念】</strong><br>保证一个类只有一个实例，并提供全局访问点。</p><p><strong>【使用场景】</strong><br>配置管理器、日志系统、线程池、数据库连接池等全局唯一对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-工厂模式（Factory-Pattern）"><a href="#2-工厂模式（Factory-Pattern）" class="headerlink" title="2. 工厂模式（Factory Pattern）"></a>2. 工厂模式（Factory Pattern）</h2><p><strong>【概念】</strong><br>定义一个用于创建对象的接口，让子类决定实例化哪一个类。</p><p><strong>【使用场景】</strong><br>框架&#x2F;库需要对外屏蔽具体实现细节，常用于日志库、数据库驱动、UI组件等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct</span> : <span class="hljs-keyword">public</span> Product &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; ... &#125; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Product* <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProduct</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-观察者模式（Observer-Pattern）"><a href="#3-观察者模式（Observer-Pattern）" class="headerlink" title="3. 观察者模式（Observer Pattern）"></a>3. 观察者模式（Observer Pattern）</h2><p><strong>【概念】</strong><br>定义对象间一对多依赖关系，当一个对象状态变化时，所有依赖者都会收到通知。</p><p><strong>【使用场景】</strong><br>事件系统、GUI事件、订阅-发布、MVC架构中的视图更新等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br>    vector&lt;Observer*&gt; obs;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Observer* o)</span> </span>&#123; obs.<span class="hljs-built_in">push_back</span>(o); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> o : obs) o-&gt;<span class="hljs-built_in">update</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-策略模式（Strategy-Pattern）"><a href="#4-策略模式（Strategy-Pattern）" class="headerlink" title="4. 策略模式（Strategy Pattern）"></a>4. 策略模式（Strategy Pattern）</h2><p><strong>【概念】</strong><br>定义一系列算法，将每个算法封装起来，使它们可以互换。</p><p><strong>【使用场景】</strong><br>算法族切换（如排序、压缩）、行为可配置的业务逻辑、AI决策等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteA</span> : <span class="hljs-keyword">public</span> Strategy &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; ... &#125; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    Strategy* s;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Strategy* s_)</span> </span>&#123; s = s_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; s-&gt;<span class="hljs-built_in">execute</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-装饰器模式（Decorator-Pattern）"><a href="#5-装饰器模式（Decorator-Pattern）" class="headerlink" title="5. 装饰器模式（Decorator Pattern）"></a>5. 装饰器模式（Decorator Pattern）</h2><p><strong>【概念】</strong><br>动态地给对象添加额外功能，且不影响其他对象。</p><p><strong>【使用场景】</strong><br>IO流处理、日志增强、权限校验、功能扩展等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorator</span> : <span class="hljs-keyword">public</span> Component &#123;<br>    Component* comp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Decorator</span>(Component* c) : <span class="hljs-built_in">comp</span>(c) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; comp-&gt;<span class="hljs-built_in">op</span>(); <span class="hljs-comment">/*扩展*/</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="6-适配器模式（Adapter-Pattern）"><a href="#6-适配器模式（Adapter-Pattern）" class="headerlink" title="6. 适配器模式（Adapter Pattern）"></a>6. 适配器模式（Adapter Pattern）</h2><p><strong>【概念】</strong><br>将一个类的接口转换成客户端期望的另一个接口，实现类之间的兼容。</p><p><strong>【使用场景】</strong><br>旧系统兼容新接口、第三方库集成、不同协议&#x2F;格式转换等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">specificRequest</span><span class="hljs-params">()</span> </span>&#123; ... &#125; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> : <span class="hljs-keyword">public</span> Target &#123;<br>    Adaptee* adaptee;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Adapter</span>(Adaptee* a) : <span class="hljs-built_in">adaptee</span>(a) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; adaptee-&gt;<span class="hljs-built_in">specificRequest</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="7-模板方法模式（Template-Method-Pattern）"><a href="#7-模板方法模式（Template-Method-Pattern）" class="headerlink" title="7. 模板方法模式（Template Method Pattern）"></a>7. 模板方法模式（Template Method Pattern）</h2><p><strong>【概念】</strong><br>定义算法骨架，将部分步骤延迟到子类实现。</p><p><strong>【使用场景】</strong><br>框架扩展、流程控制、通用算法模板（如排序、数据处理等）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">step1</span>(); <span class="hljs-built_in">step2</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="8-代理模式（Proxy-Pattern）"><a href="#8-代理模式（Proxy-Pattern）" class="headerlink" title="8. 代理模式（Proxy Pattern）"></a>8. 代理模式（Proxy Pattern）</h2><p><strong>【概念】</strong><br>为其他对象提供一种代理以控制对其的访问。</p><p><strong>【使用场景】</strong><br>远程代理、虚拟代理、安全代理、缓存代理、智能指针等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> : <span class="hljs-keyword">public</span> Subject &#123; <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; ... &#125; &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> : <span class="hljs-keyword">public</span> Subject &#123;<br>    RealSubject* real;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Proxy</span>(RealSubject* r) : <span class="hljs-built_in">real</span>(r) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">op</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/*权限/缓存等*/</span> real-&gt;<span class="hljs-built_in">op</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><p>设计模式提升代码复用性、可维护性和扩展性，建议结合实际项目灵活应用。 </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++模板元编程基础与进阶</title>
      <link href="/2025/06/%E7%AC%94%E8%AE%B0/C++%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
      <url>/2025/06/%E7%AC%94%E8%AE%B0/C++%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="C-模板元编程基础与进阶"><a href="#C-模板元编程基础与进阶" class="headerlink" title="C++模板元编程基础与进阶"></a>C++模板元编程基础与进阶</h1><p>模板元编程（Template Metaprogramming）是C++强大泛型能力的体现。本文系统梳理模板基础、递归、SFINAE、type traits、constexpr、变参模板等核心内容，配合【概念】、【使用场景】说明。</p><h2 id="1-模板基础"><a href="#1-模板基础" class="headerlink" title="1. 模板基础"></a>1. 模板基础</h2><p><strong>【概念】</strong><br>模板是C++泛型编程的基础，支持类型参数化，实现代码复用。</p><p><strong>【使用场景】</strong><br>容器库（如STL）、算法泛型化、类型无关的工具类和函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-comment">// 类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123; T value; &#125;;<br></code></pre></td></tr></table></figure><h2 id="2-递归模板与编译期计算"><a href="#2-递归模板与编译期计算" class="headerlink" title="2. 递归模板与编译期计算"></a>2. 递归模板与编译期计算</h2><p><strong>【概念】</strong><br>递归模板通过模板实例化实现编译期递归计算。</p><p><strong>【使用场景】</strong><br>编译期常量计算、类型列表处理、静态断言等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = N * Factorial&lt;N<span class="hljs-number">-1</span>&gt;::value;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-comment">// Factorial&lt;5&gt;::value == 120</span><br></code></pre></td></tr></table></figure><h2 id="3-SFINAE与enable-if"><a href="#3-SFINAE与enable-if" class="headerlink" title="3. SFINAE与enable_if"></a>3. SFINAE与enable_if</h2><p><strong>【概念】</strong><br>SFINAE（Substitution Failure Is Not An Error）是一种模板特化机制，enable_if用于条件编译和类型选择。</p><p><strong>【使用场景】</strong><br>类型萃取、函数重载选择、泛型约束、静态断言。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::<span class="hljs-function">type</span><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">(T t)</span> </span>&#123; <span class="hljs-keyword">return</span> t + <span class="hljs-number">1</span>; &#125;<br></code></pre></td></tr></table></figure><h2 id="4-type-traits与类型萃取"><a href="#4-type-traits与类型萃取" class="headerlink" title="4. type traits与类型萃取"></a>4. type traits与类型萃取</h2><p><strong>【概念】</strong><br>type traits是标准库提供的类型特性萃取工具。</p><p><strong>【使用场景】</strong><br>类型判断、模板特化、泛型算法优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br>std::is_same&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::value <span class="hljs-comment">// true</span><br>std::is_pointer&lt;<span class="hljs-type">int</span>*&gt;::value <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="5-constexpr与编译期函数"><a href="#5-constexpr与编译期函数" class="headerlink" title="5. constexpr与编译期函数"></a>5. constexpr与编译期函数</h2><p><strong>【概念】</strong><br>constexpr函数在编译期求值，提升性能和类型安全。</p><p><strong>【使用场景】</strong><br>编译期常量、静态断言、元编程优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n &lt;= <span class="hljs-number">1</span> ? n : <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>);<br>&#125;<br><span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">fib</span>(<span class="hljs-number">10</span>) == <span class="hljs-number">55</span>, <span class="hljs-string">&quot;error&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="6-变参模板与折叠表达式（C-11-17）"><a href="#6-变参模板与折叠表达式（C-11-17）" class="headerlink" title="6. 变参模板与折叠表达式（C++11&#x2F;17）"></a>6. 变参模板与折叠表达式（C++11&#x2F;17）</h2><p><strong>【概念】</strong><br>变参模板支持任意数量参数，折叠表达式简化参数包操作。</p><p><strong>【使用场景】</strong><br>通用打印、日志、元组处理、泛型容器等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">(Args... args)</span> </span>&#123;<br>    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl; <span class="hljs-comment">// C++17折叠表达式</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-常见元编程技巧与应用"><a href="#7-常见元编程技巧与应用" class="headerlink" title="7. 常见元编程技巧与应用"></a>7. 常见元编程技巧与应用</h2><ul><li>条件编译：<code>std::conditional</code></li><li>类型选择：<code>std::enable_if</code>、<code>std::is_same</code></li><li>静态断言：<code>static_assert</code></li><li>编译期常量：<code>integral_constant</code></li></ul><h2 id="8-应用案例：类型安全的最小值函数"><a href="#8-应用案例：类型安全的最小值函数" class="headerlink" title="8. 应用案例：类型安全的最小值函数"></a>8. 应用案例：类型安全的最小值函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">mymin</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a &lt; b ? a : b; &#125;<br></code></pre></td></tr></table></figure><hr><p>模板元编程可提升代码泛化与性能，但需注意可读性和编译时间。 </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模板元编程 </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MysqlConnectionPool —— C++高并发数据库连接池项目</title>
      <link href="/2025/06/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/MysqlConnectionPool/"/>
      <url>/2025/06/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/MysqlConnectionPool/</url>
      
        <content type="html"><![CDATA[<h1 id="MysqlConnectionPool-——-C-高并发数据库连接池项目"><a href="#MysqlConnectionPool-——-C-高并发数据库连接池项目" class="headerlink" title="MysqlConnectionPool —— C++高并发数据库连接池项目"></a>MysqlConnectionPool —— C++高并发数据库连接池项目</h1><p><a href="https://github.com/hwl111/MysqlConnectionPool">项目GitHub地址</a></p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>MysqlConnectionPool 是一个用 C++ 实现的高效 MySQL 数据库连接池，适用于高并发场景下的数据库访问优化。项目支持线程安全的连接管理、最大连接数限制、空闲连接复用、自动初始化与资源释放等特性。</p><h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ul><li><strong>自定义连接池实现</strong>：支持最大连接数、空闲连接重用、自动初始化与资源释放</li><li><strong>线程安全</strong>：多线程环境下安全复用数据库连接，提升并发性能</li><li><strong>空闲连接维护机制</strong>：定期清理长期未使用的连接，提升资源利用率</li><li><strong>配置文件驱动</strong>：通过 <code>mysql.ini</code> 灵活配置数据库参数和连接池规模</li><li><strong>高可拓展性</strong>：结构清晰，便于扩展异步连接、超时重试等高级功能</li></ul><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">MysqlConnectionPool/<br>├── Connection.cpp / <span class="hljs-string">.h</span>           <span class="hljs-comment"># 封装 MySQL 连接的类</span><br>├── MysqlConnectionPool.cpp / <span class="hljs-string">.h</span> <span class="hljs-comment"># 连接池的核心实现</span><br>├── main.cpp                      <span class="hljs-comment"># 测试或演示程序入口</span><br>├── mysql.ini                     <span class="hljs-comment"># 数据库配置文件</span><br>├── libmysql.dll                  <span class="hljs-comment"># MySQL 客户端动态链接库（Windows）</span><br>├── public.h                      <span class="hljs-comment"># 公共头文件</span><br>└── *<span class="hljs-string">.vcxproj</span> / <span class="hljs-string">.sln</span>              <span class="hljs-comment"># Visual Studio 工程文件</span><br></code></pre></td></tr></table></figure><h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><p><code>mysql.ini</code> 示例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">host</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">port</span> = <span class="hljs-number">3306</span><br><span class="hljs-attr">user</span> = root<br><span class="hljs-attr">password</span> = yourpassword<br><span class="hljs-attr">database</span> = testdb<br><span class="hljs-attr">max_connections</span> = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>请根据实际环境修改数据库配置。</p><h2 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h2><ol><li>使用 Visual Studio 2019 或更高版本打开 <code>MysqlConnectionPool.sln</code></li><li>编译 Release 或 Debug 版本</li><li>将 <code>mysql.ini</code> 放在可执行文件同目录</li><li>运行程序，体验高并发下的数据库连接池性能</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>高并发 Web 服务后台</li><li>多线程数据采集&#x2F;分析系统</li><li>需要频繁访问数据库的 C++ 应用</li><li>任何对数据库连接性能有较高要求的场景</li></ul><h2 id="性能亮点"><a href="#性能亮点" class="headerlink" title="性能亮点"></a>性能亮点</h2><ul><li>连接池显著降低数据库访问延迟，提升多线程环境下的吞吐量</li><li>线程安全机制保证高并发下的稳定性</li></ul><hr><p>如需源码与详细说明，请访问 <a href="https://github.com/hwl111/MysqlConnectionPool">项目GitHub主页</a> </p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 线程池 </tag>
            
            <tag> 连接池 </tag>
            
            <tag> 项目实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2025/03/%E7%AC%94%E8%AE%B0/Git/"/>
      <url>/2025/03/%E7%AC%94%E8%AE%B0/Git/</url>
      
        <content type="html"><![CDATA[<h3 id="git快速入门"><a href="#git快速入门" class="headerlink" title="git快速入门"></a>git快速入门</h3><p>Git 完整命令手册地址：<a href="http://git-scm.com/docs">Git 官方文档</a></p><p>PDF 版命令手册：<a href="https://www.runoob.com/manual/github-git-cheat-sheet.pdf">github-git-cheat-sheet.pdf</a></p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a><strong>基础操作</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化新仓库</td></tr><tr><td align="left"><code>git clone &lt;url&gt;</code></td><td align="left">克隆远程仓库</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看工作区状态</td></tr><tr><td align="left"><code>git add &lt;file&gt; </code></td><td align="left">添加文件到暂存区</td></tr><tr><td align="left"><code>git add .</code></td><td align="left">添加所有修改到暂存区</td></tr><tr><td align="left"><code>git commit -m &quot;message&quot;</code></td><td align="left">提交更改到本地仓库</td></tr><tr><td align="left"><code>git commit --amend</code></td><td align="left">修改最后一次提交</td></tr></tbody></table><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a><strong>分支管理</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git branch</code></td><td align="left">查看本地分支</td></tr><tr><td align="left"><code>git branch </code></td><td align="left">创建新分支</td></tr><tr><td align="left"><code>git checkout </code></td><td align="left">切换分支</td></tr><tr><td align="left"><code>git checkout -b </code></td><td align="left">创建并切换分支</td></tr><tr><td align="left"><code>git merge &lt;branch&gt; </code></td><td align="left">合并分支到当前分支</td></tr><tr><td align="left"><code>git branch -d </code></td><td align="left">删除本地分支</td></tr><tr><td align="left"><code>git push origin --delete &lt;branch&gt; </code></td><td align="left">删除远程分支</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a><strong>远程操作</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote -v</code></td><td align="left">查看远程仓库地址</td></tr><tr><td align="left"><code>git pull origin &lt;branch&gt; </code></td><td align="left">拉取远程分支并合并</td></tr><tr><td align="left"><code>git push origin &lt;branch&gt;</code></td><td align="left">推送本地分支到远程</td></tr><tr><td align="left"><code>git fetch --all</code></td><td align="left">获取所有远程更新（不自动合并）</td></tr></tbody></table><h3 id="撤销与回退"><a href="#撤销与回退" class="headerlink" title="撤销与回退"></a><strong>撤销与回退</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git restore &lt;file&gt;</code></td><td align="left">撤销工作区修改</td></tr><tr><td align="left"><code>git restore --staged &lt;file&gt; </code></td><td align="left">撤销暂存区修改</td></tr><tr><td align="left"><code>git reset --hard HEAD^</code></td><td align="left">回退到上一个提交（彻底删除更改）</td></tr><tr><td align="left"><code>git reset --soft HEAD^</code></td><td align="left">回退提交但保留更改到暂存区</td></tr><tr><td align="left"><code>git revert &lt;commit-id&gt; </code></td><td align="left">撤销指定提交（生成新提交）</td></tr></tbody></table><h3 id="日志与对比"><a href="#日志与对比" class="headerlink" title="日志与对比"></a><strong>日志与对比</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看提交历史</td></tr><tr><td align="left"><code>git log --oneline --graph</code></td><td align="left">简洁版提交历史（带分支图）</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">查看工作区与暂存区的差异</td></tr><tr><td align="left"><code>git diff --cached</code></td><td align="left">查看暂存区与仓库的差异</td></tr></tbody></table><h3 id="临时修改用户名和邮箱"><a href="#临时修改用户名和邮箱" class="headerlink" title="临时修改用户名和邮箱"></a><strong>临时修改用户名和邮箱</strong></h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git config user.name &quot;新用户名&quot;</code></td><td align="left">修改用户名</td></tr><tr><td align="left"><code>git config user.email &quot;新邮箱地址&quot;</code></td><td align="left">修改邮箱</td></tr><tr><td align="left"><code>git config user.name</code></td><td align="left">查看用户名</td></tr><tr><td align="left"><code>git config user.email</code></td><td align="left">查看邮箱</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++内存池</title>
      <link href="/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%86%85%E5%AD%98%E6%B1%A0%E9%A1%B9%E7%9B%AE/"/>
      <url>/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%86%85%E5%AD%98%E6%B1%A0%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="内存池介绍"><a href="#内存池介绍" class="headerlink" title="内存池介绍"></a>内存池介绍</h3><h4 id="什么是内存池"><a href="#什么是内存池" class="headerlink" title="什么是内存池"></a>什么是内存池</h4><p><strong>内存池是一种预分配内存并且进行重复利用的技术</strong>，通过减少频繁的动态内存分配与释放操作，从而提高程序的运行效率。内存池通常预先分配一块大的区域，将其划分为多个小块，每次需要分配内存时直接从这块区域分配，而不是调用系统的动态分配函数（如new或者malloc）。简单来说就是申请一块较大的内存块（不够就继续申请），之后将这块内存的管理放在应用层执行，减少系统调用带来的开销。</p><h4 id="为什么要做内存池"><a href="#为什么要做内存池" class="headerlink" title="为什么要做内存池"></a>为什么要做内存池</h4><h5 id="性能优化："><a href="#性能优化：" class="headerlink" title="性能优化："></a>性能优化：</h5><ul><li><p><strong>减少动态内存分配的开销</strong>：系统调用malloc&#x2F;new和free&#x2F;delete涉及复杂的内存管理操作（如内存查找、碎片整理），导致性能较低，而内存池通过预分配和简单的管理逻辑显著提高了分配和释放的效率。</p></li><li><p><strong>避免内存碎片</strong>：动态分配内存会产生内存碎片，尤其在大量小对象频繁分配和释放的场景中，导致的后果就是：当程序长时间运行时，由于所申请的内存块的大小不定，频繁使用时会造成大量的内存碎片从而降低程序和操作系统的性能。内存池通过管理固定大小的内存块，可以有效避免碎片化。</p></li><li><p><strong>降低系统调用频率</strong>：系统级内存分配（如malloc）需要进入内核态，频繁调用会有较高的性能开销。内存池通过减少系统调用频率提高程序效率。</p></li></ul><h5 id="确定性（实时性）："><a href="#确定性（实时性）：" class="headerlink" title="确定性（实时性）："></a>确定性（实时性）：</h5><ul><li><strong>稳定的分配时间</strong>：使用内存池可以使分配和释放操作的耗时更加可控和稳定，适合实时性有严格要求的系统。</li></ul><h4 id="内存池的应用场景："><a href="#内存池的应用场景：" class="headerlink" title="内存池的应用场景："></a>内存池的应用场景：</h4><h5 id="高频小对象分配："><a href="#高频小对象分配：" class="headerlink" title="高频小对象分配："></a>高频小对象分配：</h5><ul><li><p><strong>游戏开发</strong>：游戏中大量小对象（如粒子、子弹、NPC）的动态分配和释放非常频繁，使用内存池可以显著优化性能。</p></li><li><p><strong>网络编程</strong>：网络编程中，大量请求和响应对象（如消息报文）和频繁创建和销毁非常适合使用内存池。</p></li><li><p><strong>内存管理库</strong>：一些容器或数据结构（如std::vector或std::deque）在内部可能使用内存池来优化分配性能。</p></li></ul><h5 id="实时系统："><a href="#实时系统：" class="headerlink" title="实时系统："></a>实时系统：</h5><ul><li>嵌入式设备或实时控制系统中，动态内存分配的延迟可能影响实时性，内存池提供确定性的分配性能。</li></ul><h5 id="高性能计算："><a href="#高性能计算：" class="headerlink" title="高性能计算："></a>高性能计算：</h5><ul><li>在高性能计算程序中，频繁地内存分配和释放会拖累整个程序的性能，内存池可以优化内存管理</li></ul><h5 id="服务器开发："><a href="#服务器开发：" class="headerlink" title="服务器开发："></a>服务器开发：</h5><ul><li>数据库服务器、web服务器等需要管理大量连接和请求，这些连接涉及大量内存分配，内存池能有效提升服务器性能。</li></ul><h4 id="内存池在代码中的应用"><a href="#内存池在代码中的应用" class="headerlink" title="内存池在代码中的应用"></a>内存池在代码中的应用</h4><ul><li><p>对new&#x2F;malloc&#x2F;delete&#x2F;free等动态开辟内存的系统调用进行替换</p></li><li><p>对STL众多容器中的空间配置器std::allocator进行替换</p></li></ul><h4 id="内存池的缺点"><a href="#内存池的缺点" class="headerlink" title="内存池的缺点"></a>内存池的缺点</h4><ul><li><p><strong>初始内存占用</strong>：内存池需要预先分配较大的内存区域，可能浪费一些内存。</p></li><li><p><strong>复杂性</strong>：实现和调试内存池代码比直接使用 malloc &#x2F; new 更复杂。</p></li><li><p><strong>不适合大型对象</strong>：对于大对象的分配可能并不划算。</p></li></ul><h3 id="项目框架"><a href="#项目框架" class="headerlink" title="项目框架"></a>项目框架</h3><p>内存池本质：预先向系统申请一大片内存，并交由应用层管理，在程序运行时，内存的分配和回收都由应用层的内存池处理，从而减少系统调用。</p><p>该项目实现的是基于<strong>哈希映射的多种定长内存分配器（内存池中的一种）</strong>：</p><img src="../img/1.jpg" alt="内存池示意图" style="width: 50%;"><p>主要框架如上图所示，主要是维护一个哈希桶 MemoryPools，里面每项对应一个内存池 MemoryPool，哈希桶中每个内存池的块大小 BlockSize 是相同的（4096字节，可以设置为不同），但是每个内存池里每个块分割的大小（槽大小）SlotSize是不同的，依次为8,16,32,…,512字节（<strong>需要的内存超过512字节就用new&#x2F;malloc</strong>），用户申请不同大小的内存就通过哈希桶的映射找到相应（槽大小）  SlotSize 的内存池向其申请，比如用户分别申请8字节和12字节的内存，则经过哈希函数的计算找到槽大小为8字节的内存池和槽大小为16字节（哈希函数向上取整，因为分配给用户的内存块只能大不能小）的内存池分别分配内存给用户，这样设置的好处是<strong>可以保证内存碎片在可控范围内</strong>。</p><p><strong>为什么用户申请超过512字节的内存就直接调用 new&#x2F;malloc 等系统调用？</strong></p><p><strong>因为内存池主要解决的是 小内存带来的内存碎片问题 和 小内存频繁申请释放带来的性能问题。</strong>（频繁申请小内存带来的问题可参考：<a href="https://blog.csdn.net/LF_2016/article/details/53511648">https://blog.csdn.net/LF_2016/article/details/53511648</a>）</p><p>每个内存池的内部结构图：</p><img src="../img/2.jpg" alt="内存池示意图" style="width: 50%;"><ul><li><strong>Slot currentBlock</strong>：内存池实际上是一个一个的 Block 以链表的形式连接起来，每一个 Block 是一块大的内存，当内存池的内存不足的时候，就会向操作系统申请新的 block 加入链表。</li><li><strong>Slot freeSlot</strong>：链表里面的每一项都是对象被释放后归还给内存池的空间，内存池刚创建时 freeSlot 是空的。用户创建对象，将对象释放时，把内存归还给内存池，此时内存池不会将内存归还给系统（delete&#x2F;free），而是把指向这个对象的内存的指针加到 freeSlot 链表的前面（前插），之后用户每次申请内存时，memoryPool就先在这个 freeSlot 链表里面找。</li><li><strong>Slot curretSlot</strong>：用户在创建对象的时候，先检查 freeSlot 是否为空，不为空的时候直接取出一项作为分配出的空间。否则就在当前 Block 将 currentSlot 所指的内存分配出去，如果 Block 里面的内存已经使用完，就向操作系统申请一个新的 Block。</li></ul><p><strong>整体流程图</strong></p><img src="../img/3.jpg" alt="内存池示意图" style="width: 50%;"><p>该项目对外提供了两个重要的接口newElement和deleteElement，分别是向内存池申请内存和将申请的内存进行回收操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">T* <span class="hljs-title">newElement</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p>用户在构造对象T的时候通过调用newElement<T>()方法申请内存，newElement<T>()方法计算出元素T的大小后传入哈希桶中，哈希桶中根据哈希映射选择相应槽大小的内存池去分配内存返回（分配内存时优先使用FreeList_里的空闲内存槽，其次再找curSlot_，如果curSlot_大于等于lastSot_，则重新申请一块内存块来分配内存槽），newElement函数获得内存之后，在该内存上构造对象T后将地址返回给用户。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteElement</span><span class="hljs-params">(T* p)</span></span>;<br></code></pre></td></tr></table></figure><p>当用户想要释放对象时可调用deleteElement函数，该方法首先调用对象T的析构函数，其次同样经过哈希映射找到相应的内存池去把内存槽加入到FreeList_中。</p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用C++实现终端版俄罗斯方块：从零开始的游戏开发指南</title>
      <link href="/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/"/>
      <url>/2025/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="用C-实现终端版俄罗斯方块：从零开始的游戏开发指南"><a href="#用C-实现终端版俄罗斯方块：从零开始的游戏开发指南" class="headerlink" title="用C++实现终端版俄罗斯方块：从零开始的游戏开发指南"></a>用C++实现终端版俄罗斯方块：从零开始的游戏开发指南</h3><h4 id="引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C-控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。"><a href="#引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C-控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。" class="headerlink" title="引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C++控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。"></a>引言俄罗斯方块作为经典游戏，其简洁的规则和丰富的策略性一直吸引着开发者尝试用各种语言实现。本文将基于一个C++控制台俄罗斯方块项目，解析核心实现逻辑和关键编程技巧。</h4><p>观看视频讲解：<a href="https://www.bilibili.com/video/BV1a94y1Y7Jw">C++俄罗斯方块实现教程</a></p><h4 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h4><h5 id="1-方块表示与旋转"><a href="#1-方块表示与旋转" class="headerlink" title="1. 方块表示与旋转"></a>1. 方块表示与旋转</h5><ul><li>采用4x4字符矩阵表示方块，通过旋转算法实现多角度变换：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模拟俄罗斯方块的旋转</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> px, <span class="hljs-type">int</span> py, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">switch</span> (r % <span class="hljs-number">4</span>)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> py * <span class="hljs-number">4</span> + px;         <span class="hljs-comment">//0 degress</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">12</span> + py - (px * <span class="hljs-number">4</span>);<span class="hljs-comment">//90 degress</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">15</span> - (py * <span class="hljs-number">4</span>) - px;<span class="hljs-comment">//180 degress</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">3</span> - py + (px * <span class="hljs-number">4</span>);     <span class="hljs-comment">//270 degress</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-碰撞检测"><a href="#2-碰撞检测" class="headerlink" title="2. 碰撞检测"></a>2. 碰撞检测</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DoesPieceFit</span><span class="hljs-params">(<span class="hljs-type">int</span> nTetromino, <span class="hljs-type">int</span> nRotation, <span class="hljs-type">int</span> nPosX, <span class="hljs-type">int</span> nPosY)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// All Field cells &gt;0 are occupied</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">0</span>; px &lt; <span class="hljs-number">4</span>; px++)<span class="hljs-comment">// 循环遍历方块的水平位置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<span class="hljs-comment">// 循环遍历方块的垂直位置</span><br>&#123;<br><span class="hljs-comment">// Get index into piece</span><br><span class="hljs-comment">// 获取方块内部位置的索引</span><br><span class="hljs-type">int</span> pi = <span class="hljs-built_in">Rotate</span>(px, py, nRotation);<br><br><span class="hljs-comment">// Get index into field</span><br><span class="hljs-comment">// 获取方块在游戏区域中的索引</span><br><span class="hljs-type">int</span> fi = (nPosY + py) * nFieldWidth + (nPosX + px);<br><br><span class="hljs-comment">// Check that test is in bounds. Note out of bounds does</span><br><span class="hljs-comment">// not necessarily mean a fail, as the long vertical piece</span><br><span class="hljs-comment">// can have cells that lie outside the boundary, so we&#x27;ll</span><br><span class="hljs-comment">// just ignore them</span><br><span class="hljs-keyword">if</span> (nPosX + px &gt;= <span class="hljs-number">0</span> &amp;&amp; nPosX + px &lt; nFieldWidth)<span class="hljs-comment">// 检查方块是否在横向范围内</span><br>&#123;<br><span class="hljs-keyword">if</span> (nPosY + py &gt;= <span class="hljs-number">0</span> &amp;&amp; nPosY + py &lt; nFieldHeight)<span class="hljs-comment">// 检查方块是否在纵向范围内</span><br>&#123;<br><span class="hljs-comment">// In Bounds so do collision check</span><br><span class="hljs-keyword">if</span> (tetromino[nTetromino][pi] != <span class="hljs-string">L&#x27;.&#x27;</span> &amp;&amp; pField[fi] != <span class="hljs-number">0</span>)<span class="hljs-comment">// 检查方块和游戏区域是否有重叠</span><br><span class="hljs-comment">// 第一个碰撞就返回失败</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// fail on first hit</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 方块适合放置在指定位置</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-方块定义"><a href="#3-方块定义" class="headerlink" title="3. 方块定义"></a>3. 方块定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++">tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">0</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br><br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br>tetromino[<span class="hljs-number">1</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">2</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">3</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">4</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br><br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br>tetromino[<span class="hljs-number">5</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;..X.&quot;</span>);<br><br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;....&quot;</span>);<br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.XX.&quot;</span>);<br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br>tetromino[<span class="hljs-number">6</span>].<span class="hljs-built_in">append</span>(<span class="hljs-string">L&quot;.X..&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="4-游戏主循环"><a href="#4-游戏主循环" class="headerlink" title="4. 游戏主循环"></a>4. 游戏主循环</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (!bGameOver)<br>&#123;<br><span class="hljs-comment">//GAME TIMING =======================================</span><br>this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">50</span>ms);<br>nSpeedCounter++;<br>bForceDown = (nSpeedCounter == nSpeed);<br><br><span class="hljs-comment">//INPUT =============================================</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++)<span class="hljs-comment">// R   L   D Z</span><br><span class="hljs-comment">// 判断了指定键码对应的按键是否处于按下状态。如果按键被按下，则结果为真，否则为假。</span><br>bKey[k] = (<span class="hljs-number">0x8000</span> &amp; <span class="hljs-built_in">GetAsyncKeyState</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(<span class="hljs-string">&quot;\x27\x25\x28Z&quot;</span>[k]))) != <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//GAME LOGIC ========================================</span><br><span class="hljs-comment">// Handle player movement</span><br><span class="hljs-comment">// 处理玩家的移动</span><br><span class="hljs-comment">// 按下右键 right</span><br>nCurrentX += (bKey[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX + <span class="hljs-number">1</span>, nCurrentY)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 按下左键 left</span><br>nCurrentX -= (bKey[<span class="hljs-number">1</span>] &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX - <span class="hljs-number">1</span>, nCurrentY)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 按下下键 down</span><br>nCurrentY += (bKey[<span class="hljs-number">2</span>] &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX, nCurrentY + <span class="hljs-number">1</span>)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 按下Z键，旋转</span><br><span class="hljs-keyword">if</span> (bKey[<span class="hljs-number">3</span>])<span class="hljs-comment">// 按下Z键</span><br>&#123;<br>nCurrentRotation += (bRotateHold &amp;&amp; <span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation + <span class="hljs-number">1</span>, nCurrentX, nCurrentY)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>bRotateHold = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>bRotateHold = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 无法连续旋转</span><br><br><span class="hljs-keyword">if</span> (bForceDown)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX, nCurrentY + <span class="hljs-number">1</span>))<br>nCurrentY++;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// Lock the current in the field</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">0</span>; px &lt; <span class="hljs-number">4</span>; px++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<br><span class="hljs-keyword">if</span> (tetromino[nCurrentPiece][<span class="hljs-built_in">Rotate</span>(px, py, nCurrentRotation)] == <span class="hljs-string">L&#x27;X&#x27;</span>)<br>pField[(nCurrentY + py) * nFieldWidth + (nCurrentX + px)] = nCurrentPiece + <span class="hljs-number">1</span>;<br><br>nPieceCount++;<br><span class="hljs-keyword">if</span> (nPieceCount % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> (nSpeed &gt;= <span class="hljs-number">10</span>) nSpeed--;<br><br><br><span class="hljs-comment">// Check have we got any lines</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<br><span class="hljs-keyword">if</span> (nCurrentY + py &lt; nFieldHeight - <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-type">bool</span> bLine = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">1</span>; px &lt; nFieldWidth - <span class="hljs-number">1</span>; px++)<br>bLine &amp;= (pField[(nCurrentY + py) * nFieldWidth + px]) != <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (bLine)<br>&#123;<br><span class="hljs-comment">// Remove Line, set to = </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">1</span>; px &lt; nFieldWidth - <span class="hljs-number">1</span>; px++)<br>pField[(nCurrentY + py) * nFieldWidth + px] = <span class="hljs-number">8</span>; <br><br>vLines.<span class="hljs-built_in">push_back</span>(nCurrentY + py);<br>&#125;<br>&#125;<br>nScore += <span class="hljs-number">50</span>;<br><span class="hljs-keyword">if</span> (!vLines.<span class="hljs-built_in">empty</span>()) nScore += (<span class="hljs-number">1</span> &lt;&lt; vLines.<span class="hljs-built_in">size</span>()) * <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">// Choose next piece</span><br>nCurrentX = nFieldWidth / <span class="hljs-number">2</span>;<br>nCurrentY = <span class="hljs-number">0</span>;<br>nCurrentRotation = <span class="hljs-number">0</span>;<br>nCurrentPiece = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">7</span>;<br><br>bGameOver = !<span class="hljs-built_in">DoesPieceFit</span>(nCurrentPiece, nCurrentRotation, nCurrentX, nCurrentY);<br>&#125;<br>nSpeedCounter = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//RENDER OUTPUT =====================================</span><br><br><br><br><span class="hljs-comment">// Draw Field</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; nFieldWidth; x++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; nFieldHeight; y++)<br>screen[(y + <span class="hljs-number">2</span>) * nScreenWidth + (x + <span class="hljs-number">2</span>)] = <span class="hljs-string">L&quot; ABCDEFG=#&quot;</span>[pField[y * nFieldWidth + x]];<br><br><span class="hljs-comment">// Draw Current piece</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">0</span>; px &lt; <span class="hljs-number">4</span>; px++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = <span class="hljs-number">0</span>; py &lt; <span class="hljs-number">4</span>; py++)<br><span class="hljs-keyword">if</span> (tetromino[nCurrentPiece][<span class="hljs-built_in">Rotate</span>(px, py, nCurrentRotation)] == <span class="hljs-string">L&#x27;X&#x27;</span>)<br>screen[(nCurrentY + py + <span class="hljs-number">2</span>) * nScreenWidth + (nCurrentX + px + <span class="hljs-number">2</span>)] = nCurrentPiece + <span class="hljs-number">65</span>;<br><br><span class="hljs-comment">// Draw Score</span><br><span class="hljs-built_in">swprintf_s</span>(&amp;screen[<span class="hljs-number">2</span> * nScreenWidth + nFieldWidth + <span class="hljs-number">6</span>], <span class="hljs-number">16</span>, <span class="hljs-string">L&quot;SCORE: %8d&quot;</span>, nScore);<br><br><span class="hljs-keyword">if</span> (!vLines.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-comment">// Display Frame (cheekily to dray lines</span><br><span class="hljs-built_in">WriteConsoleOutputCharacter</span>(hConsole, screen, nScreenWidth * nScreenHeight, &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;, &amp;dwBytesWritten);<br>this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">400</span>ms);  <span class="hljs-comment">//Delay a bit</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; v : vLines)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> px = <span class="hljs-number">1</span>; px &lt; nFieldWidth - <span class="hljs-number">1</span>; px++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> py = v; py &gt; <span class="hljs-number">0</span>; py--)<br>pField[py * nFieldWidth + px] = pField[(py - <span class="hljs-number">1</span>) * nFieldWidth + px];<br>pField[px] = <span class="hljs-number">0</span>;<br>&#125;<br>vLines.<span class="hljs-built_in">clear</span>();<br>&#125;<br><br><span class="hljs-comment">//Display Frame</span><br><span class="hljs-built_in">WriteConsoleOutputCharacter</span>(hConsole, screen, nScreenWidth * nScreenHeight, &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span> &#125;, &amp;dwBytesWritten);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><a href="https://github.com/hwl111/hwl111.github.io/blob/main/code/tetris.cpp">在线查看代码</a></li><li><a href="https://github.com/hwl111/hwl111.github.io/raw/main/code/tetris.cpp">直接下载代码</a></li></ul><p>通过这个项目，我们不仅实现了经典游戏，还掌握了：</p><ul><li>二维游戏逻辑开发</li><li>控制台图形渲染</li><li>实时输入处理</li><li>状态管理技巧</li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法时间复杂度与空间复杂度详解</title>
      <link href="/2025/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2025/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="算法时间复杂度与空间复杂度"><a href="#算法时间复杂度与空间复杂度" class="headerlink" title="算法时间复杂度与空间复杂度"></a>算法时间复杂度与空间复杂度</h3><h4 id="什么是算法复杂度"><a href="#什么是算法复杂度" class="headerlink" title="什么是算法复杂度"></a>什么是算法复杂度</h4><p>算法复杂度是衡量算法效率的重要指标，主要包括：</p><ul><li><strong>时间复杂度</strong>：算法执行所需的时间量级</li><li><strong>空间复杂度</strong>：算法执行所需的内存空间量级</li></ul><p>复杂度作用：</p><ol><li>比较不同算法的效率</li><li>预测算法在不同规模数据下的表现</li><li>优化程序性能</li></ol><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><h5 id="1-大O表示法"><a href="#1-大O表示法" class="headerlink" title="1. 大O表示法"></a>1. 大O表示法</h5><p>大O表示法（Big-O Notation）描述了算法在最坏情况下的增长趋势：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        std::cout&lt;&lt;i;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子的时间复杂度就是O(n)</p><h5 id="2-常见时间复杂度对比"><a href="#2-常见时间复杂度对比" class="headerlink" title="2. 常见时间复杂度对比"></a>2. 常见时间复杂度对比</h5><table><thead><tr><th align="left">复杂度</th><th align="left">名称</th><th align="left">示例</th><th align="left">n&#x3D;100时的操作次数</th></tr></thead><tbody><tr><td align="left">O(1)</td><td align="left">常数时间</td><td align="left">哈希表查找</td><td align="left">1</td></tr><tr><td align="left">O(log n)</td><td align="left">对数时间</td><td align="left">二分查找</td><td align="left">~7</td></tr><tr><td align="left">O(n)</td><td align="left">线性时间</td><td align="left">遍历数组</td><td align="left">100</td></tr><tr><td align="left">O(n log n)</td><td align="left">线性对数时间</td><td align="left">快速排序</td><td align="left">~664</td></tr><tr><td align="left">O(n²)</td><td align="left">平方时间</td><td align="left">冒泡排序</td><td align="left">10,000</td></tr><tr><td align="left">O(2ⁿ)</td><td align="left">指数时间</td><td align="left">穷举算法</td><td align="left">1.26e+30</td></tr></tbody></table><h5 id="3-计算规则"><a href="#3-计算规则" class="headerlink" title="3. 计算规则"></a>3. 计算规则</h5><ul><li><strong>加法规则</strong>：T(n) &#x3D; T1(n) + T2(n) → O(max(f(n), g(n)))</li><li><strong>乘法规则</strong>：T(n) &#x3D; T1(n) * T2(n) → O(f(n) * g(n))</li></ul><h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><h5 id="1-计算方法"><a href="#1-计算方法" class="headerlink" title="1. 计算方法"></a>1. 计算方法</h5><p>计算算法运行过程中<strong>额外</strong>占用的存储空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># O(n)空间复杂度示例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_array</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>] * n  <span class="hljs-comment"># 需要分配n个元素的存储空间</span><br></code></pre></td></tr></table></figure><h5 id="2-常见空间复杂度"><a href="#2-常见空间复杂度" class="headerlink" title="2. 常见空间复杂度"></a>2. 常见空间复杂度</h5><table><thead><tr><th align="left">复杂度</th><th align="left">说明</th><th align="left">典型算法</th></tr></thead><tbody><tr><td align="left">O(1)</td><td align="left">固定大小的额外空间</td><td align="left">迭代算法</td></tr><tr><td align="left">O(n)</td><td align="left">与输入规模线性相关</td><td align="left">归并排序</td></tr><tr><td align="left">O(n²)</td><td align="left">二维数据结构</td><td align="left">邻接矩阵存储图</td></tr></tbody></table><h4 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 递归实现（时间复杂度O(2ⁿ)，空间复杂度O(n)）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_recursive</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> n<br>    <span class="hljs-keyword">return</span> fib_recursive(n-<span class="hljs-number">1</span>) + fib_recursive(n-<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 迭代实现（时间复杂度O(n)，空间复杂度O(1)）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_iterative</span>(<span class="hljs-params">n</span>):<br>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        a, b = b, a + b<br>    <span class="hljs-keyword">return</span> a<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间复杂度 </tag>
            
            <tag> 空间复杂度 </tag>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树与图的进阶算法与工程实践</title>
      <link href="/2024/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="树与图的进阶算法与工程实践"><a href="#树与图的进阶算法与工程实践" class="headerlink" title="树与图的进阶算法与工程实践"></a>树与图的进阶算法与工程实践</h1><p>树和图是非线性数据结构的核心，广泛应用于算法竞赛、工程开发和系统设计。本文将深入探讨树与图的高阶算法与实际工程中的应用。</p><h2 id="1-树的高阶遍历与应用"><a href="#1-树的高阶遍历与应用" class="headerlink" title="1. 树的高阶遍历与应用"></a>1. 树的高阶遍历与应用</h2><h3 id="1-1-Morris-遍历"><a href="#1-1-Morris-遍历" class="headerlink" title="1.1 Morris 遍历"></a>1.1 Morris 遍历</h3><ul><li>利用线索化思想实现 O(1) 空间的中序遍历。</li><li>适合内存受限场景。</li></ul><h3 id="1-2-线段树与树状数组"><a href="#1-2-线段树与树状数组" class="headerlink" title="1.2 线段树与树状数组"></a>1.2 线段树与树状数组</h3><ul><li>支持区间查询与修改，常用于竞赛和数据库索引。</li><li>线段树适合动态区间，树状数组适合前缀和。</li></ul><h3 id="1-3-平衡树（AVL、红黑树、Treap）"><a href="#1-3-平衡树（AVL、红黑树、Treap）" class="headerlink" title="1.3 平衡树（AVL、红黑树、Treap）"></a>1.3 平衡树（AVL、红黑树、Treap）</h3><ul><li>保证插入、删除、查找 O(log n) 时间复杂度。</li><li>应用：STL map&#x2F;set、数据库索引、操作系统调度。</li></ul><h2 id="2-图的高阶搜索与工程实践"><a href="#2-图的高阶搜索与工程实践" class="headerlink" title="2. 图的高阶搜索与工程实践"></a>2. 图的高阶搜索与工程实践</h2><h3 id="2-1-拓扑排序"><a href="#2-1-拓扑排序" class="headerlink" title="2.1 拓扑排序"></a>2.1 拓扑排序</h3><ul><li>DAG 上的线性排序，常用于任务调度、编译依赖。</li></ul><h3 id="2-2-最短路算法"><a href="#2-2-最短路算法" class="headerlink" title="2.2 最短路算法"></a>2.2 最短路算法</h3><ul><li>Dijkstra、SPFA、A*，工程中常用于地图导航、网络路由。</li></ul><h3 id="2-3-最小生成树"><a href="#2-3-最小生成树" class="headerlink" title="2.3 最小生成树"></a>2.3 最小生成树</h3><ul><li>Kruskal、Prim 算法，应用于网络设计、聚类分析。</li></ul><h3 id="2-4-强连通分量与割点"><a href="#2-4-强连通分量与割点" class="headerlink" title="2.4 强连通分量与割点"></a>2.4 强连通分量与割点</h3><ul><li>Tarjan 算法，适合社交网络、依赖分析。</li></ul><h2 id="3-工程中的树与图优化"><a href="#3-工程中的树与图优化" class="headerlink" title="3. 工程中的树与图优化"></a>3. 工程中的树与图优化</h2><h3 id="3-1-压缩存储"><a href="#3-1-压缩存储" class="headerlink" title="3.1 压缩存储"></a>3.1 压缩存储</h3><ul><li>邻接表、邻接矩阵、稀疏图压缩，节省内存。</li></ul><h3 id="3-2-并查集与路径压缩"><a href="#3-2-并查集与路径压缩" class="headerlink" title="3.2 并查集与路径压缩"></a>3.2 并查集与路径压缩</h3><ul><li>动态连通性判定，常用于社交网络、网络连通。</li></ul><h3 id="3-3-并行与分布式图计算"><a href="#3-3-并行与分布式图计算" class="headerlink" title="3.3 并行与分布式图计算"></a>3.3 并行与分布式图计算</h3><ul><li>大规模图处理采用分布式框架（如 Pregel、GraphX）。</li></ul><h2 id="4-代码示例：Tarjan-算法求强连通分量（Python）"><a href="#4-代码示例：Tarjan-算法求强连通分量（Python）" class="headerlink" title="4. 代码示例：Tarjan 算法求强连通分量（Python）"></a>4. 代码示例：Tarjan 算法求强连通分量（Python）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tarjan</span>(<span class="hljs-params">graph</span>):<br>    n = <span class="hljs-built_in">len</span>(graph)<br>    index = <span class="hljs-number">0</span><br>    indices = [-<span class="hljs-number">1</span>] * n<br>    lowlink = [-<span class="hljs-number">1</span>] * n<br>    stack = []<br>    onStack = [<span class="hljs-literal">False</span>] * n<br>    sccs = []<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strongconnect</span>(<span class="hljs-params">v</span>):<br>        <span class="hljs-keyword">nonlocal</span> index<br>        indices[v] = lowlink[v] = index<br>        index += <span class="hljs-number">1</span><br>        stack.append(v)<br>        onStack[v] = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> graph[v]:<br>            <span class="hljs-keyword">if</span> indices[w] == -<span class="hljs-number">1</span>:<br>                strongconnect(w)<br>                lowlink[v] = <span class="hljs-built_in">min</span>(lowlink[v], lowlink[w])<br>            <span class="hljs-keyword">elif</span> onStack[w]:<br>                lowlink[v] = <span class="hljs-built_in">min</span>(lowlink[v], indices[w])<br>        <span class="hljs-keyword">if</span> lowlink[v] == indices[v]:<br>            scc = []<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                w = stack.pop()<br>                onStack[w] = <span class="hljs-literal">False</span><br>                scc.append(w)<br>                <span class="hljs-keyword">if</span> w == v:<br>                    <span class="hljs-keyword">break</span><br>            sccs.append(scc)<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> indices[v] == -<span class="hljs-number">1</span>:<br>            strongconnect(v)<br>    <span class="hljs-keyword">return</span> sccs<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>树与图的进阶算法是算法工程师和系统架构师的必备技能。建议结合实际项目和算法题深入理解其原理与优化手段。  </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 图 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表的高阶应用与优化</title>
      <link href="/2024/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E9%AB%98%E9%98%B6%E5%BA%94%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2024/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E7%9A%84%E9%AB%98%E9%98%B6%E5%BA%94%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="链表的高阶应用与优化"><a href="#链表的高阶应用与优化" class="headerlink" title="链表的高阶应用与优化"></a>链表的高阶应用与优化</h1><p>链表作为基础数据结构，在实际工程和算法面试中有着丰富的变种和高阶用法。本文将深入探讨链表的进阶应用、常见优化手段以及面试中的高频考点。</p><h2 id="1-链表的变种"><a href="#1-链表的变种" class="headerlink" title="1. 链表的变种"></a>1. 链表的变种</h2><h3 id="1-1-双向链表"><a href="#1-1-双向链表" class="headerlink" title="1.1 双向链表"></a>1.1 双向链表</h3><ul><li>每个节点有 prev 和 next 指针，支持 O(1) 时间复杂度的前后遍历和删除。</li><li>应用：LRU 缓存淘汰、操作系统任务调度。</li></ul><h3 id="1-2-循环链表"><a href="#1-2-循环链表" class="headerlink" title="1.2 循环链表"></a>1.2 循环链表</h3><ul><li>尾节点指向头节点，适合需要循环遍历的场景。</li><li>应用：约瑟夫环问题、循环队列。</li></ul><h3 id="1-3-跳表（Skip-List）"><a href="#1-3-跳表（Skip-List）" class="headerlink" title="1.3 跳表（Skip List）"></a>1.3 跳表（Skip List）</h3><ul><li>多级链表结构，提升查找效率，接近 O(log n)。</li><li>应用：Redis 有序集合、内存数据库索引。</li></ul><h2 id="2-工程中的链表优化"><a href="#2-工程中的链表优化" class="headerlink" title="2. 工程中的链表优化"></a>2. 工程中的链表优化</h2><h3 id="2-1-内存池与对象复用"><a href="#2-1-内存池与对象复用" class="headerlink" title="2.1 内存池与对象复用"></a>2.1 内存池与对象复用</h3><ul><li>频繁创建&#x2F;销毁节点时，采用内存池减少 GC 压力。</li><li>C++ STL 的 list、Java 的 LinkedBlockingQueue 都有对象池优化。</li></ul><h3 id="2-2-节点缓存与预分配"><a href="#2-2-节点缓存与预分配" class="headerlink" title="2.2 节点缓存与预分配"></a>2.2 节点缓存与预分配</h3><ul><li>批量分配节点，减少内存碎片。</li><li>适合高性能场景，如网络包缓冲区。</li></ul><h3 id="2-3-空间局部性优化"><a href="#2-3-空间局部性优化" class="headerlink" title="2.3 空间局部性优化"></a>2.3 空间局部性优化</h3><ul><li>数组模拟链表（如 LeetCode 707），提升缓存命中率。</li></ul><h2 id="3-复杂操作与面试技巧"><a href="#3-复杂操作与面试技巧" class="headerlink" title="3. 复杂操作与面试技巧"></a>3. 复杂操作与面试技巧</h2><h3 id="3-1-链表反转"><a href="#3-1-链表反转" class="headerlink" title="3.1 链表反转"></a>3.1 链表反转</h3><ul><li>递归与迭代两种写法，考察指针操作能力。</li></ul><h3 id="3-2-K-个一组反转链表"><a href="#3-2-K-个一组反转链表" class="headerlink" title="3.2 K 个一组反转链表"></a>3.2 K 个一组反转链表</h3><ul><li>典型分段处理，需掌握 dummy 节点和分组指针移动。</li></ul><h3 id="3-3-链表环检测"><a href="#3-3-链表环检测" class="headerlink" title="3.3 链表环检测"></a>3.3 链表环检测</h3><ul><li>快慢指针法（Floyd 判圈算法），空间 O(1)。</li></ul><h3 id="3-4-链表排序"><a href="#3-4-链表排序" class="headerlink" title="3.4 链表排序"></a>3.4 链表排序</h3><ul><li>归并排序适合链表，时间 O(n log n)，空间 O(1)。</li></ul><h3 id="3-5-LRU-缓存设计"><a href="#3-5-LRU-缓存设计" class="headerlink" title="3.5 LRU 缓存设计"></a>3.5 LRU 缓存设计</h3><ul><li>双向链表 + 哈希表，O(1) 插入、删除、查找。</li></ul><h2 id="4-代码示例：K-个一组反转链表（Python）"><a href="#4-代码示例：K-个一组反转链表（Python）" class="headerlink" title="4. 代码示例：K 个一组反转链表（Python）"></a>4. 代码示例：K 个一组反转链表（Python）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseKGroup</span>(<span class="hljs-params">head, k</span>):<br>    dummy = ListNode(<span class="hljs-number">0</span>)<br>    dummy.<span class="hljs-built_in">next</span> = head<br>    pre = dummy<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        tail = pre<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            tail = tail.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tail:<br>                <span class="hljs-keyword">return</span> dummy.<span class="hljs-built_in">next</span><br>        nex = tail.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 反转 k 个节点</span><br>        prev, curr = tail.<span class="hljs-built_in">next</span>, pre.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>            tmp = curr.<span class="hljs-built_in">next</span><br>            curr.<span class="hljs-built_in">next</span> = prev<br>            prev = curr<br>            curr = tmp<br>        tmp = pre.<span class="hljs-built_in">next</span><br>        pre.<span class="hljs-built_in">next</span> = tail<br>        pre = tmp<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>链表的高阶应用不仅考察基础，更考察对工程优化和复杂场景的理解。建议多刷题、多总结，提升链表相关的代码能力和思维深度。 </p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语法详解</title>
      <link href="/2024/06/%E7%AC%94%E8%AE%B0/C++%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/%E7%AC%94%E8%AE%B0/C++%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="C-语法详解"><a href="#C-语法详解" class="headerlink" title="C++语法详解"></a>C++语法详解</h1><p>本文系统梳理 C++ 常用语法，涵盖基础语法、面向对象、模板、STL、内存管理等，适合进阶学习与查阅。</p><h2 id="1-基础语法与数据类型"><a href="#1-基础语法与数据类型" class="headerlink" title="1. 基础语法与数据类型"></a>1. 基础语法与数据类型</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><ul><li>整型：<code>int</code>, <code>short</code>, <code>long</code>, <code>long long</code>, <code>unsigned</code></li><li>浮点型：<code>float</code>, <code>double</code>, <code>long double</code></li><li>字符型：<code>char</code>, <code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code></li><li>布尔型：<code>bool</code></li><li>字符串：<code>string</code>（需 <code>#include &lt;string&gt;</code>）</li></ul><h3 id="常量与宏"><a href="#常量与宏" class="headerlink" title="常量与宏"></a>常量与宏</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.14159</span><br></code></pre></td></tr></table></figure><h2 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2. 流程控制"></a>2. 流程控制</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == b) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;&#125;<br><span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;&#125;<br><span class="hljs-keyword">do</span> &#123; ... &#125; <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span> (op) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: ...; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: ...; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: ...;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h2><h3 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="默认参数与函数重载"><a href="#默认参数与函数重载" class="headerlink" title="默认参数与函数重载"></a>默认参数与函数重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="内联函数与递归"><a href="#内联函数与递归" class="headerlink" title="内联函数与递归"></a>内联函数与递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> x * x; &#125;<br></code></pre></td></tr></table></figure><h2 id="4-指针与引用"><a href="#4-指针与引用" class="headerlink" title="4. 指针与引用"></a>4. 指针与引用</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* p = &amp;a;<br>*p = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> b = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span>&amp; ref = b;<br>ref = <span class="hljs-number">8</span>;<br></code></pre></td></tr></table></figure><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span>* p = arr;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) cout &lt;&lt; *(p + i);<br></code></pre></td></tr></table></figure><h2 id="5-类与对象"><a href="#5-类与对象" class="headerlink" title="5. 类与对象"></a>5. 类与对象</h2><h3 id="类定义与成员"><a href="#类定义与成员" class="headerlink" title="类定义与成员"></a>类定义与成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Hello, I am &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;构造&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;析构&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="this-指针与静态成员"><a href="#this-指针与静态成员" class="headerlink" title="this 指针与静态成员"></a>this 指针与静态成员</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-built_in">Counter</span>() &#123; ++count; &#125;<br>&#125;;<br><span class="hljs-type">int</span> Counter::count = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="6-继承与多态"><a href="#6-继承与多态" class="headerlink" title="6. 继承与多态"></a>6. 继承与多态</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Animal&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Dog&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="多态与虚函数"><a href="#多态与虚函数" class="headerlink" title="多态与虚函数"></a>多态与虚函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Animal* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>();<br>p-&gt;<span class="hljs-built_in">speak</span>(); <span class="hljs-comment">// 输出 Dog</span><br></code></pre></td></tr></table></figure><h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="7-模板"><a href="#7-模板" class="headerlink" title="7. 模板"></a>7. 模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br></code></pre></td></tr></table></figure><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123;<br>    T value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Box</span>(T v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;<br>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="8-STL（标准模板库）"><a href="#8-STL（标准模板库）" class="headerlink" title="8. STL（标准模板库）"></a>8. STL（标准模板库）</h2><h3 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>map&lt;string, <span class="hljs-type">int</span>&gt; m;<br>set&lt;<span class="hljs-type">int</span>&gt; s;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>stack&lt;<span class="hljs-type">int</span>&gt; st;<br></code></pre></td></tr></table></figure><h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">reverse</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">find</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="9-内存管理"><a href="#9-内存管理" class="headerlink" title="9. 内存管理"></a>9. 内存管理</h2><h3 id="new-delete"><a href="#new-delete" class="headerlink" title="new&#x2F;delete"></a>new&#x2F;delete</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br><span class="hljs-keyword">delete</span>[] arr;<br></code></pre></td></tr></table></figure><h3 id="智能指针（C-11）"><a href="#智能指针（C-11）" class="headerlink" title="智能指针（C++11）"></a>智能指针（C++11）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">5</span>))</span></span>;<br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; sp = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="10-异常处理"><a href="#10-异常处理" class="headerlink" title="10. 异常处理"></a>10. 异常处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125; <span class="hljs-built_in">catch</span> (exception&amp; e) &#123;<br>    cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-其他常用语法与技巧"><a href="#11-其他常用语法与技巧" class="headerlink" title="11. 其他常用语法与技巧"></a>11. 其他常用语法与技巧</h2><ul><li>命名空间：<code>namespace myns &#123; ... &#125;</code></li><li>auto 关键字（类型自动推断，C++11）：<code>auto x = 10;</code></li><li>range-based for（C++11）：<code>for (auto x : v) &#123; ... &#125;</code></li><li>lambda 表达式（C++11）：<code>auto f = [](int x)&#123; return x*x; &#125;;</code></li><li>constexpr 常量表达式（C++11）：<code>constexpr int sq(int x) &#123; return x*x; &#125;</code></li><li>枚举类型：<code>enum Color &#123; RED, GREEN, BLUE &#125;;</code></li></ul><hr><p>如需更深入的专题（如C++11&#x2F;14&#x2F;17新特性、并发、模板元编程等），欢迎留言补充！ </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程 </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务与隔离级别详解</title>
      <link href="/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL事务与隔离级别详解"><a href="#MySQL事务与隔离级别详解" class="headerlink" title="MySQL事务与隔离级别详解"></a>MySQL事务与隔离级别详解</h1><p>事务是数据库可靠性的基础。本文详细解析 MySQL 事务的 ACID 特性、隔离级别、并发问题与 InnoDB 实现原理。</p><h2 id="1-事务的-ACID-特性"><a href="#1-事务的-ACID-特性" class="headerlink" title="1. 事务的 ACID 特性"></a>1. 事务的 ACID 特性</h2><ul><li><strong>原子性（Atomicity）</strong>：事务不可分割，要么全部成功要么全部失败。</li><li><strong>一致性（Consistency）</strong>：事务前后数据完整性不被破坏。</li><li><strong>隔离性（Isolation）</strong>：并发事务互不干扰。</li><li><strong>持久性（Durability）</strong>：事务提交后数据永久保存。</li></ul><h2 id="2-四大隔离级别"><a href="#2-四大隔离级别" class="headerlink" title="2. 四大隔离级别"></a>2. 四大隔离级别</h2><ul><li><strong>Read Uncommitted（读未提交）</strong>：最低，可能脏读。</li><li><strong>Read Committed（读已提交）</strong>：Oracle 默认，防止脏读，可能不可重复读。</li><li><strong>Repeatable Read（可重复读）</strong>：MySQL 默认，防止脏读和不可重复读，可能幻读。</li><li><strong>Serializable（可串行化）</strong>：最高，完全串行，性能最低。</li></ul><h2 id="3-并发问题"><a href="#3-并发问题" class="headerlink" title="3. 并发问题"></a>3. 并发问题</h2><ul><li><strong>脏读</strong>：读到未提交事务的数据。</li><li><strong>不可重复读</strong>：同一事务两次读取同一数据结果不同。</li><li><strong>幻读</strong>：同一事务两次查询，第二次多了&#x2F;少了行。</li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read Committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="4-InnoDB-实现原理"><a href="#4-InnoDB-实现原理" class="headerlink" title="4. InnoDB 实现原理"></a>4. InnoDB 实现原理</h2><ul><li><strong>MVCC（多版本并发控制）</strong>：通过隐藏字段和 undo log 实现快照读，提升并发性能。</li><li><strong>行锁与间隙锁</strong>：防止幻读，保证隔离性。</li><li><strong>意向锁</strong>：加速表级锁与行级锁兼容判断。</li></ul><h2 id="5-事务相关SQL"><a href="#5-事务相关SQL" class="headerlink" title="5. 事务相关SQL"></a>5. 事务相关SQL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br><br><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br></code></pre></td></tr></table></figure><h2 id="6-常见面试题"><a href="#6-常见面试题" class="headerlink" title="6. 常见面试题"></a>6. 常见面试题</h2><ul><li>MySQL 默认隔离级别？如何防止幻读？</li><li>MVCC 的原理？快照读和当前读的区别？</li><li>行锁、间隙锁、意向锁的区别？</li><li>事务的四大特性？</li></ul><hr><p>理解事务与隔离级别是保障数据一致性和高并发性能的关键。 </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
            <tag> 隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL查询优化与执行计划分析</title>
      <link href="/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90/"/>
      <url>/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL查询优化与执行计划分析"><a href="#MySQL查询优化与执行计划分析" class="headerlink" title="MySQL查询优化与执行计划分析"></a>MySQL查询优化与执行计划分析</h1><p>高效的 SQL 查询是数据库性能的保障。本文系统梳理 MySQL 查询优化方法、EXPLAIN 执行计划分析、慢查询定位与常见反模式。</p><h2 id="1-SQL-优化思路"><a href="#1-SQL-优化思路" class="headerlink" title="1. SQL 优化思路"></a>1. SQL 优化思路</h2><ul><li>只查需要的字段，避免 SELECT *</li><li>WHERE 条件优先用索引列</li><li>合理使用 LIMIT，避免大 OFFSET</li><li>拆分大 SQL，减少锁表</li><li>预估数据量，选择合适的分页方式</li></ul><h2 id="2-EXPLAIN-执行计划分析"><a href="#2-EXPLAIN-执行计划分析" class="headerlink" title="2. EXPLAIN 执行计划分析"></a>2. EXPLAIN 执行计划分析</h2><ul><li><code>EXPLAIN SELECT ...</code> 查看 SQL 执行路径</li><li>关注 type、key、rows、Extra 字段</li><li>type 越靠近 const 性能越好（const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL）</li><li>Extra 字段出现 Using filesort、Using temporary 需警惕</li></ul><h2 id="3-慢查询分析"><a href="#3-慢查询分析" class="headerlink" title="3. 慢查询分析"></a>3. 慢查询分析</h2><ul><li>开启慢查询日志：<code>SET GLOBAL slow_query_log = 1;</code></li><li>查看慢查询日志文件位置：<code>SHOW VARIABLES LIKE &#39;slow_query_log%&#39;;</code></li><li>使用 mysqldumpslow、pt-query-digest 工具分析</li></ul><h2 id="4-常见-SQL-反模式"><a href="#4-常见-SQL-反模式" class="headerlink" title="4. 常见 SQL 反模式"></a>4. 常见 SQL 反模式</h2><ul><li>在 WHERE 中对索引列做函数&#x2F;运算</li><li>隐式类型转换</li><li>过多 JOIN 或子查询</li><li>过度依赖临时表、filesort</li><li>大表分页 OFFSET N 性能差</li></ul><h2 id="5-分页优化"><a href="#5-分页优化" class="headerlink" title="5. 分页优化"></a>5. 分页优化</h2><ul><li>大数据量分页推荐主键游标法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> ? <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id LIMIT <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><ul><li>避免 <code>LIMIT 10000, 20</code> 这种大偏移量</li></ul><h2 id="6-索引选择与优化"><a href="#6-索引选择与优化" class="headerlink" title="6. 索引选择与优化"></a>6. 索引选择与优化</h2><ul><li>使用覆盖索引减少回表</li><li>联合索引遵循最左前缀原则</li><li>定期用 <code>SHOW INDEX</code> 检查冗余索引</li></ul><h2 id="7-实际案例分析"><a href="#7-实际案例分析" class="headerlink" title="7. 实际案例分析"></a>7. 实际案例分析</h2><h3 id="案例1：索引未命中"><a href="#案例1：索引未命中" class="headerlink" title="案例1：索引未命中"></a>案例1：索引未命中</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">YEAR</span>(created_at) <span class="hljs-operator">=</span> <span class="hljs-number">2024</span>;<br><span class="hljs-comment">-- 索引失效，建议改为：</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> created_at <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2024-01-01&#x27;</span> <span class="hljs-keyword">AND</span> created_at <span class="hljs-operator">&lt;</span> <span class="hljs-string">&#x27;2025-01-01&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="案例2：大表分页优化"><a href="#案例2：大表分页优化" class="headerlink" title="案例2：大表分页优化"></a>案例2：大表分页优化</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100000</span> LIMIT <span class="hljs-number">20</span>;<br><span class="hljs-comment">-- 替代 OFFSET 100000, 20</span><br></code></pre></td></tr></table></figure><hr><p>SQL 优化是持续过程，建议结合 EXPLAIN、慢查询日志和实际业务场景不断调优。 </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 查询优化 </tag>
            
            <tag> 执行计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引原理与优化实战</title>
      <link href="/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/"/>
      <url>/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL索引原理与优化实战"><a href="#MySQL索引原理与优化实战" class="headerlink" title="MySQL索引原理与优化实战"></a>MySQL索引原理与优化实战</h1><p>MySQL 索引是高性能查询的核心。本文深入剖析索引底层原理、常见类型、优化技巧及面试高频考点。</p><h2 id="1-索引类型"><a href="#1-索引类型" class="headerlink" title="1. 索引类型"></a>1. 索引类型</h2><ul><li><strong>主键索引（Primary Key）</strong>：唯一且不能为空，InnoDB表默认聚簇索引。</li><li><strong>唯一索引（Unique）</strong>：唯一但可为空。</li><li><strong>普通索引（Index）</strong>：无唯一性约束。</li><li><strong>全文索引（Fulltext）</strong>：适合大文本字段全文检索。</li><li><strong>联合索引（Composite Index）</strong>：多个字段组成的索引。</li></ul><h2 id="2-B-树索引结构"><a href="#2-B-树索引结构" class="headerlink" title="2. B+树索引结构"></a>2. B+树索引结构</h2><ul><li>InnoDB 默认采用 B+树索引。</li><li>聚簇索引：数据和主键索引存储在一起。</li><li>二级索引：叶子节点存储主键值，需回表查询数据。</li></ul><h2 id="3-索引失效场景"><a href="#3-索引失效场景" class="headerlink" title="3. 索引失效场景"></a>3. 索引失效场景</h2><ul><li>WHERE 条件中对索引列进行函数&#x2F;运算（如 <code>WHERE YEAR(date_col)=2024</code>）。</li><li>隐式类型转换（如字符串和数字比较）。</li><li>LIKE 以 <code>%</code> 开头（如 <code>LIKE &#39;%abc&#39;</code>）。</li><li>OR 连接未全部用到索引。</li><li>索引列未出现在最左前缀。</li></ul><h2 id="4-联合索引与最左前缀原则"><a href="#4-联合索引与最左前缀原则" class="headerlink" title="4. 联合索引与最左前缀原则"></a>4. 联合索引与最左前缀原则</h2><ul><li>联合索引如 (a, b, c)，可用于 (a)、(a, b)、(a, b, c) 的查询。</li><li>WHERE b&#x3D;… 无法单独用到 (a, b, c) 联合索引。</li><li>建议将区分度高的字段放在前面。</li></ul><h2 id="5-覆盖索引（索引覆盖查询）"><a href="#5-覆盖索引（索引覆盖查询）" class="headerlink" title="5. 覆盖索引（索引覆盖查询）"></a>5. 覆盖索引（索引覆盖查询）</h2><ul><li>查询字段全部在索引中，无需回表，提升性能。</li><li>例：<code>SELECT id, name FROM users WHERE id &gt; 10;</code> 若 (id, name) 有联合索引。</li></ul><h2 id="6-索引优化建议"><a href="#6-索引优化建议" class="headerlink" title="6. 索引优化建议"></a>6. 索引优化建议</h2><ul><li>只为高频查询和过滤字段建索引，避免过多索引拖慢写入。</li><li>使用 EXPLAIN 分析 SQL 是否走索引。</li><li>定期清理冗余和低效索引。</li><li>避免在小表、低基数字段上建索引。</li></ul><h2 id="7-常见面试题"><a href="#7-常见面试题" class="headerlink" title="7. 常见面试题"></a>7. 常见面试题</h2><ul><li>聚簇索引与非聚簇索引区别？</li><li>覆盖索引的原理和优势？</li><li>联合索引的最左前缀原则？</li><li>为什么索引用 B+树而不是哈希&#x2F;二叉树？</li></ul><h2 id="8-EXPLAIN-关键字段简析"><a href="#8-EXPLAIN-关键字段简析" class="headerlink" title="8. EXPLAIN 关键字段简析"></a>8. EXPLAIN 关键字段简析</h2><ul><li>type: 查询类型（ALL、index、range、ref、eq_ref、const、system）</li><li>key: 实际使用的索引</li><li>rows: 预估扫描行数</li><li>Extra: 是否使用了 Using index、Using where、Using filesort</li></ul><hr><p>索引优化是 MySQL 性能调优的核心，建议结合实际业务场景和 SQL 语句灵活设计。 </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL语法详解</title>
      <link href="/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/%E7%AC%94%E8%AE%B0/MySQL%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL语法详解"><a href="#MySQL语法详解" class="headerlink" title="MySQL语法详解"></a>MySQL语法详解</h1><p>本文系统梳理 MySQL 常用语法，涵盖表结构、数据操作、查询优化、事务控制、索引、常用函数等，适合进阶学习与查阅。</p><h2 id="1-数据定义语言（DDL）"><a href="#1-数据定义语言（DDL）" class="headerlink" title="1. 数据定义语言（DDL）"></a>1. 数据定义语言（DDL）</h2><h3 id="创建数据库和表"><a href="#创建数据库和表" class="headerlink" title="创建数据库和表"></a>创建数据库和表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE dbname <span class="hljs-keyword">CHARACTER SET</span> utf8mb4;<br>USE dbname;<br><br><span class="hljs-keyword">CREATE TABLE</span> users (<br>  id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  age <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">18</span>,<br>  email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">UNIQUE</span>,<br>  created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span><br>);<br></code></pre></td></tr></table></figure><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> users <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;M&#x27;</span>;<br><span class="hljs-keyword">ALTER TABLE</span> users <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> gender;<br><span class="hljs-keyword">ALTER TABLE</span> users MODIFY <span class="hljs-keyword">COLUMN</span> age <span class="hljs-type">SMALLINT</span>;<br><span class="hljs-keyword">ALTER TABLE</span> users CHANGE name username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h3 id="删除表-数据库"><a href="#删除表-数据库" class="headerlink" title="删除表&#x2F;数据库"></a>删除表&#x2F;数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> users;<br><span class="hljs-keyword">DROP</span> DATABASE IF <span class="hljs-keyword">EXISTS</span> dbname;<br></code></pre></td></tr></table></figure><h2 id="2-数据操作语言（DML）"><a href="#2-数据操作语言（DML）" class="headerlink" title="2. 数据操作语言（DML）"></a>2. 数据操作语言（DML）</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> users (name, age, email) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;alice@example.com&#x27;</span>);<br><span class="hljs-keyword">INSERT INTO</span> users <span class="hljs-keyword">SET</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Bob&#x27;</span>, age<span class="hljs-operator">=</span><span class="hljs-number">22</span>, email<span class="hljs-operator">=</span><span class="hljs-string">&#x27;bob@example.com&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">SET</span> age<span class="hljs-operator">=</span><span class="hljs-number">21</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Alice&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">18</span>;<br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> users; <span class="hljs-comment">-- 清空表并重置自增</span><br></code></pre></td></tr></table></figure><h2 id="3-数据查询语言（DQL）"><a href="#3-数据查询语言（DQL）" class="headerlink" title="3. 数据查询语言（DQL）"></a>3. 数据查询语言（DQL）</h2><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users;<br><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">18</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h3 id="聚合与分组"><a href="#聚合与分组" class="headerlink" title="聚合与分组"></a>聚合与分组</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> total, <span class="hljs-built_in">AVG</span>(age) <span class="hljs-keyword">FROM</span> users;<br><span class="hljs-keyword">SELECT</span> age, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> u.name, o.amount<br><span class="hljs-keyword">FROM</span> users u<br><span class="hljs-keyword">JOIN</span> orders o <span class="hljs-keyword">ON</span> u.id <span class="hljs-operator">=</span> o.user_id<br><span class="hljs-keyword">WHERE</span> o.amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>;<br><br><span class="hljs-comment">-- 左连接</span><br><span class="hljs-keyword">SELECT</span> u.name, o.amount<br><span class="hljs-keyword">FROM</span> users u<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> orders o <span class="hljs-keyword">ON</span> u.id <span class="hljs-operator">=</span> o.user_id;<br></code></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> user_id <span class="hljs-keyword">FROM</span> orders <span class="hljs-keyword">WHERE</span> amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> adult_users <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">18</span>;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> IF <span class="hljs-keyword">EXISTS</span> adult_users;<br></code></pre></td></tr></table></figure><h2 id="4-索引与约束"><a href="#4-索引与约束" class="headerlink" title="4. 索引与约束"></a>4. 索引与约束</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_age <span class="hljs-keyword">ON</span> users(age);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_email <span class="hljs-keyword">ON</span> users(email);<br><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> users;<br><span class="hljs-keyword">DROP</span> INDEX idx_age <span class="hljs-keyword">ON</span> users;<br></code></pre></td></tr></table></figure><h3 id="主键与外键"><a href="#主键与外键" class="headerlink" title="主键与外键"></a>主键与外键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> orders <span class="hljs-keyword">ADD CONSTRAINT</span> fk_user <span class="hljs-keyword">FOREIGN KEY</span> (user_id) <span class="hljs-keyword">REFERENCES</span> users(id);<br></code></pre></td></tr></table></figure><h2 id="5-事务与锁"><a href="#5-事务与锁" class="headerlink" title="5. 事务与锁"></a>5. 事务与锁</h2><h3 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-keyword">UPDATE</span> users <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> age <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">COMMIT</span>;<br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br></code></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><h2 id="6-常用函数"><a href="#6-常用函数" class="headerlink" title="6. 常用函数"></a>6. 常用函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">CONCAT(name, <span class="hljs-string">&#x27;-&#x27;</span>, email)<br><span class="hljs-built_in">UPPER</span>(name)<br><span class="hljs-built_in">LOWER</span>(email)<br><span class="hljs-built_in">SUBSTRING</span>(name, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>REPLACE(email, <span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;#&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">NOW()<br>CURDATE()<br>DATE_FORMAT(created_at, <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)<br>TIMESTAMPDIFF(<span class="hljs-keyword">YEAR</span>, created_at, NOW())<br></code></pre></td></tr></table></figure><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">ROUND(<span class="hljs-number">3.1415</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">FLOOR</span>(age<span class="hljs-operator">/</span><span class="hljs-number">10</span>)<br>RAND()<br></code></pre></td></tr></table></figure><h2 id="7-性能优化建议"><a href="#7-性能优化建议" class="headerlink" title="7. 性能优化建议"></a>7. 性能优化建议</h2><ul><li>合理建索引，避免全表扫描</li><li>使用 EXPLAIN 分析 SQL 执行计划</li><li>避免 SELECT *，只查需要的字段</li><li>WHERE 条件优先用索引列</li><li>分页查询时避免大 OFFSET，可用主键游标</li><li>定期优化表（OPTIMIZE TABLE）</li></ul><h2 id="8-其他常用语法"><a href="#8-其他常用语法" class="headerlink" title="8. 其他常用语法"></a>8. 其他常用语法</h2><h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 导出</span><br>mysqldump <span class="hljs-operator">-</span>u <span class="hljs-keyword">user</span> <span class="hljs-operator">-</span>p dbname <span class="hljs-operator">&gt;</span> backup.sql<br><span class="hljs-comment">-- 导入</span><br>mysql <span class="hljs-operator">-</span>u <span class="hljs-keyword">user</span> <span class="hljs-operator">-</span>p dbname <span class="hljs-operator">&lt;</span> backup.sql<br></code></pre></td></tr></table></figure><h3 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;test&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> dbname.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;test&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><hr><p>如需更详细的语法或特定场景示例，可在评论区留言或查阅官方文档。 </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
